// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rpcpb.proto

package rpcpb

import (
	fmt "fmt"
	io "io"
	math "math"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	metapb "github.com/matrixorigin/matrixcube/components/prophet/pb/metapb"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Type rpc type
type Type int32

const (
	TypeRegisterContainer     Type = 0
	TypeResourceHeartbeatReq  Type = 1
	TypeResourceHeartbeatRsp  Type = 2
	TypeContainerHeartbeatReq Type = 3
	TypeContainerHeartbeatRsp Type = 4
	TypePutContainerReq       Type = 5
	TypePutContainerRsp       Type = 6
	TypeGetContainerReq       Type = 7
	TypeGetContainerRsp       Type = 8
	TypeAllocIDReq            Type = 9
	TypeAllocIDRsp            Type = 10
	TypeAskSplitReq           Type = 11
	TypeAskSplitRsp           Type = 12
	TypeAskBatchSplitReq      Type = 13
	TypeAskBatchSplitRsp      Type = 14
	TypeReportSplitReq        Type = 15
	TypeReportSplitRsp        Type = 16
	TypeBatchReportSplitReq   Type = 17
	TypeBatchReportSplitRsp   Type = 18
	TypeCreateWatcherReq      Type = 19
	TypeEventNotify           Type = 20
)

var Type_name = map[int32]string{
	0:  "TypeRegisterContainer",
	1:  "TypeResourceHeartbeatReq",
	2:  "TypeResourceHeartbeatRsp",
	3:  "TypeContainerHeartbeatReq",
	4:  "TypeContainerHeartbeatRsp",
	5:  "TypePutContainerReq",
	6:  "TypePutContainerRsp",
	7:  "TypeGetContainerReq",
	8:  "TypeGetContainerRsp",
	9:  "TypeAllocIDReq",
	10: "TypeAllocIDRsp",
	11: "TypeAskSplitReq",
	12: "TypeAskSplitRsp",
	13: "TypeAskBatchSplitReq",
	14: "TypeAskBatchSplitRsp",
	15: "TypeReportSplitReq",
	16: "TypeReportSplitRsp",
	17: "TypeBatchReportSplitReq",
	18: "TypeBatchReportSplitRsp",
	19: "TypeCreateWatcherReq",
	20: "TypeEventNotify",
}

var Type_value = map[string]int32{
	"TypeRegisterContainer":     0,
	"TypeResourceHeartbeatReq":  1,
	"TypeResourceHeartbeatRsp":  2,
	"TypeContainerHeartbeatReq": 3,
	"TypeContainerHeartbeatRsp": 4,
	"TypePutContainerReq":       5,
	"TypePutContainerRsp":       6,
	"TypeGetContainerReq":       7,
	"TypeGetContainerRsp":       8,
	"TypeAllocIDReq":            9,
	"TypeAllocIDRsp":            10,
	"TypeAskSplitReq":           11,
	"TypeAskSplitRsp":           12,
	"TypeAskBatchSplitReq":      13,
	"TypeAskBatchSplitRsp":      14,
	"TypeReportSplitReq":        15,
	"TypeReportSplitRsp":        16,
	"TypeBatchReportSplitReq":   17,
	"TypeBatchReportSplitRsp":   18,
	"TypeCreateWatcherReq":      19,
	"TypeEventNotify":           20,
}

func (x Type) String() string {
	return proto.EnumName(Type_name, int32(x))
}

func (Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{0}
}

// Request the prophet rpc request
type Request struct {
	ID                   uint64                `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	ContainerID          uint64                `protobuf:"varint,2,opt,name=containerID,proto3" json:"containerID,omitempty"`
	Type                 Type                  `protobuf:"varint,3,opt,name=type,proto3,enum=rpcpb.Type" json:"type,omitempty"`
	ResourceHeartbeat    ResourceHeartbeatReq  `protobuf:"bytes,4,opt,name=ResourceHeartbeat,proto3" json:"ResourceHeartbeat"`
	ContainerHeartbeat   ContainerHeartbeatReq `protobuf:"bytes,5,opt,name=ContainerHeartbeat,proto3" json:"ContainerHeartbeat"`
	PutContainer         PutContainerReq       `protobuf:"bytes,6,opt,name=PutContainer,proto3" json:"PutContainer"`
	GetContainer         GetContainerReq       `protobuf:"bytes,7,opt,name=GetContainer,proto3" json:"GetContainer"`
	AllocID              AllocIDReq            `protobuf:"bytes,8,opt,name=AllocID,proto3" json:"AllocID"`
	AskSplit             AskSplitReq           `protobuf:"bytes,9,opt,name=AskSplit,proto3" json:"AskSplit"`
	AskBatchSplit        AskBatchSplitReq      `protobuf:"bytes,10,opt,name=AskBatchSplit,proto3" json:"AskBatchSplit"`
	ReportSplit          ReportSplitReq        `protobuf:"bytes,11,opt,name=ReportSplit,proto3" json:"ReportSplit"`
	BatchReportSplit     BatchReportSplitReq   `protobuf:"bytes,12,opt,name=BatchReportSplit,proto3" json:"BatchReportSplit"`
	CreateWatcher        CreateWatcherReq      `protobuf:"bytes,13,opt,name=CreateWatcher,proto3" json:"CreateWatcher"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{0}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Request) GetContainerID() uint64 {
	if m != nil {
		return m.ContainerID
	}
	return 0
}

func (m *Request) GetType() Type {
	if m != nil {
		return m.Type
	}
	return TypeRegisterContainer
}

func (m *Request) GetResourceHeartbeat() ResourceHeartbeatReq {
	if m != nil {
		return m.ResourceHeartbeat
	}
	return ResourceHeartbeatReq{}
}

func (m *Request) GetContainerHeartbeat() ContainerHeartbeatReq {
	if m != nil {
		return m.ContainerHeartbeat
	}
	return ContainerHeartbeatReq{}
}

func (m *Request) GetPutContainer() PutContainerReq {
	if m != nil {
		return m.PutContainer
	}
	return PutContainerReq{}
}

func (m *Request) GetGetContainer() GetContainerReq {
	if m != nil {
		return m.GetContainer
	}
	return GetContainerReq{}
}

func (m *Request) GetAllocID() AllocIDReq {
	if m != nil {
		return m.AllocID
	}
	return AllocIDReq{}
}

func (m *Request) GetAskSplit() AskSplitReq {
	if m != nil {
		return m.AskSplit
	}
	return AskSplitReq{}
}

func (m *Request) GetAskBatchSplit() AskBatchSplitReq {
	if m != nil {
		return m.AskBatchSplit
	}
	return AskBatchSplitReq{}
}

func (m *Request) GetReportSplit() ReportSplitReq {
	if m != nil {
		return m.ReportSplit
	}
	return ReportSplitReq{}
}

func (m *Request) GetBatchReportSplit() BatchReportSplitReq {
	if m != nil {
		return m.BatchReportSplit
	}
	return BatchReportSplitReq{}
}

func (m *Request) GetCreateWatcher() CreateWatcherReq {
	if m != nil {
		return m.CreateWatcher
	}
	return CreateWatcherReq{}
}

// Response the prophet rpc response
type Response struct {
	ID                   uint64                `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type                 Type                  `protobuf:"varint,2,opt,name=type,proto3,enum=rpcpb.Type" json:"type,omitempty"`
	Error                string                `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	Leader               string                `protobuf:"bytes,4,opt,name=leader,proto3" json:"leader,omitempty"`
	ResourceHeartbeat    ResourceHeartbeatRsp  `protobuf:"bytes,5,opt,name=ResourceHeartbeat,proto3" json:"ResourceHeartbeat"`
	ContainerHeartbeat   ContainerHeartbeatRsp `protobuf:"bytes,6,opt,name=ContainerHeartbeat,proto3" json:"ContainerHeartbeat"`
	PutContainer         PutContainerRsp       `protobuf:"bytes,7,opt,name=PutContainer,proto3" json:"PutContainer"`
	GetContainer         GetContainerRsp       `protobuf:"bytes,8,opt,name=GetContainer,proto3" json:"GetContainer"`
	AllocID              AllocIDRsp            `protobuf:"bytes,9,opt,name=AllocID,proto3" json:"AllocID"`
	AskSplit             AskSplitRsp           `protobuf:"bytes,10,opt,name=AskSplit,proto3" json:"AskSplit"`
	AskBatchSplit        AskBatchSplitRsp      `protobuf:"bytes,11,opt,name=AskBatchSplit,proto3" json:"AskBatchSplit"`
	ReportSplit          ReportSplitRsp        `protobuf:"bytes,12,opt,name=ReportSplit,proto3" json:"ReportSplit"`
	BatchReportSplit     BatchReportSplitRsp   `protobuf:"bytes,13,opt,name=BatchReportSplit,proto3" json:"BatchReportSplit"`
	Event                EventNotify           `protobuf:"bytes,14,opt,name=Event,proto3" json:"Event"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{1}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Response) GetType() Type {
	if m != nil {
		return m.Type
	}
	return TypeRegisterContainer
}

func (m *Response) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *Response) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

func (m *Response) GetResourceHeartbeat() ResourceHeartbeatRsp {
	if m != nil {
		return m.ResourceHeartbeat
	}
	return ResourceHeartbeatRsp{}
}

func (m *Response) GetContainerHeartbeat() ContainerHeartbeatRsp {
	if m != nil {
		return m.ContainerHeartbeat
	}
	return ContainerHeartbeatRsp{}
}

func (m *Response) GetPutContainer() PutContainerRsp {
	if m != nil {
		return m.PutContainer
	}
	return PutContainerRsp{}
}

func (m *Response) GetGetContainer() GetContainerRsp {
	if m != nil {
		return m.GetContainer
	}
	return GetContainerRsp{}
}

func (m *Response) GetAllocID() AllocIDRsp {
	if m != nil {
		return m.AllocID
	}
	return AllocIDRsp{}
}

func (m *Response) GetAskSplit() AskSplitRsp {
	if m != nil {
		return m.AskSplit
	}
	return AskSplitRsp{}
}

func (m *Response) GetAskBatchSplit() AskBatchSplitRsp {
	if m != nil {
		return m.AskBatchSplit
	}
	return AskBatchSplitRsp{}
}

func (m *Response) GetReportSplit() ReportSplitRsp {
	if m != nil {
		return m.ReportSplit
	}
	return ReportSplitRsp{}
}

func (m *Response) GetBatchReportSplit() BatchReportSplitRsp {
	if m != nil {
		return m.BatchReportSplit
	}
	return BatchReportSplitRsp{}
}

func (m *Response) GetEvent() EventNotify {
	if m != nil {
		return m.Event
	}
	return EventNotify{}
}

// ResourceHeartbeatReq resource heartbeat request
type ResourceHeartbeatReq struct {
	ContainerID uint64 `protobuf:"varint,1,opt,name=containerID,proto3" json:"containerID,omitempty"`
	Resource    []byte `protobuf:"bytes,2,opt,name=resource,proto3" json:"resource,omitempty"`
	// Term is the term of raft group.
	Term         uint64             `protobuf:"varint,3,opt,name=term,proto3" json:"term,omitempty"`
	Leader       *metapb.Peer       `protobuf:"bytes,4,opt,name=leader,proto3" json:"leader,omitempty"`
	DownPeers    []metapb.PeerStats `protobuf:"bytes,5,rep,name=downPeers,proto3" json:"downPeers"`
	PendingPeers []metapb.Peer      `protobuf:"bytes,6,rep,name=pendingPeers,proto3" json:"pendingPeers"`
	// Bytes read/written during this period.
	BytesWritten uint64 `protobuf:"varint,7,opt,name=bytesWritten,proto3" json:"bytesWritten,omitempty"`
	BytesRead    uint64 `protobuf:"varint,8,opt,name=bytesRead,proto3" json:"bytesRead,omitempty"`
	// Keys read/written during this period.
	KeysWritten uint64 `protobuf:"varint,9,opt,name=keysWritten,proto3" json:"keysWritten,omitempty"`
	KeysRead    uint64 `protobuf:"varint,10,opt,name=keysRead,proto3" json:"keysRead,omitempty"`
	// Approximate  resource size in bytes.
	ApproximateSize uint64 `protobuf:"varint,11,opt,name=approximateSize,proto3" json:"approximateSize,omitempty"`
	// Approximate keys that resource contains.
	ApproximateKeys uint64 `protobuf:"varint,12,opt,name=approximateKeys,proto3" json:"approximateKeys,omitempty"`
	// Actually reported time interval
	Interval             *TimeInterval `protobuf:"bytes,13,opt,name=interval,proto3" json:"interval,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ResourceHeartbeatReq) Reset()         { *m = ResourceHeartbeatReq{} }
func (m *ResourceHeartbeatReq) String() string { return proto.CompactTextString(m) }
func (*ResourceHeartbeatReq) ProtoMessage()    {}
func (*ResourceHeartbeatReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{2}
}
func (m *ResourceHeartbeatReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceHeartbeatReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceHeartbeatReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceHeartbeatReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceHeartbeatReq.Merge(m, src)
}
func (m *ResourceHeartbeatReq) XXX_Size() int {
	return m.Size()
}
func (m *ResourceHeartbeatReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceHeartbeatReq.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceHeartbeatReq proto.InternalMessageInfo

func (m *ResourceHeartbeatReq) GetContainerID() uint64 {
	if m != nil {
		return m.ContainerID
	}
	return 0
}

func (m *ResourceHeartbeatReq) GetResource() []byte {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *ResourceHeartbeatReq) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *ResourceHeartbeatReq) GetLeader() *metapb.Peer {
	if m != nil {
		return m.Leader
	}
	return nil
}

func (m *ResourceHeartbeatReq) GetDownPeers() []metapb.PeerStats {
	if m != nil {
		return m.DownPeers
	}
	return nil
}

func (m *ResourceHeartbeatReq) GetPendingPeers() []metapb.Peer {
	if m != nil {
		return m.PendingPeers
	}
	return nil
}

func (m *ResourceHeartbeatReq) GetBytesWritten() uint64 {
	if m != nil {
		return m.BytesWritten
	}
	return 0
}

func (m *ResourceHeartbeatReq) GetBytesRead() uint64 {
	if m != nil {
		return m.BytesRead
	}
	return 0
}

func (m *ResourceHeartbeatReq) GetKeysWritten() uint64 {
	if m != nil {
		return m.KeysWritten
	}
	return 0
}

func (m *ResourceHeartbeatReq) GetKeysRead() uint64 {
	if m != nil {
		return m.KeysRead
	}
	return 0
}

func (m *ResourceHeartbeatReq) GetApproximateSize() uint64 {
	if m != nil {
		return m.ApproximateSize
	}
	return 0
}

func (m *ResourceHeartbeatReq) GetApproximateKeys() uint64 {
	if m != nil {
		return m.ApproximateKeys
	}
	return 0
}

func (m *ResourceHeartbeatReq) GetInterval() *TimeInterval {
	if m != nil {
		return m.Interval
	}
	return nil
}

// ResourceHeartbeatRsp resource heartbeat response.
type ResourceHeartbeatRsp struct {
	ResourceID    uint64               `protobuf:"varint,1,opt,name=resourceID,proto3" json:"resourceID,omitempty"`
	ResourceEpoch metapb.ResourceEpoch `protobuf:"bytes,2,opt,name=resourceEpoch,proto3" json:"resourceEpoch"`
	// Leader of the resource at the moment of the corresponding request was made.
	TargetPeer *metapb.Peer `protobuf:"bytes,3,opt,name=targetPeer,proto3" json:"targetPeer,omitempty"`
	// Notice, prophet only allows handling reported epoch >= current prophet's.
	// Leader peer reports resource status with ResourceHeartbeatReq
	// to prophet regularly, prophet will determine whether this resource
	// should do ChangePeer or not.
	// E,g, max peer number is 3, resource A, first only peer 1 in A.
	// 1. prophet resource state -> Peers (1), ConfVer (1).
	// 2. Leader peer 1 reports resource state to prophet, prophet finds the
	// peer number is < 3, so first changes its current resource
	// state -> Peers (1, 2), ConfVer (1), and returns ChangePeer Adding 2.
	// 3. Leader does ChangePeer, then reports Peers (1, 2), ConfVer (2),
	// prophet updates its state -> Peers (1, 2), ConfVer (2).
	// 4. Leader may report old Peers (1), ConfVer (1) to pd before ConfChange
	// finished, pd stills responses ChangePeer Adding 2, of course, we must
	// guarantee the second ChangePeer can't be applied in your application.
	ChangePeer           *ChangePeer     `protobuf:"bytes,4,opt,name=changePeer,proto3" json:"changePeer,omitempty"`
	TransferLeader       *TransferLeader `protobuf:"bytes,5,opt,name=transferLeader,proto3" json:"transferLeader,omitempty"`
	Merge                *Merge          `protobuf:"bytes,6,opt,name=merge,proto3" json:"merge,omitempty"`
	SplitResource        *SplitResource  `protobuf:"bytes,7,opt,name=splitResource,proto3" json:"splitResource,omitempty"`
	ChangePeerV2         *ChangePeerV2   `protobuf:"bytes,8,opt,name=changePeerV2,proto3" json:"changePeerV2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ResourceHeartbeatRsp) Reset()         { *m = ResourceHeartbeatRsp{} }
func (m *ResourceHeartbeatRsp) String() string { return proto.CompactTextString(m) }
func (*ResourceHeartbeatRsp) ProtoMessage()    {}
func (*ResourceHeartbeatRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{3}
}
func (m *ResourceHeartbeatRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceHeartbeatRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceHeartbeatRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceHeartbeatRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceHeartbeatRsp.Merge(m, src)
}
func (m *ResourceHeartbeatRsp) XXX_Size() int {
	return m.Size()
}
func (m *ResourceHeartbeatRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceHeartbeatRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceHeartbeatRsp proto.InternalMessageInfo

func (m *ResourceHeartbeatRsp) GetResourceID() uint64 {
	if m != nil {
		return m.ResourceID
	}
	return 0
}

func (m *ResourceHeartbeatRsp) GetResourceEpoch() metapb.ResourceEpoch {
	if m != nil {
		return m.ResourceEpoch
	}
	return metapb.ResourceEpoch{}
}

func (m *ResourceHeartbeatRsp) GetTargetPeer() *metapb.Peer {
	if m != nil {
		return m.TargetPeer
	}
	return nil
}

func (m *ResourceHeartbeatRsp) GetChangePeer() *ChangePeer {
	if m != nil {
		return m.ChangePeer
	}
	return nil
}

func (m *ResourceHeartbeatRsp) GetTransferLeader() *TransferLeader {
	if m != nil {
		return m.TransferLeader
	}
	return nil
}

func (m *ResourceHeartbeatRsp) GetMerge() *Merge {
	if m != nil {
		return m.Merge
	}
	return nil
}

func (m *ResourceHeartbeatRsp) GetSplitResource() *SplitResource {
	if m != nil {
		return m.SplitResource
	}
	return nil
}

func (m *ResourceHeartbeatRsp) GetChangePeerV2() *ChangePeerV2 {
	if m != nil {
		return m.ChangePeerV2
	}
	return nil
}

// PutContainerReq put container request
type PutContainerReq struct {
	Container            []byte   `protobuf:"bytes,1,opt,name=container,proto3" json:"container,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PutContainerReq) Reset()         { *m = PutContainerReq{} }
func (m *PutContainerReq) String() string { return proto.CompactTextString(m) }
func (*PutContainerReq) ProtoMessage()    {}
func (*PutContainerReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{4}
}
func (m *PutContainerReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutContainerReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutContainerReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutContainerReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutContainerReq.Merge(m, src)
}
func (m *PutContainerReq) XXX_Size() int {
	return m.Size()
}
func (m *PutContainerReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PutContainerReq.DiscardUnknown(m)
}

var xxx_messageInfo_PutContainerReq proto.InternalMessageInfo

func (m *PutContainerReq) GetContainer() []byte {
	if m != nil {
		return m.Container
	}
	return nil
}

// PutContainerRsp put container response
type PutContainerRsp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PutContainerRsp) Reset()         { *m = PutContainerRsp{} }
func (m *PutContainerRsp) String() string { return proto.CompactTextString(m) }
func (*PutContainerRsp) ProtoMessage()    {}
func (*PutContainerRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{5}
}
func (m *PutContainerRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutContainerRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutContainerRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutContainerRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutContainerRsp.Merge(m, src)
}
func (m *PutContainerRsp) XXX_Size() int {
	return m.Size()
}
func (m *PutContainerRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_PutContainerRsp.DiscardUnknown(m)
}

var xxx_messageInfo_PutContainerRsp proto.InternalMessageInfo

// ContainerHeartbeatReq container heartbeat request
type ContainerHeartbeatReq struct {
	Stats                ContainerStats `protobuf:"bytes,1,opt,name=stats,proto3" json:"stats"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ContainerHeartbeatReq) Reset()         { *m = ContainerHeartbeatReq{} }
func (m *ContainerHeartbeatReq) String() string { return proto.CompactTextString(m) }
func (*ContainerHeartbeatReq) ProtoMessage()    {}
func (*ContainerHeartbeatReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{6}
}
func (m *ContainerHeartbeatReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerHeartbeatReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerHeartbeatReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerHeartbeatReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerHeartbeatReq.Merge(m, src)
}
func (m *ContainerHeartbeatReq) XXX_Size() int {
	return m.Size()
}
func (m *ContainerHeartbeatReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerHeartbeatReq.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerHeartbeatReq proto.InternalMessageInfo

func (m *ContainerHeartbeatReq) GetStats() ContainerStats {
	if m != nil {
		return m.Stats
	}
	return ContainerStats{}
}

// ContainerHeartbeatRsp container heartbeat response
type ContainerHeartbeatRsp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ContainerHeartbeatRsp) Reset()         { *m = ContainerHeartbeatRsp{} }
func (m *ContainerHeartbeatRsp) String() string { return proto.CompactTextString(m) }
func (*ContainerHeartbeatRsp) ProtoMessage()    {}
func (*ContainerHeartbeatRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{7}
}
func (m *ContainerHeartbeatRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerHeartbeatRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerHeartbeatRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerHeartbeatRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerHeartbeatRsp.Merge(m, src)
}
func (m *ContainerHeartbeatRsp) XXX_Size() int {
	return m.Size()
}
func (m *ContainerHeartbeatRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerHeartbeatRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerHeartbeatRsp proto.InternalMessageInfo

// GetContainerReq get container request
type GetContainerReq struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetContainerReq) Reset()         { *m = GetContainerReq{} }
func (m *GetContainerReq) String() string { return proto.CompactTextString(m) }
func (*GetContainerReq) ProtoMessage()    {}
func (*GetContainerReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{8}
}
func (m *GetContainerReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetContainerReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetContainerReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetContainerReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetContainerReq.Merge(m, src)
}
func (m *GetContainerReq) XXX_Size() int {
	return m.Size()
}
func (m *GetContainerReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetContainerReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetContainerReq proto.InternalMessageInfo

func (m *GetContainerReq) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

// GetContainerRsp get container response
type GetContainerRsp struct {
	Data                 []byte          `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Stats                *ContainerStats `protobuf:"bytes,2,opt,name=stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetContainerRsp) Reset()         { *m = GetContainerRsp{} }
func (m *GetContainerRsp) String() string { return proto.CompactTextString(m) }
func (*GetContainerRsp) ProtoMessage()    {}
func (*GetContainerRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{9}
}
func (m *GetContainerRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetContainerRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetContainerRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetContainerRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetContainerRsp.Merge(m, src)
}
func (m *GetContainerRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetContainerRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetContainerRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetContainerRsp proto.InternalMessageInfo

func (m *GetContainerRsp) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *GetContainerRsp) GetStats() *ContainerStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// AllocIDReq alloc id request
type AllocIDReq struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AllocIDReq) Reset()         { *m = AllocIDReq{} }
func (m *AllocIDReq) String() string { return proto.CompactTextString(m) }
func (*AllocIDReq) ProtoMessage()    {}
func (*AllocIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{10}
}
func (m *AllocIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllocIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllocIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocIDReq.Merge(m, src)
}
func (m *AllocIDReq) XXX_Size() int {
	return m.Size()
}
func (m *AllocIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_AllocIDReq proto.InternalMessageInfo

// AllocIDRsp alloc id response
type AllocIDRsp struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AllocIDRsp) Reset()         { *m = AllocIDRsp{} }
func (m *AllocIDRsp) String() string { return proto.CompactTextString(m) }
func (*AllocIDRsp) ProtoMessage()    {}
func (*AllocIDRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{11}
}
func (m *AllocIDRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocIDRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllocIDRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllocIDRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocIDRsp.Merge(m, src)
}
func (m *AllocIDRsp) XXX_Size() int {
	return m.Size()
}
func (m *AllocIDRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocIDRsp.DiscardUnknown(m)
}

var xxx_messageInfo_AllocIDRsp proto.InternalMessageInfo

func (m *AllocIDRsp) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

// AskSplitReq ask split request
type AskSplitReq struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AskSplitReq) Reset()         { *m = AskSplitReq{} }
func (m *AskSplitReq) String() string { return proto.CompactTextString(m) }
func (*AskSplitReq) ProtoMessage()    {}
func (*AskSplitReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{12}
}
func (m *AskSplitReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AskSplitReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AskSplitReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AskSplitReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AskSplitReq.Merge(m, src)
}
func (m *AskSplitReq) XXX_Size() int {
	return m.Size()
}
func (m *AskSplitReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AskSplitReq.DiscardUnknown(m)
}

var xxx_messageInfo_AskSplitReq proto.InternalMessageInfo

func (m *AskSplitReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// AskSplitRsp ask split response
type AskSplitRsp struct {
	SplitID              SplitID  `protobuf:"bytes,1,opt,name=splitID,proto3" json:"splitID"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AskSplitRsp) Reset()         { *m = AskSplitRsp{} }
func (m *AskSplitRsp) String() string { return proto.CompactTextString(m) }
func (*AskSplitRsp) ProtoMessage()    {}
func (*AskSplitRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{13}
}
func (m *AskSplitRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AskSplitRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AskSplitRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AskSplitRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AskSplitRsp.Merge(m, src)
}
func (m *AskSplitRsp) XXX_Size() int {
	return m.Size()
}
func (m *AskSplitRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_AskSplitRsp.DiscardUnknown(m)
}

var xxx_messageInfo_AskSplitRsp proto.InternalMessageInfo

func (m *AskSplitRsp) GetSplitID() SplitID {
	if m != nil {
		return m.SplitID
	}
	return SplitID{}
}

// ReportSplitReq report split request
type ReportSplitReq struct {
	Left                 []byte   `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Right                []byte   `protobuf:"bytes,2,opt,name=right,proto3" json:"right,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReportSplitReq) Reset()         { *m = ReportSplitReq{} }
func (m *ReportSplitReq) String() string { return proto.CompactTextString(m) }
func (*ReportSplitReq) ProtoMessage()    {}
func (*ReportSplitReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{14}
}
func (m *ReportSplitReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportSplitReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportSplitReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportSplitReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportSplitReq.Merge(m, src)
}
func (m *ReportSplitReq) XXX_Size() int {
	return m.Size()
}
func (m *ReportSplitReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportSplitReq.DiscardUnknown(m)
}

var xxx_messageInfo_ReportSplitReq proto.InternalMessageInfo

func (m *ReportSplitReq) GetLeft() []byte {
	if m != nil {
		return m.Left
	}
	return nil
}

func (m *ReportSplitReq) GetRight() []byte {
	if m != nil {
		return m.Right
	}
	return nil
}

// ReportSplitRsp report split response
type ReportSplitRsp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReportSplitRsp) Reset()         { *m = ReportSplitRsp{} }
func (m *ReportSplitRsp) String() string { return proto.CompactTextString(m) }
func (*ReportSplitRsp) ProtoMessage()    {}
func (*ReportSplitRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{15}
}
func (m *ReportSplitRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportSplitRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportSplitRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportSplitRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportSplitRsp.Merge(m, src)
}
func (m *ReportSplitRsp) XXX_Size() int {
	return m.Size()
}
func (m *ReportSplitRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportSplitRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ReportSplitRsp proto.InternalMessageInfo

// AskBatchSplitReq ask batch split request
type AskBatchSplitReq struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Count                uint32   `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AskBatchSplitReq) Reset()         { *m = AskBatchSplitReq{} }
func (m *AskBatchSplitReq) String() string { return proto.CompactTextString(m) }
func (*AskBatchSplitReq) ProtoMessage()    {}
func (*AskBatchSplitReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{16}
}
func (m *AskBatchSplitReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AskBatchSplitReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AskBatchSplitReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AskBatchSplitReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AskBatchSplitReq.Merge(m, src)
}
func (m *AskBatchSplitReq) XXX_Size() int {
	return m.Size()
}
func (m *AskBatchSplitReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AskBatchSplitReq.DiscardUnknown(m)
}

var xxx_messageInfo_AskBatchSplitReq proto.InternalMessageInfo

func (m *AskBatchSplitReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *AskBatchSplitReq) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

// AskBatchSplitRsp ask batch split response
type AskBatchSplitRsp struct {
	SplitIDs             []SplitID `protobuf:"bytes,1,rep,name=splitIDs,proto3" json:"splitIDs"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *AskBatchSplitRsp) Reset()         { *m = AskBatchSplitRsp{} }
func (m *AskBatchSplitRsp) String() string { return proto.CompactTextString(m) }
func (*AskBatchSplitRsp) ProtoMessage()    {}
func (*AskBatchSplitRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{17}
}
func (m *AskBatchSplitRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AskBatchSplitRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AskBatchSplitRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AskBatchSplitRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AskBatchSplitRsp.Merge(m, src)
}
func (m *AskBatchSplitRsp) XXX_Size() int {
	return m.Size()
}
func (m *AskBatchSplitRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_AskBatchSplitRsp.DiscardUnknown(m)
}

var xxx_messageInfo_AskBatchSplitRsp proto.InternalMessageInfo

func (m *AskBatchSplitRsp) GetSplitIDs() []SplitID {
	if m != nil {
		return m.SplitIDs
	}
	return nil
}

// BatchReportSplitReq report split request
type BatchReportSplitReq struct {
	Resources            [][]byte `protobuf:"bytes,1,rep,name=resources,proto3" json:"resources,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BatchReportSplitReq) Reset()         { *m = BatchReportSplitReq{} }
func (m *BatchReportSplitReq) String() string { return proto.CompactTextString(m) }
func (*BatchReportSplitReq) ProtoMessage()    {}
func (*BatchReportSplitReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{18}
}
func (m *BatchReportSplitReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchReportSplitReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchReportSplitReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchReportSplitReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchReportSplitReq.Merge(m, src)
}
func (m *BatchReportSplitReq) XXX_Size() int {
	return m.Size()
}
func (m *BatchReportSplitReq) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchReportSplitReq.DiscardUnknown(m)
}

var xxx_messageInfo_BatchReportSplitReq proto.InternalMessageInfo

func (m *BatchReportSplitReq) GetResources() [][]byte {
	if m != nil {
		return m.Resources
	}
	return nil
}

// BatchReportSplitRsp report split response
type BatchReportSplitRsp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BatchReportSplitRsp) Reset()         { *m = BatchReportSplitRsp{} }
func (m *BatchReportSplitRsp) String() string { return proto.CompactTextString(m) }
func (*BatchReportSplitRsp) ProtoMessage()    {}
func (*BatchReportSplitRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{19}
}
func (m *BatchReportSplitRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchReportSplitRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchReportSplitRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchReportSplitRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchReportSplitRsp.Merge(m, src)
}
func (m *BatchReportSplitRsp) XXX_Size() int {
	return m.Size()
}
func (m *BatchReportSplitRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchReportSplitRsp.DiscardUnknown(m)
}

var xxx_messageInfo_BatchReportSplitRsp proto.InternalMessageInfo

// SplitID split id
type SplitID struct {
	NewID                uint64   `protobuf:"varint,1,opt,name=newID,proto3" json:"newID,omitempty"`
	NewPeerIDs           []uint64 `protobuf:"varint,2,rep,packed,name=newPeerIDs,proto3" json:"newPeerIDs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SplitID) Reset()         { *m = SplitID{} }
func (m *SplitID) String() string { return proto.CompactTextString(m) }
func (*SplitID) ProtoMessage()    {}
func (*SplitID) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{20}
}
func (m *SplitID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitID.Merge(m, src)
}
func (m *SplitID) XXX_Size() int {
	return m.Size()
}
func (m *SplitID) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitID.DiscardUnknown(m)
}

var xxx_messageInfo_SplitID proto.InternalMessageInfo

func (m *SplitID) GetNewID() uint64 {
	if m != nil {
		return m.NewID
	}
	return 0
}

func (m *SplitID) GetNewPeerIDs() []uint64 {
	if m != nil {
		return m.NewPeerIDs
	}
	return nil
}

// CreateWatcherReq create watcher req
type CreateWatcherReq struct {
	Flag                 uint32   `protobuf:"varint,1,opt,name=flag,proto3" json:"flag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateWatcherReq) Reset()         { *m = CreateWatcherReq{} }
func (m *CreateWatcherReq) String() string { return proto.CompactTextString(m) }
func (*CreateWatcherReq) ProtoMessage()    {}
func (*CreateWatcherReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{21}
}
func (m *CreateWatcherReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateWatcherReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateWatcherReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateWatcherReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateWatcherReq.Merge(m, src)
}
func (m *CreateWatcherReq) XXX_Size() int {
	return m.Size()
}
func (m *CreateWatcherReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateWatcherReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreateWatcherReq proto.InternalMessageInfo

func (m *CreateWatcherReq) GetFlag() uint32 {
	if m != nil {
		return m.Flag
	}
	return 0
}

// EventNotify event notify
type EventNotify struct {
	Seq                  uint64              `protobuf:"varint,1,opt,name=seq,proto3" json:"seq,omitempty"`
	Type                 uint32              `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	InitEvent            *InitEventData      `protobuf:"bytes,3,opt,name=initEvent,proto3" json:"initEvent,omitempty"`
	ResourceEvent        *ResourceEventData  `protobuf:"bytes,4,opt,name=resourceEvent,proto3" json:"resourceEvent,omitempty"`
	ContainerEvent       *ContainerEventData `protobuf:"bytes,5,opt,name=containerEvent,proto3" json:"containerEvent,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *EventNotify) Reset()         { *m = EventNotify{} }
func (m *EventNotify) String() string { return proto.CompactTextString(m) }
func (*EventNotify) ProtoMessage()    {}
func (*EventNotify) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{22}
}
func (m *EventNotify) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventNotify) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventNotify.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventNotify) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventNotify.Merge(m, src)
}
func (m *EventNotify) XXX_Size() int {
	return m.Size()
}
func (m *EventNotify) XXX_DiscardUnknown() {
	xxx_messageInfo_EventNotify.DiscardUnknown(m)
}

var xxx_messageInfo_EventNotify proto.InternalMessageInfo

func (m *EventNotify) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *EventNotify) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *EventNotify) GetInitEvent() *InitEventData {
	if m != nil {
		return m.InitEvent
	}
	return nil
}

func (m *EventNotify) GetResourceEvent() *ResourceEventData {
	if m != nil {
		return m.ResourceEvent
	}
	return nil
}

func (m *EventNotify) GetContainerEvent() *ContainerEventData {
	if m != nil {
		return m.ContainerEvent
	}
	return nil
}

// InitEventData init event data
type InitEventData struct {
	Resources            [][]byte `protobuf:"bytes,1,rep,name=resources,proto3" json:"resources,omitempty"`
	Leaders              []uint64 `protobuf:"varint,2,rep,packed,name=leaders,proto3" json:"leaders,omitempty"`
	Containers           [][]byte `protobuf:"bytes,3,rep,name=containers,proto3" json:"containers,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InitEventData) Reset()         { *m = InitEventData{} }
func (m *InitEventData) String() string { return proto.CompactTextString(m) }
func (*InitEventData) ProtoMessage()    {}
func (*InitEventData) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{23}
}
func (m *InitEventData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InitEventData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InitEventData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InitEventData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitEventData.Merge(m, src)
}
func (m *InitEventData) XXX_Size() int {
	return m.Size()
}
func (m *InitEventData) XXX_DiscardUnknown() {
	xxx_messageInfo_InitEventData.DiscardUnknown(m)
}

var xxx_messageInfo_InitEventData proto.InternalMessageInfo

func (m *InitEventData) GetResources() [][]byte {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *InitEventData) GetLeaders() []uint64 {
	if m != nil {
		return m.Leaders
	}
	return nil
}

func (m *InitEventData) GetContainers() [][]byte {
	if m != nil {
		return m.Containers
	}
	return nil
}

// ResourceEventData resource created or updated
type ResourceEventData struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Leader               uint64   `protobuf:"varint,2,opt,name=leader,proto3" json:"leader,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResourceEventData) Reset()         { *m = ResourceEventData{} }
func (m *ResourceEventData) String() string { return proto.CompactTextString(m) }
func (*ResourceEventData) ProtoMessage()    {}
func (*ResourceEventData) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{24}
}
func (m *ResourceEventData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceEventData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceEventData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceEventData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceEventData.Merge(m, src)
}
func (m *ResourceEventData) XXX_Size() int {
	return m.Size()
}
func (m *ResourceEventData) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceEventData.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceEventData proto.InternalMessageInfo

func (m *ResourceEventData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ResourceEventData) GetLeader() uint64 {
	if m != nil {
		return m.Leader
	}
	return 0
}

// ContainerEventData container created or updated
type ContainerEventData struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ContainerEventData) Reset()         { *m = ContainerEventData{} }
func (m *ContainerEventData) String() string { return proto.CompactTextString(m) }
func (*ContainerEventData) ProtoMessage()    {}
func (*ContainerEventData) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{25}
}
func (m *ContainerEventData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerEventData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerEventData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerEventData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerEventData.Merge(m, src)
}
func (m *ContainerEventData) XXX_Size() int {
	return m.Size()
}
func (m *ContainerEventData) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerEventData.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerEventData proto.InternalMessageInfo

func (m *ContainerEventData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// ChangePeer change peer
type ChangePeer struct {
	Peer                 metapb.Peer           `protobuf:"bytes,1,opt,name=peer,proto3" json:"peer"`
	ChangeType           metapb.ChangePeerType `protobuf:"varint,2,opt,name=changeType,proto3,enum=metapb.ChangePeerType" json:"changeType,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ChangePeer) Reset()         { *m = ChangePeer{} }
func (m *ChangePeer) String() string { return proto.CompactTextString(m) }
func (*ChangePeer) ProtoMessage()    {}
func (*ChangePeer) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{26}
}
func (m *ChangePeer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangePeer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangePeer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangePeer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangePeer.Merge(m, src)
}
func (m *ChangePeer) XXX_Size() int {
	return m.Size()
}
func (m *ChangePeer) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangePeer.DiscardUnknown(m)
}

var xxx_messageInfo_ChangePeer proto.InternalMessageInfo

func (m *ChangePeer) GetPeer() metapb.Peer {
	if m != nil {
		return m.Peer
	}
	return metapb.Peer{}
}

func (m *ChangePeer) GetChangeType() metapb.ChangePeerType {
	if m != nil {
		return m.ChangeType
	}
	return metapb.ChangePeerType_AddNode
}

// TransferLeader transfer leader
type TransferLeader struct {
	Peer                 metapb.Peer `protobuf:"bytes,1,opt,name=peer,proto3" json:"peer"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *TransferLeader) Reset()         { *m = TransferLeader{} }
func (m *TransferLeader) String() string { return proto.CompactTextString(m) }
func (*TransferLeader) ProtoMessage()    {}
func (*TransferLeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{27}
}
func (m *TransferLeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferLeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferLeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferLeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferLeader.Merge(m, src)
}
func (m *TransferLeader) XXX_Size() int {
	return m.Size()
}
func (m *TransferLeader) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferLeader.DiscardUnknown(m)
}

var xxx_messageInfo_TransferLeader proto.InternalMessageInfo

func (m *TransferLeader) GetPeer() metapb.Peer {
	if m != nil {
		return m.Peer
	}
	return metapb.Peer{}
}

// ChangePeerV2 change peer v2
type ChangePeerV2 struct {
	// If changes is empty, it means that to exit joint state.
	Changes              []ChangePeer `protobuf:"bytes,1,rep,name=changes,proto3" json:"changes"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ChangePeerV2) Reset()         { *m = ChangePeerV2{} }
func (m *ChangePeerV2) String() string { return proto.CompactTextString(m) }
func (*ChangePeerV2) ProtoMessage()    {}
func (*ChangePeerV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{28}
}
func (m *ChangePeerV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangePeerV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangePeerV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangePeerV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangePeerV2.Merge(m, src)
}
func (m *ChangePeerV2) XXX_Size() int {
	return m.Size()
}
func (m *ChangePeerV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangePeerV2.DiscardUnknown(m)
}

var xxx_messageInfo_ChangePeerV2 proto.InternalMessageInfo

func (m *ChangePeerV2) GetChanges() []ChangePeer {
	if m != nil {
		return m.Changes
	}
	return nil
}

// Merge merge
type Merge struct {
	// target resource
	Target               []byte   `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Merge) Reset()         { *m = Merge{} }
func (m *Merge) String() string { return proto.CompactTextString(m) }
func (*Merge) ProtoMessage()    {}
func (*Merge) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{29}
}
func (m *Merge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Merge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Merge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Merge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Merge.Merge(m, src)
}
func (m *Merge) XXX_Size() int {
	return m.Size()
}
func (m *Merge) XXX_DiscardUnknown() {
	xxx_messageInfo_Merge.DiscardUnknown(m)
}

var xxx_messageInfo_Merge proto.InternalMessageInfo

func (m *Merge) GetTarget() []byte {
	if m != nil {
		return m.Target
	}
	return nil
}

// SplitResource split resource
type SplitResource struct {
	Policy               metapb.CheckPolicy `protobuf:"varint,1,opt,name=policy,proto3,enum=metapb.CheckPolicy" json:"policy,omitempty"`
	Keys                 [][]byte           `protobuf:"bytes,2,rep,name=keys,proto3" json:"keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *SplitResource) Reset()         { *m = SplitResource{} }
func (m *SplitResource) String() string { return proto.CompactTextString(m) }
func (*SplitResource) ProtoMessage()    {}
func (*SplitResource) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{30}
}
func (m *SplitResource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitResource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitResource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitResource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitResource.Merge(m, src)
}
func (m *SplitResource) XXX_Size() int {
	return m.Size()
}
func (m *SplitResource) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitResource.DiscardUnknown(m)
}

var xxx_messageInfo_SplitResource proto.InternalMessageInfo

func (m *SplitResource) GetPolicy() metapb.CheckPolicy {
	if m != nil {
		return m.Policy
	}
	return metapb.CheckPolicy_SCAN
}

func (m *SplitResource) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

// TimeInterval time interval
type TimeInterval struct {
	// The unix timestamp in seconds of the start of this period.
	Start uint64 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	// The unix timestamp in seconds of the end of this period.
	End                  uint64   `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TimeInterval) Reset()         { *m = TimeInterval{} }
func (m *TimeInterval) String() string { return proto.CompactTextString(m) }
func (*TimeInterval) ProtoMessage()    {}
func (*TimeInterval) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{31}
}
func (m *TimeInterval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimeInterval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimeInterval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimeInterval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimeInterval.Merge(m, src)
}
func (m *TimeInterval) XXX_Size() int {
	return m.Size()
}
func (m *TimeInterval) XXX_DiscardUnknown() {
	xxx_messageInfo_TimeInterval.DiscardUnknown(m)
}

var xxx_messageInfo_TimeInterval proto.InternalMessageInfo

func (m *TimeInterval) GetStart() uint64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *TimeInterval) GetEnd() uint64 {
	if m != nil {
		return m.End
	}
	return 0
}

// RecordPair record pair
type RecordPair struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                uint64   `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RecordPair) Reset()         { *m = RecordPair{} }
func (m *RecordPair) String() string { return proto.CompactTextString(m) }
func (*RecordPair) ProtoMessage()    {}
func (*RecordPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{32}
}
func (m *RecordPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecordPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordPair.Merge(m, src)
}
func (m *RecordPair) XXX_Size() int {
	return m.Size()
}
func (m *RecordPair) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordPair.DiscardUnknown(m)
}

var xxx_messageInfo_RecordPair proto.InternalMessageInfo

func (m *RecordPair) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *RecordPair) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// ContainerStats container stats
type ContainerStats struct {
	// Container id
	ContainerID uint64 `protobuf:"varint,1,opt,name=containerID,proto3" json:"containerID,omitempty"`
	// When the container is started (unix timestamp in seconds).
	StartTime uint64 `protobuf:"varint,2,opt,name=startTime,proto3" json:"startTime,omitempty"`
	// Actually reported time interval
	Interval *TimeInterval `protobuf:"bytes,3,opt,name=interval,proto3" json:"interval,omitempty"`
	// Capacity for the container.
	Capacity uint64 `protobuf:"varint,4,opt,name=capacity,proto3" json:"capacity,omitempty"`
	// Available size for the container.
	Available uint64 `protobuf:"varint,5,opt,name=available,proto3" json:"available,omitempty"`
	// Actually used space by db
	UsedSize uint64 `protobuf:"varint,6,opt,name=usedSize,proto3" json:"usedSize,omitempty"`
	// If the container is busy
	IsBusy bool `protobuf:"varint,7,opt,name=isBusy,proto3" json:"isBusy,omitempty"`
	// Total resource count in this container.
	ResourceCount uint64 `protobuf:"varint,8,opt,name=resourceCount,proto3" json:"resourceCount,omitempty"`
	// Current sending snapshot count.
	SendingSnapCount uint64 `protobuf:"varint,9,opt,name=sendingSnapCount,proto3" json:"sendingSnapCount,omitempty"`
	// Current receiving snapshot count.
	ReceivingSnapCount uint64 `protobuf:"varint,10,opt,name=receivingSnapCount,proto3" json:"receivingSnapCount,omitempty"`
	// How many resource is applying snapshot.
	ApplyingSnapCount uint64 `protobuf:"varint,11,opt,name=applyingSnapCount,proto3" json:"applyingSnapCount,omitempty"`
	// Bytes written for the container during this period.
	BytesWritten uint64 `protobuf:"varint,12,opt,name=bytesWritten,proto3" json:"bytesWritten,omitempty"`
	// Bytes read for the container during this period.
	BytesRead uint64 `protobuf:"varint,13,opt,name=bytesRead,proto3" json:"bytesRead,omitempty"`
	// Bytes written for the container during this period.
	KeysWritten uint64 `protobuf:"varint,14,opt,name=keysWritten,proto3" json:"keysWritten,omitempty"`
	// Bytes read for the container during this period.
	KeysRead uint64 `protobuf:"varint,15,opt,name=keysRead,proto3" json:"keysRead,omitempty"`
	// Threads' CPU usages in the container
	CpuUsages []RecordPair `protobuf:"bytes,16,rep,name=cpuUsages,proto3" json:"cpuUsages"`
	// Threads' read disk I/O rates in the container
	ReadIORates []RecordPair `protobuf:"bytes,17,rep,name=readIORates,proto3" json:"readIORates"`
	// Threads' write disk I/O rates in the container
	WriteIORates []RecordPair `protobuf:"bytes,18,rep,name=writeIORates,proto3" json:"writeIORates"`
	// Operations' latencies in the container
	OpLatencies          []RecordPair `protobuf:"bytes,19,rep,name=opLatencies,proto3" json:"opLatencies"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ContainerStats) Reset()         { *m = ContainerStats{} }
func (m *ContainerStats) String() string { return proto.CompactTextString(m) }
func (*ContainerStats) ProtoMessage()    {}
func (*ContainerStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{33}
}
func (m *ContainerStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerStats.Merge(m, src)
}
func (m *ContainerStats) XXX_Size() int {
	return m.Size()
}
func (m *ContainerStats) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerStats.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerStats proto.InternalMessageInfo

func (m *ContainerStats) GetContainerID() uint64 {
	if m != nil {
		return m.ContainerID
	}
	return 0
}

func (m *ContainerStats) GetStartTime() uint64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *ContainerStats) GetInterval() *TimeInterval {
	if m != nil {
		return m.Interval
	}
	return nil
}

func (m *ContainerStats) GetCapacity() uint64 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

func (m *ContainerStats) GetAvailable() uint64 {
	if m != nil {
		return m.Available
	}
	return 0
}

func (m *ContainerStats) GetUsedSize() uint64 {
	if m != nil {
		return m.UsedSize
	}
	return 0
}

func (m *ContainerStats) GetIsBusy() bool {
	if m != nil {
		return m.IsBusy
	}
	return false
}

func (m *ContainerStats) GetResourceCount() uint64 {
	if m != nil {
		return m.ResourceCount
	}
	return 0
}

func (m *ContainerStats) GetSendingSnapCount() uint64 {
	if m != nil {
		return m.SendingSnapCount
	}
	return 0
}

func (m *ContainerStats) GetReceivingSnapCount() uint64 {
	if m != nil {
		return m.ReceivingSnapCount
	}
	return 0
}

func (m *ContainerStats) GetApplyingSnapCount() uint64 {
	if m != nil {
		return m.ApplyingSnapCount
	}
	return 0
}

func (m *ContainerStats) GetBytesWritten() uint64 {
	if m != nil {
		return m.BytesWritten
	}
	return 0
}

func (m *ContainerStats) GetBytesRead() uint64 {
	if m != nil {
		return m.BytesRead
	}
	return 0
}

func (m *ContainerStats) GetKeysWritten() uint64 {
	if m != nil {
		return m.KeysWritten
	}
	return 0
}

func (m *ContainerStats) GetKeysRead() uint64 {
	if m != nil {
		return m.KeysRead
	}
	return 0
}

func (m *ContainerStats) GetCpuUsages() []RecordPair {
	if m != nil {
		return m.CpuUsages
	}
	return nil
}

func (m *ContainerStats) GetReadIORates() []RecordPair {
	if m != nil {
		return m.ReadIORates
	}
	return nil
}

func (m *ContainerStats) GetWriteIORates() []RecordPair {
	if m != nil {
		return m.WriteIORates
	}
	return nil
}

func (m *ContainerStats) GetOpLatencies() []RecordPair {
	if m != nil {
		return m.OpLatencies
	}
	return nil
}

func init() {
	proto.RegisterEnum("rpcpb.Type", Type_name, Type_value)
	proto.RegisterType((*Request)(nil), "rpcpb.Request")
	proto.RegisterType((*Response)(nil), "rpcpb.Response")
	proto.RegisterType((*ResourceHeartbeatReq)(nil), "rpcpb.ResourceHeartbeatReq")
	proto.RegisterType((*ResourceHeartbeatRsp)(nil), "rpcpb.ResourceHeartbeatRsp")
	proto.RegisterType((*PutContainerReq)(nil), "rpcpb.PutContainerReq")
	proto.RegisterType((*PutContainerRsp)(nil), "rpcpb.PutContainerRsp")
	proto.RegisterType((*ContainerHeartbeatReq)(nil), "rpcpb.ContainerHeartbeatReq")
	proto.RegisterType((*ContainerHeartbeatRsp)(nil), "rpcpb.ContainerHeartbeatRsp")
	proto.RegisterType((*GetContainerReq)(nil), "rpcpb.GetContainerReq")
	proto.RegisterType((*GetContainerRsp)(nil), "rpcpb.GetContainerRsp")
	proto.RegisterType((*AllocIDReq)(nil), "rpcpb.AllocIDReq")
	proto.RegisterType((*AllocIDRsp)(nil), "rpcpb.AllocIDRsp")
	proto.RegisterType((*AskSplitReq)(nil), "rpcpb.AskSplitReq")
	proto.RegisterType((*AskSplitRsp)(nil), "rpcpb.AskSplitRsp")
	proto.RegisterType((*ReportSplitReq)(nil), "rpcpb.ReportSplitReq")
	proto.RegisterType((*ReportSplitRsp)(nil), "rpcpb.ReportSplitRsp")
	proto.RegisterType((*AskBatchSplitReq)(nil), "rpcpb.AskBatchSplitReq")
	proto.RegisterType((*AskBatchSplitRsp)(nil), "rpcpb.AskBatchSplitRsp")
	proto.RegisterType((*BatchReportSplitReq)(nil), "rpcpb.BatchReportSplitReq")
	proto.RegisterType((*BatchReportSplitRsp)(nil), "rpcpb.BatchReportSplitRsp")
	proto.RegisterType((*SplitID)(nil), "rpcpb.SplitID")
	proto.RegisterType((*CreateWatcherReq)(nil), "rpcpb.CreateWatcherReq")
	proto.RegisterType((*EventNotify)(nil), "rpcpb.EventNotify")
	proto.RegisterType((*InitEventData)(nil), "rpcpb.InitEventData")
	proto.RegisterType((*ResourceEventData)(nil), "rpcpb.ResourceEventData")
	proto.RegisterType((*ContainerEventData)(nil), "rpcpb.ContainerEventData")
	proto.RegisterType((*ChangePeer)(nil), "rpcpb.ChangePeer")
	proto.RegisterType((*TransferLeader)(nil), "rpcpb.TransferLeader")
	proto.RegisterType((*ChangePeerV2)(nil), "rpcpb.ChangePeerV2")
	proto.RegisterType((*Merge)(nil), "rpcpb.Merge")
	proto.RegisterType((*SplitResource)(nil), "rpcpb.SplitResource")
	proto.RegisterType((*TimeInterval)(nil), "rpcpb.TimeInterval")
	proto.RegisterType((*RecordPair)(nil), "rpcpb.RecordPair")
	proto.RegisterType((*ContainerStats)(nil), "rpcpb.ContainerStats")
}

func init() { proto.RegisterFile("rpcpb.proto", fileDescriptor_25e491924c678914) }

var fileDescriptor_25e491924c678914 = []byte{
	// 1860 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x58, 0xdb, 0x72, 0xdb, 0xc6,
	0x19, 0x36, 0xc5, 0x83, 0xc4, 0x9f, 0x20, 0x05, 0xad, 0x64, 0x19, 0x76, 0x5c, 0x59, 0xdd, 0xf1,
	0x64, 0xd4, 0x24, 0x95, 0x6a, 0x25, 0x71, 0xdb, 0xb4, 0x6e, 0xaa, 0x43, 0xa6, 0x55, 0xeb, 0x36,
	0x9a, 0x95, 0x9b, 0x5c, 0x2f, 0xc1, 0x15, 0x85, 0x11, 0x05, 0xac, 0xb1, 0x4b, 0x39, 0xec, 0x65,
	0x67, 0x7a, 0xd1, 0x8b, 0xbe, 0x42, 0x1f, 0xa2, 0x4f, 0x91, 0xcb, 0x3c, 0x41, 0xa6, 0xf5, 0x65,
	0x9f, 0xa2, 0xb3, 0x07, 0x60, 0x01, 0x10, 0xa4, 0x9c, 0x2b, 0xe1, 0x3f, 0x7d, 0x58, 0xec, 0xfe,
	0xdf, 0xbf, 0x1f, 0x05, 0xbd, 0x94, 0x87, 0x7c, 0xb8, 0xcf, 0xd3, 0x44, 0x26, 0xa8, 0xad, 0x8d,
	0x47, 0x2f, 0xc7, 0x91, 0xbc, 0x9a, 0x0e, 0xf7, 0xc3, 0xe4, 0xe6, 0xe0, 0x86, 0xca, 0x34, 0xfa,
	0x26, 0x49, 0xa3, 0x71, 0x14, 0x5b, 0x23, 0x9c, 0x0e, 0xd9, 0x41, 0x98, 0xdc, 0xf0, 0x24, 0x66,
	0xb1, 0x14, 0x07, 0x3c, 0x4d, 0xf8, 0x15, 0x93, 0x07, 0x7c, 0x78, 0x70, 0xc3, 0x24, 0xcd, 0xff,
	0x18, 0xd0, 0x47, 0x3f, 0x2d, 0xa0, 0x8d, 0x93, 0x71, 0x72, 0xa0, 0xdd, 0xc3, 0xe9, 0xa5, 0xb6,
	0xb4, 0xa1, 0x9f, 0x4c, 0x3a, 0xfe, 0x67, 0x07, 0x56, 0x09, 0x7b, 0x3d, 0x65, 0x42, 0xa2, 0x6d,
	0x58, 0x89, 0x46, 0x41, 0x63, 0xb7, 0xb1, 0xd7, 0x3a, 0xee, 0xbc, 0xfd, 0xfe, 0xc9, 0xca, 0xd9,
	0x29, 0x59, 0x89, 0x46, 0x68, 0x17, 0x7a, 0x61, 0x12, 0x4b, 0x1a, 0xc5, 0x2c, 0x3d, 0x3b, 0x0d,
	0x56, 0x54, 0x02, 0x29, 0xba, 0xd0, 0x13, 0x68, 0xc9, 0x19, 0x67, 0x41, 0x73, 0xb7, 0xb1, 0x37,
	0x38, 0xec, 0xed, 0x9b, 0xaf, 0x7c, 0x35, 0xe3, 0x8c, 0xe8, 0x00, 0xfa, 0x12, 0x36, 0x08, 0x13,
	0xc9, 0x34, 0x0d, 0xd9, 0xef, 0x19, 0x4d, 0xe5, 0x90, 0x51, 0x19, 0xb4, 0x76, 0x1b, 0x7b, 0xbd,
	0xc3, 0xf7, 0x6c, 0xf6, 0x5c, 0x9c, 0xb0, 0xd7, 0xc7, 0xad, 0x6f, 0xbf, 0x7f, 0x72, 0x8f, 0xcc,
	0xd7, 0x22, 0x02, 0xe8, 0x24, 0x5b, 0x80, 0x43, 0x6c, 0x6b, 0xc4, 0xc7, 0x16, 0x71, 0x3e, 0xc1,
	0x41, 0xd6, 0x54, 0xa3, 0xdf, 0x82, 0x77, 0x3e, 0x95, 0x79, 0x20, 0xe8, 0x68, 0xb4, 0x6d, 0x8b,
	0x56, 0x0c, 0x39, 0x9c, 0x52, 0x85, 0x42, 0xf8, 0x1d, 0x2b, 0x20, 0xac, 0x96, 0x10, 0x8a, 0xa1,
	0x02, 0x42, 0xd1, 0x8d, 0x9e, 0xc1, 0xea, 0xd1, 0x64, 0x92, 0x84, 0x67, 0xa7, 0xc1, 0x9a, 0x2e,
	0xde, 0xb0, 0xc5, 0xd6, 0xeb, 0xea, 0xb2, 0x3c, 0xf4, 0x09, 0xac, 0x1d, 0x89, 0xeb, 0x0b, 0x3e,
	0x89, 0x64, 0xd0, 0xd5, 0x35, 0x28, 0xab, 0xb1, 0x6e, 0x57, 0x94, 0x67, 0xa2, 0x13, 0xe8, 0x1f,
	0x89, 0xeb, 0x63, 0x2a, 0xc3, 0x2b, 0x53, 0x0a, 0xba, 0xf4, 0x81, 0x2b, 0x75, 0x31, 0x57, 0x5f,
	0xae, 0x41, 0x2f, 0xa0, 0x47, 0x18, 0x4f, 0x52, 0x69, 0x20, 0x7a, 0x1a, 0xe2, 0x7e, 0x7e, 0xa0,
	0x79, 0xc4, 0x01, 0x14, 0xf3, 0xd1, 0x4b, 0xf0, 0x35, 0x58, 0x11, 0xc3, 0xd3, 0x18, 0x8f, 0x2c,
	0x46, 0x35, 0xec, 0x80, 0xe6, 0x2a, 0xd5, 0x17, 0x9d, 0xa4, 0x8c, 0x4a, 0xf6, 0xb5, 0x8a, 0xb0,
	0x34, 0xe8, 0x97, 0xbe, 0xa8, 0x14, 0x2b, 0x7c, 0x51, 0xc9, 0x8f, 0xff, 0xde, 0x81, 0x35, 0xc2,
	0x04, 0x4f, 0x62, 0xc1, 0x16, 0x12, 0x22, 0x6b, 0xf7, 0x95, 0x45, 0xed, 0xbe, 0x05, 0x6d, 0x96,
	0xa6, 0x49, 0xaa, 0x09, 0xd1, 0x25, 0xc6, 0x40, 0xdb, 0xd0, 0x99, 0x30, 0x3a, 0x62, 0xa9, 0xee,
	0xfc, 0x2e, 0xb1, 0x56, 0x3d, 0x39, 0xda, 0x77, 0x90, 0x43, 0xf0, 0x1f, 0x4a, 0x8e, 0xce, 0x5d,
	0xe4, 0xc8, 0x21, 0xdf, 0x85, 0x1c, 0xab, 0x8b, 0xc9, 0x91, 0xe3, 0x2c, 0x27, 0xc7, 0xda, 0x62,
	0x72, 0x38, 0x84, 0x45, 0xe4, 0xe8, 0xd6, 0x92, 0x23, 0xaf, 0xab, 0x25, 0x07, 0xd4, 0x93, 0x23,
	0x2f, 0x5a, 0x42, 0x8e, 0xde, 0x12, 0x72, 0xe4, 0xf5, 0xcb, 0xc9, 0xe1, 0x2d, 0x24, 0x47, 0x0e,
	0x70, 0x27, 0x39, 0xfa, 0xcb, 0xc9, 0x91, 0x03, 0xcd, 0x93, 0x63, 0x1f, 0xda, 0x5f, 0xdc, 0xb2,
	0x58, 0x06, 0x83, 0xd2, 0x26, 0x68, 0xdf, 0x9f, 0x13, 0x19, 0x5d, 0xce, 0x6c, 0xa9, 0x49, 0xc3,
	0x7f, 0x6b, 0xc1, 0x56, 0xdd, 0x44, 0xae, 0x5e, 0x06, 0x8d, 0xf9, 0xcb, 0xe0, 0x11, 0xac, 0xa5,
	0xb6, 0x52, 0x33, 0xc4, 0x23, 0xb9, 0x8d, 0x10, 0xb4, 0x24, 0x4b, 0x6f, 0x34, 0x2f, 0x5a, 0x44,
	0x3f, 0xa3, 0xa7, 0x25, 0x5a, 0xf4, 0x0e, 0xbd, 0x7d, 0x7b, 0xa1, 0x9d, 0x33, 0x96, 0xe6, 0x24,
	0xf9, 0x14, 0xba, 0xa3, 0xe4, 0x4d, 0xac, 0x7c, 0x22, 0x68, 0xef, 0x36, 0xf5, 0xe9, 0x17, 0x12,
	0x2f, 0x24, 0x95, 0xc2, 0x7e, 0x83, 0xcb, 0x44, 0xcf, 0xc1, 0xe3, 0x2c, 0x1e, 0x45, 0xf1, 0xd8,
	0x54, 0x76, 0x74, 0x65, 0xe9, 0x15, 0x59, 0xab, 0x15, 0xf3, 0x10, 0x06, 0x6f, 0x38, 0x93, 0x4c,
	0x7c, 0x9d, 0x46, 0x52, 0xb2, 0x58, 0xb7, 0x7b, 0x8b, 0x94, 0x7c, 0xe8, 0x31, 0x74, 0xb5, 0x4d,
	0x18, 0x1d, 0xe9, 0x6e, 0x6e, 0x11, 0xe7, 0x50, 0x1b, 0x75, 0xcd, 0x66, 0x39, 0x40, 0xd7, 0x6c,
	0x54, 0xc1, 0xa5, 0x36, 0x4a, 0x99, 0xba, 0x1c, 0x74, 0x38, 0xb7, 0xd1, 0x1e, 0xac, 0x53, 0xce,
	0xd3, 0xe4, 0x9b, 0xe8, 0x86, 0x4a, 0x76, 0x11, 0xfd, 0x95, 0xe9, 0x1e, 0x6c, 0x91, 0xaa, 0xbb,
	0x92, 0xf9, 0x47, 0x36, 0x13, 0xba, 0xd5, 0xca, 0x99, 0xca, 0x8d, 0x0e, 0x60, 0x2d, 0x8a, 0x25,
	0x4b, 0x6f, 0xe9, 0xc4, 0x76, 0xd2, 0x66, 0x36, 0xba, 0xa2, 0x1b, 0x76, 0x66, 0x43, 0x24, 0x4f,
	0xc2, 0xff, 0x6e, 0xd6, 0x35, 0x81, 0xe0, 0x68, 0x07, 0x20, 0x3b, 0xd2, 0xbc, 0x07, 0x0a, 0x1e,
	0x74, 0x04, 0xfd, 0xcc, 0xfa, 0x82, 0x27, 0xe1, 0x95, 0xee, 0x03, 0xd5, 0xfc, 0x76, 0xdb, 0x49,
	0x31, 0x98, 0xb1, 0xa7, 0x54, 0x81, 0x3e, 0x02, 0x90, 0x34, 0x1d, 0x33, 0xa9, 0xce, 0x43, 0xf7,
	0x4b, 0xb5, 0x33, 0x0a, 0x71, 0xf4, 0x0c, 0x20, 0xbc, 0xa2, 0xf1, 0x98, 0xe9, 0xec, 0x56, 0x69,
	0x38, 0x9c, 0xe4, 0x01, 0x52, 0x48, 0x42, 0x2f, 0x60, 0x20, 0x53, 0x1a, 0x8b, 0x4b, 0x96, 0xbe,
	0x34, 0xed, 0xd7, 0x2e, 0x31, 0xf4, 0x55, 0x29, 0x48, 0x2a, 0xc9, 0x08, 0x43, 0xfb, 0x86, 0xa5,
	0x63, 0x66, 0xc7, 0xaa, 0x67, 0xab, 0xfe, 0xa4, 0x7c, 0xc4, 0x84, 0xd0, 0x67, 0xd0, 0x17, 0xe6,
	0xd6, 0xb2, 0x74, 0x30, 0x43, 0x73, 0xcb, 0xe6, 0x5e, 0x14, 0x63, 0xa4, 0x9c, 0x8a, 0x7e, 0x0e,
	0x9e, 0x5b, 0xec, 0x57, 0x87, 0x76, 0x5a, 0x6e, 0xce, 0x7d, 0xd3, 0x57, 0x87, 0xa4, 0x94, 0x88,
	0x0f, 0x60, 0xbd, 0x22, 0x55, 0x54, 0xa3, 0xe6, 0x04, 0xd5, 0xa7, 0xe5, 0x11, 0xe7, 0xc0, 0x1b,
	0x95, 0x02, 0xc1, 0xf1, 0x1f, 0xe0, 0x7e, 0xad, 0x78, 0x42, 0xcf, 0xa0, 0x2d, 0x14, 0xd1, 0x34,
	0x8a, 0xdb, 0xab, 0x3c, 0xb9, 0xc8, 0x42, 0x93, 0x89, 0x1f, 0xd4, 0x62, 0x09, 0x8e, 0x7f, 0x02,
	0xeb, 0x15, 0x45, 0xb4, 0xe8, 0xc2, 0xc5, 0xa4, 0x92, 0x2a, 0xb8, 0x9a, 0x24, 0x23, 0x2a, 0xa9,
	0xfd, 0x1c, 0xfd, 0x8c, 0x3e, 0xcc, 0x56, 0xb7, 0xb2, 0x64, 0x75, 0xd9, 0xba, 0x3c, 0x00, 0xa7,
	0xa9, 0xf0, 0x53, 0x67, 0x09, 0xbe, 0x70, 0x1d, 0x3f, 0x86, 0x5e, 0x41, 0x53, 0xd5, 0xad, 0x01,
	0xbf, 0x28, 0xa4, 0x08, 0x8e, 0xf6, 0x61, 0x55, 0x9f, 0xab, 0xa5, 0x49, 0xef, 0x70, 0x50, 0x3c,
	0xfc, 0xb3, 0xd3, 0xec, 0xbe, 0xb2, 0x49, 0xf8, 0x33, 0x18, 0x94, 0xe5, 0x8e, 0x7a, 0xc9, 0x84,
	0x5d, 0xca, 0xec, 0x25, 0xea, 0x59, 0xe9, 0x8b, 0x34, 0x1a, 0x5f, 0x49, 0x3b, 0x5f, 0x8d, 0x81,
	0xfd, 0x72, 0xad, 0xe0, 0xf8, 0xd7, 0xe0, 0x57, 0x85, 0x5c, 0xed, 0xc6, 0x6d, 0x41, 0x3b, 0x4c,
	0xa6, 0xb1, 0xc1, 0xeb, 0x13, 0x63, 0xe0, 0xd3, 0x6a, 0xb5, 0xe0, 0xe8, 0x67, 0xb0, 0x66, 0x97,
	0xaa, 0x7a, 0xa0, 0xb9, 0xf0, 0x83, 0xf2, 0x2c, 0xfc, 0x31, 0x6c, 0xd6, 0xa8, 0x38, 0xd5, 0x93,
	0x19, 0xe1, 0x0d, 0x92, 0x47, 0x9c, 0x03, 0xdf, 0xaf, 0x29, 0x12, 0x1c, 0x7f, 0x0e, 0xab, 0xf6,
	0x35, 0x6a, 0xc9, 0x31, 0x7b, 0x93, 0x4f, 0x1f, 0x63, 0xa8, 0xc1, 0x14, 0xb3, 0x37, 0x8a, 0x09,
	0x6a, 0x81, 0x2b, 0xbb, 0x4d, 0x35, 0x98, 0x9c, 0x07, 0xbf, 0x0f, 0x7e, 0x55, 0x07, 0xaa, 0x0d,
	0xb9, 0x9c, 0xd0, 0xb1, 0x06, 0xea, 0x13, 0xfd, 0x8c, 0xff, 0xd7, 0x80, 0x5e, 0xe1, 0x6e, 0x44,
	0x3e, 0x34, 0x05, 0x7b, 0x6d, 0xdf, 0xa5, 0x1e, 0xf5, 0x4d, 0x96, 0x69, 0xc0, 0xbe, 0x95, 0x7d,
	0x87, 0xd0, 0x8d, 0xe2, 0x48, 0x9a, 0x8b, 0xb6, 0x59, 0xe2, 0xfa, 0x59, 0xe6, 0x3f, 0xa5, 0x92,
	0x12, 0x97, 0x86, 0x7e, 0x53, 0x18, 0x95, 0xba, 0xce, 0x0c, 0xaf, 0xa0, 0x22, 0xfc, 0x5c, 0x6d,
	0x39, 0x1d, 0x1d, 0xc1, 0x20, 0xa7, 0xb2, 0x01, 0x30, 0x63, 0xec, 0x61, 0xb5, 0xf9, 0x1d, 0x42,
	0xa5, 0x00, 0x8f, 0xa1, 0x5f, 0x5a, 0xde, 0xf2, 0xb3, 0x41, 0x01, 0xac, 0x9a, 0x3b, 0x39, 0xdb,
	0xe0, 0xcc, 0x54, 0xbb, 0x9f, 0x43, 0x8b, 0xa0, 0xa9, 0x0b, 0x0b, 0x1e, 0xfc, 0xb9, 0x13, 0xba,
	0xee, 0x65, 0x75, 0xfd, 0xe8, 0x94, 0xb2, 0xf9, 0xb1, 0x69, 0x2d, 0xbc, 0x57, 0x10, 0xb6, 0x4b,
	0x11, 0xf0, 0x04, 0xc0, 0xcd, 0x48, 0xf4, 0x3e, 0xb4, 0x38, 0xb3, 0xb3, 0xaf, 0xfe, 0xf6, 0xd7,
	0x71, 0xf4, 0x3c, 0xbb, 0x46, 0x5e, 0x39, 0x79, 0xbf, 0x9d, 0x65, 0x3b, 0x3c, 0xad, 0xf4, 0x0b,
	0x99, 0xf8, 0x17, 0x30, 0x28, 0x5f, 0x17, 0xef, 0xfa, 0x46, 0x7c, 0x04, 0x5e, 0x71, 0x96, 0x2b,
	0x89, 0x6b, 0x70, 0x33, 0x7a, 0xcd, 0xdf, 0x62, 0xd9, 0xc8, 0xb0, 0x79, 0xf8, 0x09, 0xb4, 0xf5,
	0xad, 0xa3, 0x76, 0xcd, 0x5c, 0x89, 0x76, 0x27, 0xac, 0x85, 0xcf, 0xa1, 0x5f, 0xba, 0x6a, 0xd0,
	0x87, 0xd0, 0xe1, 0xc9, 0x24, 0x0a, 0x67, 0x3a, 0x71, 0x70, 0xb8, 0xe9, 0x3e, 0x91, 0x85, 0xd7,
	0xe7, 0x3a, 0x44, 0x6c, 0x8a, 0xda, 0x5d, 0xa5, 0x4a, 0xf4, 0x59, 0x7b, 0x44, 0x3f, 0xe3, 0xe7,
	0xe0, 0x15, 0x25, 0x83, 0x22, 0xa3, 0x90, 0x34, 0x95, 0x19, 0x19, 0xb5, 0xa1, 0x48, 0xc3, 0xe2,
	0x91, 0x3d, 0x42, 0xf5, 0x88, 0x3f, 0x01, 0x20, 0x2c, 0x4c, 0xd2, 0xd1, 0x39, 0x8d, 0x52, 0x15,
	0xbf, 0x66, 0x66, 0x0d, 0x5d, 0xa2, 0x1e, 0x15, 0xce, 0x2d, 0x9d, 0x4c, 0x99, 0xad, 0x31, 0x06,
	0xfe, 0x47, 0x07, 0x06, 0xe5, 0x19, 0xfe, 0x0e, 0x2a, 0xf4, 0x31, 0x74, 0xf5, 0x2a, 0xd4, 0x3a,
	0x2d, 0x9c, 0x73, 0x94, 0xa4, 0x50, 0xf3, 0x1d, 0xa4, 0x90, 0xd2, 0x6a, 0x21, 0xe5, 0x34, 0x8c,
	0xe4, 0x4c, 0x33, 0xb4, 0x45, 0x72, 0x5b, 0xbd, 0x8a, 0xde, 0xd2, 0x68, 0x42, 0x87, 0x13, 0xa6,
	0xd9, 0xd7, 0x22, 0xce, 0xa1, 0x2a, 0xa7, 0x82, 0x8d, 0xb4, 0x84, 0xeb, 0x98, 0xca, 0xcc, 0x56,
	0x27, 0x16, 0x89, 0xe3, 0xa9, 0x98, 0x69, 0x65, 0xb0, 0x46, 0xac, 0x85, 0x9e, 0xba, 0xa1, 0x70,
	0xa2, 0xe7, 0xb2, 0x51, 0x97, 0x65, 0x27, 0xfa, 0x00, 0x7c, 0x61, 0x34, 0xeb, 0x45, 0x4c, 0xb9,
	0x49, 0x34, 0x32, 0x73, 0xce, 0x8f, 0xf6, 0x01, 0xa5, 0x2c, 0x64, 0xd1, 0x6d, 0x29, 0xdb, 0xa8,
	0xce, 0x9a, 0x08, 0xfa, 0x08, 0x36, 0x28, 0xe7, 0x93, 0x59, 0x29, 0xdd, 0x28, 0xd0, 0xf9, 0xc0,
	0x9c, 0x5a, 0xf6, 0xee, 0x52, 0xcb, 0xfd, 0x3b, 0xd4, 0xf2, 0x60, 0xb9, 0x5a, 0x5e, 0xaf, 0xa8,
	0xe5, 0x4f, 0xa1, 0x1b, 0xf2, 0xe9, 0x5f, 0x04, 0x55, 0xbc, 0xf1, 0x4b, 0xbc, 0x71, 0xfd, 0x96,
	0xfd, 0x38, 0xc8, 0x33, 0xd1, 0x2f, 0xa1, 0x97, 0x32, 0x3a, 0x3a, 0xfb, 0x92, 0x50, 0xc9, 0x44,
	0xb0, 0xb1, 0xbc, 0xb0, 0x98, 0x8b, 0x7e, 0x05, 0xde, 0x9b, 0x34, 0x92, 0x2c, 0xab, 0x45, 0xcb,
	0x6b, 0x4b, 0xc9, 0xea, 0xbd, 0x09, 0x7f, 0x49, 0x25, 0x8b, 0xc3, 0x88, 0x89, 0x60, 0xf3, 0x8e,
	0xf7, 0x16, 0x72, 0x3f, 0xf8, 0x57, 0x0b, 0x5a, 0x6a, 0xe4, 0xa0, 0x87, 0x70, 0x5f, 0x8f, 0x21,
	0x36, 0x8e, 0x84, 0x64, 0x69, 0xce, 0x0f, 0xff, 0x1e, 0x7a, 0x0c, 0x81, 0x09, 0xcd, 0xff, 0x7c,
	0xf3, 0x1b, 0x8b, 0xa3, 0x82, 0xfb, 0x2b, 0xe8, 0x47, 0xf0, 0x50, 0x45, 0x6b, 0xd5, 0x9f, 0xdf,
	0x5c, 0x12, 0x16, 0xdc, 0x6f, 0xa1, 0x07, 0xb0, 0xa9, 0xc2, 0x15, 0xfd, 0xe9, 0xb7, 0x6b, 0x03,
	0x82, 0xfb, 0x9d, 0x2c, 0x50, 0x11, 0x82, 0xfe, 0x6a, 0x6d, 0x40, 0x70, 0x7f, 0x0d, 0x21, 0x18,
	0xa8, 0x80, 0xd3, 0x6e, 0x7e, 0xb7, 0xea, 0x13, 0xdc, 0x07, 0xb4, 0x09, 0xeb, 0xda, 0xe7, 0xf4,
	0x9a, 0xdf, 0x9b, 0x73, 0x0a, 0xee, 0x7b, 0x28, 0x80, 0x2d, 0xeb, 0x2c, 0x29, 0x25, 0xbf, 0x5f,
	0x1f, 0x11, 0xdc, 0x1f, 0xa0, 0x6d, 0x40, 0x66, 0x17, 0x8b, 0xa2, 0xc6, 0x5f, 0xaf, 0xf3, 0x0b,
	0xee, 0xfb, 0xe8, 0x3d, 0x78, 0xa0, 0xfc, 0x35, 0x4a, 0xc8, 0xdf, 0x58, 0x18, 0x14, 0xdc, 0x47,
	0xd9, 0x1a, 0xaa, 0xb2, 0xc5, 0xdf, 0xcc, 0x3e, 0xa6, 0xa0, 0x53, 0xfc, 0xad, 0x63, 0xff, 0xbb,
	0xff, 0xee, 0xdc, 0xfb, 0xf6, 0xed, 0x4e, 0xe3, 0xbb, 0xb7, 0x3b, 0x8d, 0xff, 0xbc, 0xdd, 0x69,
	0x0c, 0x3b, 0xfa, 0x3f, 0xbd, 0x1f, 0xff, 0x3f, 0x00, 0x00, 0xff, 0xff, 0x5e, 0x00, 0x73, 0x80,
	0x7c, 0x16, 0x00, 0x00,
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ID))
	}
	if m.ContainerID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ContainerID))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Type))
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.ResourceHeartbeat.Size()))
	n1, err := m.ResourceHeartbeat.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x2a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.ContainerHeartbeat.Size()))
	n2, err := m.ContainerHeartbeat.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x32
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.PutContainer.Size()))
	n3, err := m.PutContainer.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x3a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.GetContainer.Size()))
	n4, err := m.GetContainer.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	dAtA[i] = 0x42
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.AllocID.Size()))
	n5, err := m.AllocID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x4a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.AskSplit.Size()))
	n6, err := m.AskSplit.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x52
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.AskBatchSplit.Size()))
	n7, err := m.AskBatchSplit.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x5a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.ReportSplit.Size()))
	n8, err := m.ReportSplit.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	dAtA[i] = 0x62
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.BatchReportSplit.Size()))
	n9, err := m.BatchReportSplit.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	dAtA[i] = 0x6a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.CreateWatcher.Size()))
	n10, err := m.CreateWatcher.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ID))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Type))
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if len(m.Leader) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Leader)))
		i += copy(dAtA[i:], m.Leader)
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.ResourceHeartbeat.Size()))
	n11, err := m.ResourceHeartbeat.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	dAtA[i] = 0x32
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.ContainerHeartbeat.Size()))
	n12, err := m.ContainerHeartbeat.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	dAtA[i] = 0x3a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.PutContainer.Size()))
	n13, err := m.PutContainer.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	dAtA[i] = 0x42
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.GetContainer.Size()))
	n14, err := m.GetContainer.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	dAtA[i] = 0x4a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.AllocID.Size()))
	n15, err := m.AllocID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	dAtA[i] = 0x52
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.AskSplit.Size()))
	n16, err := m.AskSplit.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	dAtA[i] = 0x5a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.AskBatchSplit.Size()))
	n17, err := m.AskBatchSplit.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	dAtA[i] = 0x62
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.ReportSplit.Size()))
	n18, err := m.ReportSplit.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	dAtA[i] = 0x6a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.BatchReportSplit.Size()))
	n19, err := m.BatchReportSplit.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	dAtA[i] = 0x72
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Event.Size()))
	n20, err := m.Event.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResourceHeartbeatReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceHeartbeatReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ContainerID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ContainerID))
	}
	if len(m.Resource) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Resource)))
		i += copy(dAtA[i:], m.Resource)
	}
	if m.Term != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Term))
	}
	if m.Leader != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Leader.Size()))
		n21, err := m.Leader.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if len(m.DownPeers) > 0 {
		for _, msg := range m.DownPeers {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PendingPeers) > 0 {
		for _, msg := range m.PendingPeers {
			dAtA[i] = 0x32
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.BytesWritten != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.BytesWritten))
	}
	if m.BytesRead != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.BytesRead))
	}
	if m.KeysWritten != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.KeysWritten))
	}
	if m.KeysRead != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.KeysRead))
	}
	if m.ApproximateSize != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ApproximateSize))
	}
	if m.ApproximateKeys != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ApproximateKeys))
	}
	if m.Interval != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Interval.Size()))
		n22, err := m.Interval.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResourceHeartbeatRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceHeartbeatRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ResourceID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ResourceID))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.ResourceEpoch.Size()))
	n23, err := m.ResourceEpoch.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n23
	if m.TargetPeer != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.TargetPeer.Size()))
		n24, err := m.TargetPeer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.ChangePeer != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ChangePeer.Size()))
		n25, err := m.ChangePeer.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.TransferLeader != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.TransferLeader.Size()))
		n26, err := m.TransferLeader.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.Merge != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Merge.Size()))
		n27, err := m.Merge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.SplitResource != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.SplitResource.Size()))
		n28, err := m.SplitResource.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	if m.ChangePeerV2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ChangePeerV2.Size()))
		n29, err := m.ChangePeerV2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PutContainerReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutContainerReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Container) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Container)))
		i += copy(dAtA[i:], m.Container)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PutContainerRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutContainerRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ContainerHeartbeatReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerHeartbeatReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Stats.Size()))
	n30, err := m.Stats.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n30
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ContainerHeartbeatRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerHeartbeatRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetContainerReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetContainerReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetContainerRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetContainerRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Stats != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Stats.Size()))
		n31, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AllocIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocIDReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AllocIDRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocIDRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AskSplitReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AskSplitReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AskSplitRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AskSplitRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.SplitID.Size()))
	n32, err := m.SplitID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n32
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ReportSplitReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportSplitReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Left) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Left)))
		i += copy(dAtA[i:], m.Left)
	}
	if len(m.Right) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Right)))
		i += copy(dAtA[i:], m.Right)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ReportSplitRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportSplitRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AskBatchSplitReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AskBatchSplitReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AskBatchSplitRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AskBatchSplitRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SplitIDs) > 0 {
		for _, msg := range m.SplitIDs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BatchReportSplitReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchReportSplitReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for _, b := range m.Resources {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BatchReportSplitRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchReportSplitRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SplitID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NewID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.NewID))
	}
	if len(m.NewPeerIDs) > 0 {
		dAtA34 := make([]byte, len(m.NewPeerIDs)*10)
		var j33 int
		for _, num := range m.NewPeerIDs {
			for num >= 1<<7 {
				dAtA34[j33] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j33++
			}
			dAtA34[j33] = uint8(num)
			j33++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(j33))
		i += copy(dAtA[i:], dAtA34[:j33])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateWatcherReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateWatcherReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flag != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Flag))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EventNotify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventNotify) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seq != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Seq))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Type))
	}
	if m.InitEvent != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.InitEvent.Size()))
		n35, err := m.InitEvent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n35
	}
	if m.ResourceEvent != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ResourceEvent.Size()))
		n36, err := m.ResourceEvent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.ContainerEvent != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ContainerEvent.Size()))
		n37, err := m.ContainerEvent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InitEventData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitEventData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for _, b := range m.Resources {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Leaders) > 0 {
		dAtA39 := make([]byte, len(m.Leaders)*10)
		var j38 int
		for _, num := range m.Leaders {
			for num >= 1<<7 {
				dAtA39[j38] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j38++
			}
			dAtA39[j38] = uint8(num)
			j38++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(j38))
		i += copy(dAtA[i:], dAtA39[:j38])
	}
	if len(m.Containers) > 0 {
		for _, b := range m.Containers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResourceEventData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceEventData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Leader != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Leader))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ContainerEventData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerEventData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChangePeer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangePeer) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Peer.Size()))
	n40, err := m.Peer.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n40
	if m.ChangeType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ChangeType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TransferLeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferLeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Peer.Size()))
	n41, err := m.Peer.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n41
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ChangePeerV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangePeerV2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for _, msg := range m.Changes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Merge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Merge) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Target) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Target)))
		i += copy(dAtA[i:], m.Target)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SplitResource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitResource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Policy != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Policy))
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			dAtA[i] = 0x12
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TimeInterval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeInterval) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Start != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.End))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RecordPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordPair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Value != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ContainerStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ContainerID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ContainerID))
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.StartTime))
	}
	if m.Interval != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Interval.Size()))
		n42, err := m.Interval.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n42
	}
	if m.Capacity != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Capacity))
	}
	if m.Available != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Available))
	}
	if m.UsedSize != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.UsedSize))
	}
	if m.IsBusy {
		dAtA[i] = 0x38
		i++
		if m.IsBusy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ResourceCount != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ResourceCount))
	}
	if m.SendingSnapCount != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.SendingSnapCount))
	}
	if m.ReceivingSnapCount != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ReceivingSnapCount))
	}
	if m.ApplyingSnapCount != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ApplyingSnapCount))
	}
	if m.BytesWritten != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.BytesWritten))
	}
	if m.BytesRead != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.BytesRead))
	}
	if m.KeysWritten != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.KeysWritten))
	}
	if m.KeysRead != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.KeysRead))
	}
	if len(m.CpuUsages) > 0 {
		for _, msg := range m.CpuUsages {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ReadIORates) > 0 {
		for _, msg := range m.ReadIORates {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.WriteIORates) > 0 {
		for _, msg := range m.WriteIORates {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OpLatencies) > 0 {
		for _, msg := range m.OpLatencies {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintRpcpb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRpcpb(uint64(m.ID))
	}
	if m.ContainerID != 0 {
		n += 1 + sovRpcpb(uint64(m.ContainerID))
	}
	if m.Type != 0 {
		n += 1 + sovRpcpb(uint64(m.Type))
	}
	l = m.ResourceHeartbeat.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.ContainerHeartbeat.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.PutContainer.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.GetContainer.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.AllocID.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.AskSplit.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.AskBatchSplit.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.ReportSplit.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.BatchReportSplit.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.CreateWatcher.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRpcpb(uint64(m.ID))
	}
	if m.Type != 0 {
		n += 1 + sovRpcpb(uint64(m.Type))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = m.ResourceHeartbeat.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.ContainerHeartbeat.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.PutContainer.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.GetContainer.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.AllocID.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.AskSplit.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.AskBatchSplit.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.ReportSplit.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.BatchReportSplit.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.Event.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourceHeartbeatReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContainerID != 0 {
		n += 1 + sovRpcpb(uint64(m.ContainerID))
	}
	l = len(m.Resource)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Term != 0 {
		n += 1 + sovRpcpb(uint64(m.Term))
	}
	if m.Leader != nil {
		l = m.Leader.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if len(m.DownPeers) > 0 {
		for _, e := range m.DownPeers {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if len(m.PendingPeers) > 0 {
		for _, e := range m.PendingPeers {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.BytesWritten != 0 {
		n += 1 + sovRpcpb(uint64(m.BytesWritten))
	}
	if m.BytesRead != 0 {
		n += 1 + sovRpcpb(uint64(m.BytesRead))
	}
	if m.KeysWritten != 0 {
		n += 1 + sovRpcpb(uint64(m.KeysWritten))
	}
	if m.KeysRead != 0 {
		n += 1 + sovRpcpb(uint64(m.KeysRead))
	}
	if m.ApproximateSize != 0 {
		n += 1 + sovRpcpb(uint64(m.ApproximateSize))
	}
	if m.ApproximateKeys != 0 {
		n += 1 + sovRpcpb(uint64(m.ApproximateKeys))
	}
	if m.Interval != nil {
		l = m.Interval.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourceHeartbeatRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResourceID != 0 {
		n += 1 + sovRpcpb(uint64(m.ResourceID))
	}
	l = m.ResourceEpoch.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.TargetPeer != nil {
		l = m.TargetPeer.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.ChangePeer != nil {
		l = m.ChangePeer.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.TransferLeader != nil {
		l = m.TransferLeader.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Merge != nil {
		l = m.Merge.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.SplitResource != nil {
		l = m.SplitResource.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.ChangePeerV2 != nil {
		l = m.ChangePeerV2.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutContainerReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Container)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutContainerRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContainerHeartbeatReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Stats.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContainerHeartbeatRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetContainerReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRpcpb(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetContainerRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllocIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllocIDRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRpcpb(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AskSplitReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AskSplitRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SplitID.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportSplitReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Left)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = len(m.Right)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportSplitRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AskBatchSplitReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovRpcpb(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AskBatchSplitRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SplitIDs) > 0 {
		for _, e := range m.SplitIDs {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BatchReportSplitReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for _, b := range m.Resources {
			l = len(b)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BatchReportSplitRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SplitID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewID != 0 {
		n += 1 + sovRpcpb(uint64(m.NewID))
	}
	if len(m.NewPeerIDs) > 0 {
		l = 0
		for _, e := range m.NewPeerIDs {
			l += sovRpcpb(uint64(e))
		}
		n += 1 + sovRpcpb(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateWatcherReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flag != 0 {
		n += 1 + sovRpcpb(uint64(m.Flag))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EventNotify) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seq != 0 {
		n += 1 + sovRpcpb(uint64(m.Seq))
	}
	if m.Type != 0 {
		n += 1 + sovRpcpb(uint64(m.Type))
	}
	if m.InitEvent != nil {
		l = m.InitEvent.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.ResourceEvent != nil {
		l = m.ResourceEvent.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.ContainerEvent != nil {
		l = m.ContainerEvent.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InitEventData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for _, b := range m.Resources {
			l = len(b)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if len(m.Leaders) > 0 {
		l = 0
		for _, e := range m.Leaders {
			l += sovRpcpb(uint64(e))
		}
		n += 1 + sovRpcpb(uint64(l)) + l
	}
	if len(m.Containers) > 0 {
		for _, b := range m.Containers {
			l = len(b)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourceEventData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Leader != 0 {
		n += 1 + sovRpcpb(uint64(m.Leader))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContainerEventData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChangePeer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Peer.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.ChangeType != 0 {
		n += 1 + sovRpcpb(uint64(m.ChangeType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransferLeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Peer.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChangePeerV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for _, e := range m.Changes {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Merge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SplitResource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Policy != 0 {
		n += 1 + sovRpcpb(uint64(m.Policy))
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TimeInterval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovRpcpb(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovRpcpb(uint64(m.End))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecordPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovRpcpb(uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContainerStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContainerID != 0 {
		n += 1 + sovRpcpb(uint64(m.ContainerID))
	}
	if m.StartTime != 0 {
		n += 1 + sovRpcpb(uint64(m.StartTime))
	}
	if m.Interval != nil {
		l = m.Interval.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Capacity != 0 {
		n += 1 + sovRpcpb(uint64(m.Capacity))
	}
	if m.Available != 0 {
		n += 1 + sovRpcpb(uint64(m.Available))
	}
	if m.UsedSize != 0 {
		n += 1 + sovRpcpb(uint64(m.UsedSize))
	}
	if m.IsBusy {
		n += 2
	}
	if m.ResourceCount != 0 {
		n += 1 + sovRpcpb(uint64(m.ResourceCount))
	}
	if m.SendingSnapCount != 0 {
		n += 1 + sovRpcpb(uint64(m.SendingSnapCount))
	}
	if m.ReceivingSnapCount != 0 {
		n += 1 + sovRpcpb(uint64(m.ReceivingSnapCount))
	}
	if m.ApplyingSnapCount != 0 {
		n += 1 + sovRpcpb(uint64(m.ApplyingSnapCount))
	}
	if m.BytesWritten != 0 {
		n += 1 + sovRpcpb(uint64(m.BytesWritten))
	}
	if m.BytesRead != 0 {
		n += 1 + sovRpcpb(uint64(m.BytesRead))
	}
	if m.KeysWritten != 0 {
		n += 1 + sovRpcpb(uint64(m.KeysWritten))
	}
	if m.KeysRead != 0 {
		n += 1 + sovRpcpb(uint64(m.KeysRead))
	}
	if len(m.CpuUsages) > 0 {
		for _, e := range m.CpuUsages {
			l = e.Size()
			n += 2 + l + sovRpcpb(uint64(l))
		}
	}
	if len(m.ReadIORates) > 0 {
		for _, e := range m.ReadIORates {
			l = e.Size()
			n += 2 + l + sovRpcpb(uint64(l))
		}
	}
	if len(m.WriteIORates) > 0 {
		for _, e := range m.WriteIORates {
			l = e.Size()
			n += 2 + l + sovRpcpb(uint64(l))
		}
	}
	if len(m.OpLatencies) > 0 {
		for _, e := range m.OpLatencies {
			l = e.Size()
			n += 2 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovRpcpb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRpcpb(x uint64) (n int) {
	return sovRpcpb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerID", wireType)
			}
			m.ContainerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceHeartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ContainerHeartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PutContainer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PutContainer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetContainer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetContainer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AllocID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AskSplit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskBatchSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AskBatchSplit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReportSplit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchReportSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BatchReportSplit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateWatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreateWatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceHeartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ContainerHeartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PutContainer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PutContainer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetContainer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetContainer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AllocID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AskSplit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskBatchSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AskBatchSplit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReportSplit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchReportSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BatchReportSplit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Event.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceHeartbeatReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceHeartbeatReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceHeartbeatReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerID", wireType)
			}
			m.ContainerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resource = append(m.Resource[:0], dAtA[iNdEx:postIndex]...)
			if m.Resource == nil {
				m.Resource = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Leader == nil {
				m.Leader = &metapb.Peer{}
			}
			if err := m.Leader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownPeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownPeers = append(m.DownPeers, metapb.PeerStats{})
			if err := m.DownPeers[len(m.DownPeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingPeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PendingPeers = append(m.PendingPeers, metapb.Peer{})
			if err := m.PendingPeers[len(m.PendingPeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesWritten", wireType)
			}
			m.BytesWritten = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesWritten |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesRead", wireType)
			}
			m.BytesRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesRead |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeysWritten", wireType)
			}
			m.KeysWritten = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeysWritten |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeysRead", wireType)
			}
			m.KeysRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeysRead |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproximateSize", wireType)
			}
			m.ApproximateSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApproximateSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproximateKeys", wireType)
			}
			m.ApproximateKeys = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApproximateKeys |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interval == nil {
				m.Interval = &TimeInterval{}
			}
			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceHeartbeatRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceHeartbeatRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceHeartbeatRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceID", wireType)
			}
			m.ResourceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResourceID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TargetPeer == nil {
				m.TargetPeer = &metapb.Peer{}
			}
			if err := m.TargetPeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangePeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangePeer == nil {
				m.ChangePeer = &ChangePeer{}
			}
			if err := m.ChangePeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferLeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransferLeader == nil {
				m.TransferLeader = &TransferLeader{}
			}
			if err := m.TransferLeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Merge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Merge == nil {
				m.Merge = &Merge{}
			}
			if err := m.Merge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitResource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SplitResource == nil {
				m.SplitResource = &SplitResource{}
			}
			if err := m.SplitResource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangePeerV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangePeerV2 == nil {
				m.ChangePeerV2 = &ChangePeerV2{}
			}
			if err := m.ChangePeerV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutContainerReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutContainerReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutContainerReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Container = append(m.Container[:0], dAtA[iNdEx:postIndex]...)
			if m.Container == nil {
				m.Container = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutContainerRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutContainerRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutContainerRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerHeartbeatReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerHeartbeatReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerHeartbeatReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerHeartbeatRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerHeartbeatRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerHeartbeatRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetContainerReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetContainerReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetContainerReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetContainerRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetContainerRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetContainerRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &ContainerStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocIDRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocIDRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocIDRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AskSplitReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AskSplitReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AskSplitReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AskSplitRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AskSplitRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AskSplitRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SplitID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportSplitReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportSplitReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportSplitReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Left = append(m.Left[:0], dAtA[iNdEx:postIndex]...)
			if m.Left == nil {
				m.Left = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Right = append(m.Right[:0], dAtA[iNdEx:postIndex]...)
			if m.Right == nil {
				m.Right = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportSplitRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportSplitRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportSplitRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AskBatchSplitReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AskBatchSplitReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AskBatchSplitReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AskBatchSplitRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AskBatchSplitRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AskBatchSplitRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SplitIDs = append(m.SplitIDs, SplitID{})
			if err := m.SplitIDs[len(m.SplitIDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchReportSplitReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchReportSplitReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchReportSplitReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, make([]byte, postIndex-iNdEx))
			copy(m.Resources[len(m.Resources)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchReportSplitRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchReportSplitRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchReportSplitRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewID", wireType)
			}
			m.NewID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NewPeerIDs = append(m.NewPeerIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRpcpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRpcpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NewPeerIDs) == 0 {
					m.NewPeerIDs = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NewPeerIDs = append(m.NewPeerIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPeerIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateWatcherReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateWatcherReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateWatcherReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventNotify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventNotify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventNotify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitEvent == nil {
				m.InitEvent = &InitEventData{}
			}
			if err := m.InitEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceEvent == nil {
				m.ResourceEvent = &ResourceEventData{}
			}
			if err := m.ResourceEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContainerEvent == nil {
				m.ContainerEvent = &ContainerEventData{}
			}
			if err := m.ContainerEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitEventData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitEventData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitEventData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, make([]byte, postIndex-iNdEx))
			copy(m.Resources[len(m.Resources)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Leaders = append(m.Leaders, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRpcpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRpcpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Leaders) == 0 {
					m.Leaders = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Leaders = append(m.Leaders, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Leaders", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Containers = append(m.Containers, make([]byte, postIndex-iNdEx))
			copy(m.Containers[len(m.Containers)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceEventData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceEventData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceEventData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			m.Leader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leader |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerEventData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerEventData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerEventData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangePeer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangePeer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangePeer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeType", wireType)
			}
			m.ChangeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeType |= metapb.ChangePeerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferLeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferLeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferLeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangePeerV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangePeerV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangePeerV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changes = append(m.Changes, ChangePeer{})
			if err := m.Changes[len(m.Changes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Merge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Merge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Merge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = append(m.Target[:0], dAtA[iNdEx:postIndex]...)
			if m.Target == nil {
				m.Target = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitResource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitResource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitResource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			m.Policy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Policy |= metapb.CheckPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeInterval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeInterval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeInterval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerID", wireType)
			}
			m.ContainerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interval == nil {
				m.Interval = &TimeInterval{}
			}
			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capacity", wireType)
			}
			m.Capacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Capacity |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Available", wireType)
			}
			m.Available = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Available |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedSize", wireType)
			}
			m.UsedSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBusy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBusy = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceCount", wireType)
			}
			m.ResourceCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResourceCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendingSnapCount", wireType)
			}
			m.SendingSnapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendingSnapCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceivingSnapCount", wireType)
			}
			m.ReceivingSnapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceivingSnapCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyingSnapCount", wireType)
			}
			m.ApplyingSnapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyingSnapCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesWritten", wireType)
			}
			m.BytesWritten = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesWritten |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesRead", wireType)
			}
			m.BytesRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesRead |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeysWritten", wireType)
			}
			m.KeysWritten = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeysWritten |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeysRead", wireType)
			}
			m.KeysRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeysRead |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuUsages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuUsages = append(m.CpuUsages, RecordPair{})
			if err := m.CpuUsages[len(m.CpuUsages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadIORates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadIORates = append(m.ReadIORates, RecordPair{})
			if err := m.ReadIORates[len(m.ReadIORates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteIORates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WriteIORates = append(m.WriteIORates, RecordPair{})
			if err := m.WriteIORates[len(m.WriteIORates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpLatencies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpLatencies = append(m.OpLatencies, RecordPair{})
			if err := m.OpLatencies[len(m.OpLatencies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRpcpb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRpcpb
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthRpcpb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRpcpb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthRpcpb
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRpcpb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRpcpb   = fmt.Errorf("proto: integer overflow")
)
