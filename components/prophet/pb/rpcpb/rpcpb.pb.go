// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rpcpb.proto

package rpcpb

import (
	fmt "fmt"
	io "io"
	math "math"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	metapb "github.com/matrixorigin/matrixcube/components/prophet/pb/metapb"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Type rpc type
type Type int32

const (
	TypeRegisterContainer     Type = 0
	TypeResourceHeartbeatReq  Type = 1
	TypeResourceHeartbeatRsp  Type = 2
	TypeContainerHeartbeatReq Type = 3
	TypeContainerHeartbeatRsp Type = 4
	TypePutContainerReq       Type = 5
	TypePutContainerRsp       Type = 6
	TypeGetContainerReq       Type = 7
	TypeGetContainerRsp       Type = 8
	TypeAllocIDReq            Type = 9
	TypeAllocIDRsp            Type = 10
	TypeAskBatchSplitReq      Type = 13
	TypeAskBatchSplitRsp      Type = 14
	TypeBatchReportSplitReq   Type = 17
	TypeBatchReportSplitRsp   Type = 18
	TypeCreateWatcherReq      Type = 19
	TypeEventNotify           Type = 20
	TypeCreateResourcesReq    Type = 21
	TypeCreateResourcesRsp    Type = 22
	TypeRemoveResourcesReq    Type = 23
	TypeRemoveResourcesRsp    Type = 24
	TypeCheckResourceStateReq Type = 25
	TypeCheckResourceStateRsp Type = 26
	TypePutPlacementRuleReq   Type = 27
	TypePutPlacementRuleRsp   Type = 28
	TypeGetAppliedRulesReq    Type = 29
	TypeGetAppliedRulesRsp    Type = 30
	TypeCreateJobReq          Type = 31
	TypeCreateJobRsp          Type = 32
	TypeRemoveJobReq          Type = 33
	TypeRemoveJobRsp          Type = 34
	TypeExecuteJobReq         Type = 35
	TypeExecuteJobRsp         Type = 36
)

var Type_name = map[int32]string{
	0:  "TypeRegisterContainer",
	1:  "TypeResourceHeartbeatReq",
	2:  "TypeResourceHeartbeatRsp",
	3:  "TypeContainerHeartbeatReq",
	4:  "TypeContainerHeartbeatRsp",
	5:  "TypePutContainerReq",
	6:  "TypePutContainerRsp",
	7:  "TypeGetContainerReq",
	8:  "TypeGetContainerRsp",
	9:  "TypeAllocIDReq",
	10: "TypeAllocIDRsp",
	13: "TypeAskBatchSplitReq",
	14: "TypeAskBatchSplitRsp",
	17: "TypeBatchReportSplitReq",
	18: "TypeBatchReportSplitRsp",
	19: "TypeCreateWatcherReq",
	20: "TypeEventNotify",
	21: "TypeCreateResourcesReq",
	22: "TypeCreateResourcesRsp",
	23: "TypeRemoveResourcesReq",
	24: "TypeRemoveResourcesRsp",
	25: "TypeCheckResourceStateReq",
	26: "TypeCheckResourceStateRsp",
	27: "TypePutPlacementRuleReq",
	28: "TypePutPlacementRuleRsp",
	29: "TypeGetAppliedRulesReq",
	30: "TypeGetAppliedRulesRsp",
	31: "TypeCreateJobReq",
	32: "TypeCreateJobRsp",
	33: "TypeRemoveJobReq",
	34: "TypeRemoveJobRsp",
	35: "TypeExecuteJobReq",
	36: "TypeExecuteJobRsp",
}

var Type_value = map[string]int32{
	"TypeRegisterContainer":     0,
	"TypeResourceHeartbeatReq":  1,
	"TypeResourceHeartbeatRsp":  2,
	"TypeContainerHeartbeatReq": 3,
	"TypeContainerHeartbeatRsp": 4,
	"TypePutContainerReq":       5,
	"TypePutContainerRsp":       6,
	"TypeGetContainerReq":       7,
	"TypeGetContainerRsp":       8,
	"TypeAllocIDReq":            9,
	"TypeAllocIDRsp":            10,
	"TypeAskBatchSplitReq":      13,
	"TypeAskBatchSplitRsp":      14,
	"TypeBatchReportSplitReq":   17,
	"TypeBatchReportSplitRsp":   18,
	"TypeCreateWatcherReq":      19,
	"TypeEventNotify":           20,
	"TypeCreateResourcesReq":    21,
	"TypeCreateResourcesRsp":    22,
	"TypeRemoveResourcesReq":    23,
	"TypeRemoveResourcesRsp":    24,
	"TypeCheckResourceStateReq": 25,
	"TypeCheckResourceStateRsp": 26,
	"TypePutPlacementRuleReq":   27,
	"TypePutPlacementRuleRsp":   28,
	"TypeGetAppliedRulesReq":    29,
	"TypeGetAppliedRulesRsp":    30,
	"TypeCreateJobReq":          31,
	"TypeCreateJobRsp":          32,
	"TypeRemoveJobReq":          33,
	"TypeRemoveJobRsp":          34,
	"TypeExecuteJobReq":         35,
	"TypeExecuteJobRsp":         36,
}

func (x Type) String() string {
	return proto.EnumName(Type_name, int32(x))
}

func (Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{0}
}

// PeerRoleType is the expected peer type of the placement rule
type ReplicaRoleType int32

const (
	// Voter can either match a leader peer or follower peer
	Voter ReplicaRoleType = 0
	// Leader matches a leader.
	Leader ReplicaRoleType = 1
	// Follower matches a follower.
	Follower ReplicaRoleType = 2
	// Learner matches a learner.
	Learner ReplicaRoleType = 3
)

var ReplicaRoleType_name = map[int32]string{
	0: "Voter",
	1: "Leader",
	2: "Follower",
	3: "Learner",
}

var ReplicaRoleType_value = map[string]int32{
	"Voter":    0,
	"Leader":   1,
	"Follower": 2,
	"Learner":  3,
}

func (x ReplicaRoleType) String() string {
	return proto.EnumName(ReplicaRoleType_name, int32(x))
}

func (ReplicaRoleType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{1}
}

// LabelConstraintOp defines how a LabelConstraint matches a container. It can be one of
// 'in', 'notIn', 'exists', or 'notExists'.
type LabelConstraintOp int32

const (
	// In If label does not exist, `in` is always false.
	In LabelConstraintOp = 0
	// NotIn restricts the container label value should not in the value list.
	NotIn LabelConstraintOp = 1
	// Exists restricts the container should have the label.
	Exists LabelConstraintOp = 2
	// NotExists restricts the container should not have the label.
	NotExists LabelConstraintOp = 3
)

var LabelConstraintOp_name = map[int32]string{
	0: "In",
	1: "NotIn",
	2: "Exists",
	3: "NotExists",
}

var LabelConstraintOp_value = map[string]int32{
	"In":        0,
	"NotIn":     1,
	"Exists":    2,
	"NotExists": 3,
}

func (x LabelConstraintOp) String() string {
	return proto.EnumName(LabelConstraintOp_name, int32(x))
}

func (LabelConstraintOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{2}
}

// Request the prophet rpc request
type Request struct {
	ID                   uint64                `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	ContainerID          uint64                `protobuf:"varint,2,opt,name=containerID,proto3" json:"containerID,omitempty"`
	Type                 Type                  `protobuf:"varint,3,opt,name=type,proto3,enum=rpcpb.Type" json:"type,omitempty"`
	ResourceHeartbeat    ResourceHeartbeatReq  `protobuf:"bytes,4,opt,name=resourceHeartbeat,proto3" json:"resourceHeartbeat"`
	ContainerHeartbeat   ContainerHeartbeatReq `protobuf:"bytes,5,opt,name=containerHeartbeat,proto3" json:"containerHeartbeat"`
	PutContainer         PutContainerReq       `protobuf:"bytes,6,opt,name=putContainer,proto3" json:"putContainer"`
	GetContainer         GetContainerReq       `protobuf:"bytes,7,opt,name=getContainer,proto3" json:"getContainer"`
	AllocID              AllocIDReq            `protobuf:"bytes,8,opt,name=allocID,proto3" json:"allocID"`
	AskBatchSplit        AskBatchSplitReq      `protobuf:"bytes,10,opt,name=askBatchSplit,proto3" json:"askBatchSplit"`
	BatchReportSplit     BatchReportSplitReq   `protobuf:"bytes,12,opt,name=batchReportSplit,proto3" json:"batchReportSplit"`
	CreateWatcher        CreateWatcherReq      `protobuf:"bytes,13,opt,name=createWatcher,proto3" json:"createWatcher"`
	CreateResources      CreateResourcesReq    `protobuf:"bytes,14,opt,name=createResources,proto3" json:"createResources"`
	RemoveResources      RemoveResourcesReq    `protobuf:"bytes,15,opt,name=removeResources,proto3" json:"removeResources"`
	CheckResourceState   CheckResourceStateReq `protobuf:"bytes,16,opt,name=checkResourceState,proto3" json:"checkResourceState"`
	PutPlacementRule     PutPlacementRuleReq   `protobuf:"bytes,17,opt,name=putPlacementRule,proto3" json:"putPlacementRule"`
	GetAppliedRules      GetAppliedRulesReq    `protobuf:"bytes,18,opt,name=getAppliedRules,proto3" json:"getAppliedRules"`
	CreateJob            CreateJobReq          `protobuf:"bytes,19,opt,name=createJob,proto3" json:"createJob"`
	RemoveJob            RemoveJobReq          `protobuf:"bytes,20,opt,name=removeJob,proto3" json:"removeJob"`
	ExecuteJob           ExecuteJobReq         `protobuf:"bytes,21,opt,name=executeJob,proto3" json:"executeJob"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{0}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Request) GetContainerID() uint64 {
	if m != nil {
		return m.ContainerID
	}
	return 0
}

func (m *Request) GetType() Type {
	if m != nil {
		return m.Type
	}
	return TypeRegisterContainer
}

func (m *Request) GetResourceHeartbeat() ResourceHeartbeatReq {
	if m != nil {
		return m.ResourceHeartbeat
	}
	return ResourceHeartbeatReq{}
}

func (m *Request) GetContainerHeartbeat() ContainerHeartbeatReq {
	if m != nil {
		return m.ContainerHeartbeat
	}
	return ContainerHeartbeatReq{}
}

func (m *Request) GetPutContainer() PutContainerReq {
	if m != nil {
		return m.PutContainer
	}
	return PutContainerReq{}
}

func (m *Request) GetGetContainer() GetContainerReq {
	if m != nil {
		return m.GetContainer
	}
	return GetContainerReq{}
}

func (m *Request) GetAllocID() AllocIDReq {
	if m != nil {
		return m.AllocID
	}
	return AllocIDReq{}
}

func (m *Request) GetAskBatchSplit() AskBatchSplitReq {
	if m != nil {
		return m.AskBatchSplit
	}
	return AskBatchSplitReq{}
}

func (m *Request) GetBatchReportSplit() BatchReportSplitReq {
	if m != nil {
		return m.BatchReportSplit
	}
	return BatchReportSplitReq{}
}

func (m *Request) GetCreateWatcher() CreateWatcherReq {
	if m != nil {
		return m.CreateWatcher
	}
	return CreateWatcherReq{}
}

func (m *Request) GetCreateResources() CreateResourcesReq {
	if m != nil {
		return m.CreateResources
	}
	return CreateResourcesReq{}
}

func (m *Request) GetRemoveResources() RemoveResourcesReq {
	if m != nil {
		return m.RemoveResources
	}
	return RemoveResourcesReq{}
}

func (m *Request) GetCheckResourceState() CheckResourceStateReq {
	if m != nil {
		return m.CheckResourceState
	}
	return CheckResourceStateReq{}
}

func (m *Request) GetPutPlacementRule() PutPlacementRuleReq {
	if m != nil {
		return m.PutPlacementRule
	}
	return PutPlacementRuleReq{}
}

func (m *Request) GetGetAppliedRules() GetAppliedRulesReq {
	if m != nil {
		return m.GetAppliedRules
	}
	return GetAppliedRulesReq{}
}

func (m *Request) GetCreateJob() CreateJobReq {
	if m != nil {
		return m.CreateJob
	}
	return CreateJobReq{}
}

func (m *Request) GetRemoveJob() RemoveJobReq {
	if m != nil {
		return m.RemoveJob
	}
	return RemoveJobReq{}
}

func (m *Request) GetExecuteJob() ExecuteJobReq {
	if m != nil {
		return m.ExecuteJob
	}
	return ExecuteJobReq{}
}

// Response the prophet rpc response
type Response struct {
	ID                   uint64                `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type                 Type                  `protobuf:"varint,2,opt,name=type,proto3,enum=rpcpb.Type" json:"type,omitempty"`
	Error                string                `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	Leader               string                `protobuf:"bytes,4,opt,name=leader,proto3" json:"leader,omitempty"`
	ResourceHeartbeat    ResourceHeartbeatRsp  `protobuf:"bytes,5,opt,name=resourceHeartbeat,proto3" json:"resourceHeartbeat"`
	ContainerHeartbeat   ContainerHeartbeatRsp `protobuf:"bytes,6,opt,name=containerHeartbeat,proto3" json:"containerHeartbeat"`
	PutContainer         PutContainerRsp       `protobuf:"bytes,7,opt,name=putContainer,proto3" json:"putContainer"`
	GetContainer         GetContainerRsp       `protobuf:"bytes,8,opt,name=getContainer,proto3" json:"getContainer"`
	AllocID              AllocIDRsp            `protobuf:"bytes,9,opt,name=allocID,proto3" json:"allocID"`
	AskBatchSplit        AskBatchSplitRsp      `protobuf:"bytes,11,opt,name=askBatchSplit,proto3" json:"askBatchSplit"`
	BatchReportSplit     BatchReportSplitRsp   `protobuf:"bytes,13,opt,name=batchReportSplit,proto3" json:"batchReportSplit"`
	Event                EventNotify           `protobuf:"bytes,14,opt,name=event,proto3" json:"event"`
	CreateResources      CreateResourcesRsp    `protobuf:"bytes,15,opt,name=createResources,proto3" json:"createResources"`
	RemoveResources      RemoveResourcesRsp    `protobuf:"bytes,16,opt,name=removeResources,proto3" json:"removeResources"`
	CheckResourceState   CheckResourceStateRsp `protobuf:"bytes,17,opt,name=checkResourceState,proto3" json:"checkResourceState"`
	PutPlacementRule     PutPlacementRuleRsp   `protobuf:"bytes,18,opt,name=putPlacementRule,proto3" json:"putPlacementRule"`
	GetAppliedRules      GetAppliedRulesRsp    `protobuf:"bytes,19,opt,name=getAppliedRules,proto3" json:"getAppliedRules"`
	CreateJob            CreateJobRsp          `protobuf:"bytes,20,opt,name=createJob,proto3" json:"createJob"`
	RemoveJob            RemoveJobRsp          `protobuf:"bytes,21,opt,name=removeJob,proto3" json:"removeJob"`
	ExecuteJob           ExecuteJobRsp         `protobuf:"bytes,22,opt,name=executeJob,proto3" json:"executeJob"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{1}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Response) GetType() Type {
	if m != nil {
		return m.Type
	}
	return TypeRegisterContainer
}

func (m *Response) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *Response) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

func (m *Response) GetResourceHeartbeat() ResourceHeartbeatRsp {
	if m != nil {
		return m.ResourceHeartbeat
	}
	return ResourceHeartbeatRsp{}
}

func (m *Response) GetContainerHeartbeat() ContainerHeartbeatRsp {
	if m != nil {
		return m.ContainerHeartbeat
	}
	return ContainerHeartbeatRsp{}
}

func (m *Response) GetPutContainer() PutContainerRsp {
	if m != nil {
		return m.PutContainer
	}
	return PutContainerRsp{}
}

func (m *Response) GetGetContainer() GetContainerRsp {
	if m != nil {
		return m.GetContainer
	}
	return GetContainerRsp{}
}

func (m *Response) GetAllocID() AllocIDRsp {
	if m != nil {
		return m.AllocID
	}
	return AllocIDRsp{}
}

func (m *Response) GetAskBatchSplit() AskBatchSplitRsp {
	if m != nil {
		return m.AskBatchSplit
	}
	return AskBatchSplitRsp{}
}

func (m *Response) GetBatchReportSplit() BatchReportSplitRsp {
	if m != nil {
		return m.BatchReportSplit
	}
	return BatchReportSplitRsp{}
}

func (m *Response) GetEvent() EventNotify {
	if m != nil {
		return m.Event
	}
	return EventNotify{}
}

func (m *Response) GetCreateResources() CreateResourcesRsp {
	if m != nil {
		return m.CreateResources
	}
	return CreateResourcesRsp{}
}

func (m *Response) GetRemoveResources() RemoveResourcesRsp {
	if m != nil {
		return m.RemoveResources
	}
	return RemoveResourcesRsp{}
}

func (m *Response) GetCheckResourceState() CheckResourceStateRsp {
	if m != nil {
		return m.CheckResourceState
	}
	return CheckResourceStateRsp{}
}

func (m *Response) GetPutPlacementRule() PutPlacementRuleRsp {
	if m != nil {
		return m.PutPlacementRule
	}
	return PutPlacementRuleRsp{}
}

func (m *Response) GetGetAppliedRules() GetAppliedRulesRsp {
	if m != nil {
		return m.GetAppliedRules
	}
	return GetAppliedRulesRsp{}
}

func (m *Response) GetCreateJob() CreateJobRsp {
	if m != nil {
		return m.CreateJob
	}
	return CreateJobRsp{}
}

func (m *Response) GetRemoveJob() RemoveJobRsp {
	if m != nil {
		return m.RemoveJob
	}
	return RemoveJobRsp{}
}

func (m *Response) GetExecuteJob() ExecuteJobRsp {
	if m != nil {
		return m.ExecuteJob
	}
	return ExecuteJobRsp{}
}

// ResourceHeartbeatReq resource heartbeat request
type ResourceHeartbeatReq struct {
	ContainerID uint64 `protobuf:"varint,1,opt,name=containerID,proto3" json:"containerID,omitempty"`
	Resource    []byte `protobuf:"bytes,2,opt,name=resource,proto3" json:"resource,omitempty"`
	// Term is the term of raft group.
	Term                 uint64                `protobuf:"varint,3,opt,name=term,proto3" json:"term,omitempty"`
	Leader               *metapb.Replica       `protobuf:"bytes,4,opt,name=leader,proto3" json:"leader,omitempty"`
	DownReplicas         []metapb.ReplicaStats `protobuf:"bytes,5,rep,name=downReplicas,proto3" json:"downReplicas"`
	PendingReplicas      []metapb.Replica      `protobuf:"bytes,6,rep,name=pendingReplicas,proto3" json:"pendingReplicas"`
	Stats                metapb.ResourceStats  `protobuf:"bytes,7,opt,name=stats,proto3" json:"stats"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ResourceHeartbeatReq) Reset()         { *m = ResourceHeartbeatReq{} }
func (m *ResourceHeartbeatReq) String() string { return proto.CompactTextString(m) }
func (*ResourceHeartbeatReq) ProtoMessage()    {}
func (*ResourceHeartbeatReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{2}
}
func (m *ResourceHeartbeatReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceHeartbeatReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceHeartbeatReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceHeartbeatReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceHeartbeatReq.Merge(m, src)
}
func (m *ResourceHeartbeatReq) XXX_Size() int {
	return m.Size()
}
func (m *ResourceHeartbeatReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceHeartbeatReq.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceHeartbeatReq proto.InternalMessageInfo

func (m *ResourceHeartbeatReq) GetContainerID() uint64 {
	if m != nil {
		return m.ContainerID
	}
	return 0
}

func (m *ResourceHeartbeatReq) GetResource() []byte {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *ResourceHeartbeatReq) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *ResourceHeartbeatReq) GetLeader() *metapb.Replica {
	if m != nil {
		return m.Leader
	}
	return nil
}

func (m *ResourceHeartbeatReq) GetDownReplicas() []metapb.ReplicaStats {
	if m != nil {
		return m.DownReplicas
	}
	return nil
}

func (m *ResourceHeartbeatReq) GetPendingReplicas() []metapb.Replica {
	if m != nil {
		return m.PendingReplicas
	}
	return nil
}

func (m *ResourceHeartbeatReq) GetStats() metapb.ResourceStats {
	if m != nil {
		return m.Stats
	}
	return metapb.ResourceStats{}
}

// ResourceHeartbeatRsp resource heartbeat response.
type ResourceHeartbeatRsp struct {
	ResourceID    uint64               `protobuf:"varint,1,opt,name=resourceID,proto3" json:"resourceID,omitempty"`
	ResourceEpoch metapb.ResourceEpoch `protobuf:"bytes,2,opt,name=resourceEpoch,proto3" json:"resourceEpoch"`
	// Leader of the resource at the moment of the corresponding request was made.
	TargetReplica *metapb.Replica `protobuf:"bytes,3,opt,name=targetReplica,proto3" json:"targetReplica,omitempty"`
	// Notice, prophet only allows handling reported epoch >= current prophet's.
	// Leader peer reports resource status with ResourceHeartbeatReq
	// to prophet regularly, prophet will determine whether this resource
	// should do ChangePeer or not.
	// E,g, max peer number is 3, resource A, first only peer 1 in A.
	// 1. prophet resource state -> Peers (1), ConfVer (1).
	// 2. Leader peer 1 reports resource state to prophet, prophet finds the
	// peer number is < 3, so first changes its current resource
	// state -> Peers (1, 2), ConfVer (1), and returns ChangePeer Adding 2.
	// 3. Leader does ChangePeer, then reports Peers (1, 2), ConfVer (2),
	// prophet updates its state -> Peers (1, 2), ConfVer (2).
	// 4. Leader may report old Peers (1), ConfVer (1) to pd before ConfChange
	// finished, pd stills responses ChangePeer Adding 2, of course, we must
	// guarantee the second ChangePeer can't be applied in your application.
	ConfigChange   *ConfigChange   `protobuf:"bytes,4,opt,name=configChange,proto3" json:"configChange,omitempty"`
	TransferLeader *TransferLeader `protobuf:"bytes,5,opt,name=transferLeader,proto3" json:"transferLeader,omitempty"`
	Merge          *Merge          `protobuf:"bytes,6,opt,name=merge,proto3" json:"merge,omitempty"`
	SplitResource  *SplitResource  `protobuf:"bytes,7,opt,name=splitResource,proto3" json:"splitResource,omitempty"`
	ConfigChangeV2 *ConfigChangeV2 `protobuf:"bytes,8,opt,name=configChangeV2,proto3" json:"configChangeV2,omitempty"`
	// DestoryDirectly the resource has been removed, destory directly without raft.
	DestoryDirectly      bool     `protobuf:"varint,9,opt,name=destoryDirectly,proto3" json:"destoryDirectly,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResourceHeartbeatRsp) Reset()         { *m = ResourceHeartbeatRsp{} }
func (m *ResourceHeartbeatRsp) String() string { return proto.CompactTextString(m) }
func (*ResourceHeartbeatRsp) ProtoMessage()    {}
func (*ResourceHeartbeatRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{3}
}
func (m *ResourceHeartbeatRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceHeartbeatRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceHeartbeatRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceHeartbeatRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceHeartbeatRsp.Merge(m, src)
}
func (m *ResourceHeartbeatRsp) XXX_Size() int {
	return m.Size()
}
func (m *ResourceHeartbeatRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceHeartbeatRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceHeartbeatRsp proto.InternalMessageInfo

func (m *ResourceHeartbeatRsp) GetResourceID() uint64 {
	if m != nil {
		return m.ResourceID
	}
	return 0
}

func (m *ResourceHeartbeatRsp) GetResourceEpoch() metapb.ResourceEpoch {
	if m != nil {
		return m.ResourceEpoch
	}
	return metapb.ResourceEpoch{}
}

func (m *ResourceHeartbeatRsp) GetTargetReplica() *metapb.Replica {
	if m != nil {
		return m.TargetReplica
	}
	return nil
}

func (m *ResourceHeartbeatRsp) GetConfigChange() *ConfigChange {
	if m != nil {
		return m.ConfigChange
	}
	return nil
}

func (m *ResourceHeartbeatRsp) GetTransferLeader() *TransferLeader {
	if m != nil {
		return m.TransferLeader
	}
	return nil
}

func (m *ResourceHeartbeatRsp) GetMerge() *Merge {
	if m != nil {
		return m.Merge
	}
	return nil
}

func (m *ResourceHeartbeatRsp) GetSplitResource() *SplitResource {
	if m != nil {
		return m.SplitResource
	}
	return nil
}

func (m *ResourceHeartbeatRsp) GetConfigChangeV2() *ConfigChangeV2 {
	if m != nil {
		return m.ConfigChangeV2
	}
	return nil
}

func (m *ResourceHeartbeatRsp) GetDestoryDirectly() bool {
	if m != nil {
		return m.DestoryDirectly
	}
	return false
}

// PutContainerReq put container request
type PutContainerReq struct {
	Container            []byte   `protobuf:"bytes,1,opt,name=container,proto3" json:"container,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PutContainerReq) Reset()         { *m = PutContainerReq{} }
func (m *PutContainerReq) String() string { return proto.CompactTextString(m) }
func (*PutContainerReq) ProtoMessage()    {}
func (*PutContainerReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{4}
}
func (m *PutContainerReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutContainerReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutContainerReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutContainerReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutContainerReq.Merge(m, src)
}
func (m *PutContainerReq) XXX_Size() int {
	return m.Size()
}
func (m *PutContainerReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PutContainerReq.DiscardUnknown(m)
}

var xxx_messageInfo_PutContainerReq proto.InternalMessageInfo

func (m *PutContainerReq) GetContainer() []byte {
	if m != nil {
		return m.Container
	}
	return nil
}

// PutContainerRsp put container response
type PutContainerRsp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PutContainerRsp) Reset()         { *m = PutContainerRsp{} }
func (m *PutContainerRsp) String() string { return proto.CompactTextString(m) }
func (*PutContainerRsp) ProtoMessage()    {}
func (*PutContainerRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{5}
}
func (m *PutContainerRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutContainerRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutContainerRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutContainerRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutContainerRsp.Merge(m, src)
}
func (m *PutContainerRsp) XXX_Size() int {
	return m.Size()
}
func (m *PutContainerRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_PutContainerRsp.DiscardUnknown(m)
}

var xxx_messageInfo_PutContainerRsp proto.InternalMessageInfo

// ContainerHeartbeatReq container heartbeat request
type ContainerHeartbeatReq struct {
	Stats                metapb.ContainerStats `protobuf:"bytes,1,opt,name=stats,proto3" json:"stats"`
	Data                 []byte                `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ContainerHeartbeatReq) Reset()         { *m = ContainerHeartbeatReq{} }
func (m *ContainerHeartbeatReq) String() string { return proto.CompactTextString(m) }
func (*ContainerHeartbeatReq) ProtoMessage()    {}
func (*ContainerHeartbeatReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{6}
}
func (m *ContainerHeartbeatReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerHeartbeatReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerHeartbeatReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerHeartbeatReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerHeartbeatReq.Merge(m, src)
}
func (m *ContainerHeartbeatReq) XXX_Size() int {
	return m.Size()
}
func (m *ContainerHeartbeatReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerHeartbeatReq.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerHeartbeatReq proto.InternalMessageInfo

func (m *ContainerHeartbeatReq) GetStats() metapb.ContainerStats {
	if m != nil {
		return m.Stats
	}
	return metapb.ContainerStats{}
}

func (m *ContainerHeartbeatReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// ContainerHeartbeatRsp container heartbeat response
type ContainerHeartbeatRsp struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ContainerHeartbeatRsp) Reset()         { *m = ContainerHeartbeatRsp{} }
func (m *ContainerHeartbeatRsp) String() string { return proto.CompactTextString(m) }
func (*ContainerHeartbeatRsp) ProtoMessage()    {}
func (*ContainerHeartbeatRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{7}
}
func (m *ContainerHeartbeatRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerHeartbeatRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerHeartbeatRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerHeartbeatRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerHeartbeatRsp.Merge(m, src)
}
func (m *ContainerHeartbeatRsp) XXX_Size() int {
	return m.Size()
}
func (m *ContainerHeartbeatRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerHeartbeatRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerHeartbeatRsp proto.InternalMessageInfo

func (m *ContainerHeartbeatRsp) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// GetContainerReq get container request
type GetContainerReq struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetContainerReq) Reset()         { *m = GetContainerReq{} }
func (m *GetContainerReq) String() string { return proto.CompactTextString(m) }
func (*GetContainerReq) ProtoMessage()    {}
func (*GetContainerReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{8}
}
func (m *GetContainerReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetContainerReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetContainerReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetContainerReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetContainerReq.Merge(m, src)
}
func (m *GetContainerReq) XXX_Size() int {
	return m.Size()
}
func (m *GetContainerReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetContainerReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetContainerReq proto.InternalMessageInfo

func (m *GetContainerReq) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

// GetContainerRsp get container response
type GetContainerRsp struct {
	Data                 []byte                 `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Stats                *metapb.ContainerStats `protobuf:"bytes,2,opt,name=stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *GetContainerRsp) Reset()         { *m = GetContainerRsp{} }
func (m *GetContainerRsp) String() string { return proto.CompactTextString(m) }
func (*GetContainerRsp) ProtoMessage()    {}
func (*GetContainerRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{9}
}
func (m *GetContainerRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetContainerRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetContainerRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetContainerRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetContainerRsp.Merge(m, src)
}
func (m *GetContainerRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetContainerRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetContainerRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetContainerRsp proto.InternalMessageInfo

func (m *GetContainerRsp) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *GetContainerRsp) GetStats() *metapb.ContainerStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// AllocIDReq alloc id request
type AllocIDReq struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AllocIDReq) Reset()         { *m = AllocIDReq{} }
func (m *AllocIDReq) String() string { return proto.CompactTextString(m) }
func (*AllocIDReq) ProtoMessage()    {}
func (*AllocIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{10}
}
func (m *AllocIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllocIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllocIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocIDReq.Merge(m, src)
}
func (m *AllocIDReq) XXX_Size() int {
	return m.Size()
}
func (m *AllocIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_AllocIDReq proto.InternalMessageInfo

// AllocIDRsp alloc id response
type AllocIDRsp struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AllocIDRsp) Reset()         { *m = AllocIDRsp{} }
func (m *AllocIDRsp) String() string { return proto.CompactTextString(m) }
func (*AllocIDRsp) ProtoMessage()    {}
func (*AllocIDRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{11}
}
func (m *AllocIDRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocIDRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllocIDRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllocIDRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocIDRsp.Merge(m, src)
}
func (m *AllocIDRsp) XXX_Size() int {
	return m.Size()
}
func (m *AllocIDRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocIDRsp.DiscardUnknown(m)
}

var xxx_messageInfo_AllocIDRsp proto.InternalMessageInfo

func (m *AllocIDRsp) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

// AskBatchSplitReq ask batch split request
type AskBatchSplitReq struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Count                uint32   `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AskBatchSplitReq) Reset()         { *m = AskBatchSplitReq{} }
func (m *AskBatchSplitReq) String() string { return proto.CompactTextString(m) }
func (*AskBatchSplitReq) ProtoMessage()    {}
func (*AskBatchSplitReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{12}
}
func (m *AskBatchSplitReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AskBatchSplitReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AskBatchSplitReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AskBatchSplitReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AskBatchSplitReq.Merge(m, src)
}
func (m *AskBatchSplitReq) XXX_Size() int {
	return m.Size()
}
func (m *AskBatchSplitReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AskBatchSplitReq.DiscardUnknown(m)
}

var xxx_messageInfo_AskBatchSplitReq proto.InternalMessageInfo

func (m *AskBatchSplitReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *AskBatchSplitReq) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

// AskBatchSplitRsp ask batch split response
type AskBatchSplitRsp struct {
	SplitIDs             []SplitID `protobuf:"bytes,1,rep,name=splitIDs,proto3" json:"splitIDs"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *AskBatchSplitRsp) Reset()         { *m = AskBatchSplitRsp{} }
func (m *AskBatchSplitRsp) String() string { return proto.CompactTextString(m) }
func (*AskBatchSplitRsp) ProtoMessage()    {}
func (*AskBatchSplitRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{13}
}
func (m *AskBatchSplitRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AskBatchSplitRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AskBatchSplitRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AskBatchSplitRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AskBatchSplitRsp.Merge(m, src)
}
func (m *AskBatchSplitRsp) XXX_Size() int {
	return m.Size()
}
func (m *AskBatchSplitRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_AskBatchSplitRsp.DiscardUnknown(m)
}

var xxx_messageInfo_AskBatchSplitRsp proto.InternalMessageInfo

func (m *AskBatchSplitRsp) GetSplitIDs() []SplitID {
	if m != nil {
		return m.SplitIDs
	}
	return nil
}

// BatchReportSplitReq report split request
type BatchReportSplitReq struct {
	Resources            [][]byte `protobuf:"bytes,1,rep,name=resources,proto3" json:"resources,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BatchReportSplitReq) Reset()         { *m = BatchReportSplitReq{} }
func (m *BatchReportSplitReq) String() string { return proto.CompactTextString(m) }
func (*BatchReportSplitReq) ProtoMessage()    {}
func (*BatchReportSplitReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{14}
}
func (m *BatchReportSplitReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchReportSplitReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchReportSplitReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchReportSplitReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchReportSplitReq.Merge(m, src)
}
func (m *BatchReportSplitReq) XXX_Size() int {
	return m.Size()
}
func (m *BatchReportSplitReq) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchReportSplitReq.DiscardUnknown(m)
}

var xxx_messageInfo_BatchReportSplitReq proto.InternalMessageInfo

func (m *BatchReportSplitReq) GetResources() [][]byte {
	if m != nil {
		return m.Resources
	}
	return nil
}

// BatchReportSplitRsp report split response
type BatchReportSplitRsp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BatchReportSplitRsp) Reset()         { *m = BatchReportSplitRsp{} }
func (m *BatchReportSplitRsp) String() string { return proto.CompactTextString(m) }
func (*BatchReportSplitRsp) ProtoMessage()    {}
func (*BatchReportSplitRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{15}
}
func (m *BatchReportSplitRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchReportSplitRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchReportSplitRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchReportSplitRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchReportSplitRsp.Merge(m, src)
}
func (m *BatchReportSplitRsp) XXX_Size() int {
	return m.Size()
}
func (m *BatchReportSplitRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchReportSplitRsp.DiscardUnknown(m)
}

var xxx_messageInfo_BatchReportSplitRsp proto.InternalMessageInfo

// SplitID split id
type SplitID struct {
	NewID                uint64   `protobuf:"varint,1,opt,name=newID,proto3" json:"newID,omitempty"`
	NewReplicaIDs        []uint64 `protobuf:"varint,2,rep,packed,name=newReplicaIDs,proto3" json:"newReplicaIDs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SplitID) Reset()         { *m = SplitID{} }
func (m *SplitID) String() string { return proto.CompactTextString(m) }
func (*SplitID) ProtoMessage()    {}
func (*SplitID) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{16}
}
func (m *SplitID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitID.Merge(m, src)
}
func (m *SplitID) XXX_Size() int {
	return m.Size()
}
func (m *SplitID) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitID.DiscardUnknown(m)
}

var xxx_messageInfo_SplitID proto.InternalMessageInfo

func (m *SplitID) GetNewID() uint64 {
	if m != nil {
		return m.NewID
	}
	return 0
}

func (m *SplitID) GetNewReplicaIDs() []uint64 {
	if m != nil {
		return m.NewReplicaIDs
	}
	return nil
}

// CreateWatcherReq create watcher req
type CreateWatcherReq struct {
	Flag                 uint32   `protobuf:"varint,1,opt,name=flag,proto3" json:"flag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateWatcherReq) Reset()         { *m = CreateWatcherReq{} }
func (m *CreateWatcherReq) String() string { return proto.CompactTextString(m) }
func (*CreateWatcherReq) ProtoMessage()    {}
func (*CreateWatcherReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{17}
}
func (m *CreateWatcherReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateWatcherReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateWatcherReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateWatcherReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateWatcherReq.Merge(m, src)
}
func (m *CreateWatcherReq) XXX_Size() int {
	return m.Size()
}
func (m *CreateWatcherReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateWatcherReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreateWatcherReq proto.InternalMessageInfo

func (m *CreateWatcherReq) GetFlag() uint32 {
	if m != nil {
		return m.Flag
	}
	return 0
}

// CreateResourcesReq create resources req
type CreateResourcesReq struct {
	Resources            [][]byte `protobuf:"bytes,1,rep,name=resources,proto3" json:"resources,omitempty"`
	LeastReplicas        []uint64 `protobuf:"varint,2,rep,packed,name=leastReplicas,proto3" json:"leastReplicas,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateResourcesReq) Reset()         { *m = CreateResourcesReq{} }
func (m *CreateResourcesReq) String() string { return proto.CompactTextString(m) }
func (*CreateResourcesReq) ProtoMessage()    {}
func (*CreateResourcesReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{18}
}
func (m *CreateResourcesReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateResourcesReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateResourcesReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateResourcesReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateResourcesReq.Merge(m, src)
}
func (m *CreateResourcesReq) XXX_Size() int {
	return m.Size()
}
func (m *CreateResourcesReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateResourcesReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreateResourcesReq proto.InternalMessageInfo

func (m *CreateResourcesReq) GetResources() [][]byte {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *CreateResourcesReq) GetLeastReplicas() []uint64 {
	if m != nil {
		return m.LeastReplicas
	}
	return nil
}

// CreateResourcesRsp create resources rsp
type CreateResourcesRsp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateResourcesRsp) Reset()         { *m = CreateResourcesRsp{} }
func (m *CreateResourcesRsp) String() string { return proto.CompactTextString(m) }
func (*CreateResourcesRsp) ProtoMessage()    {}
func (*CreateResourcesRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{19}
}
func (m *CreateResourcesRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateResourcesRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateResourcesRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateResourcesRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateResourcesRsp.Merge(m, src)
}
func (m *CreateResourcesRsp) XXX_Size() int {
	return m.Size()
}
func (m *CreateResourcesRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateResourcesRsp.DiscardUnknown(m)
}

var xxx_messageInfo_CreateResourcesRsp proto.InternalMessageInfo

// RemoveResourcesReq remove resources req
type RemoveResourcesReq struct {
	IDs                  []uint64 `protobuf:"varint,1,rep,packed,name=ids,proto3" json:"ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoveResourcesReq) Reset()         { *m = RemoveResourcesReq{} }
func (m *RemoveResourcesReq) String() string { return proto.CompactTextString(m) }
func (*RemoveResourcesReq) ProtoMessage()    {}
func (*RemoveResourcesReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{20}
}
func (m *RemoveResourcesReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveResourcesReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveResourcesReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveResourcesReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveResourcesReq.Merge(m, src)
}
func (m *RemoveResourcesReq) XXX_Size() int {
	return m.Size()
}
func (m *RemoveResourcesReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveResourcesReq.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveResourcesReq proto.InternalMessageInfo

func (m *RemoveResourcesReq) GetIDs() []uint64 {
	if m != nil {
		return m.IDs
	}
	return nil
}

// RemoveResourcesRsp remove resources rsp
type RemoveResourcesRsp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoveResourcesRsp) Reset()         { *m = RemoveResourcesRsp{} }
func (m *RemoveResourcesRsp) String() string { return proto.CompactTextString(m) }
func (*RemoveResourcesRsp) ProtoMessage()    {}
func (*RemoveResourcesRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{21}
}
func (m *RemoveResourcesRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveResourcesRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveResourcesRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveResourcesRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveResourcesRsp.Merge(m, src)
}
func (m *RemoveResourcesRsp) XXX_Size() int {
	return m.Size()
}
func (m *RemoveResourcesRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveResourcesRsp.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveResourcesRsp proto.InternalMessageInfo

// CheckResourceStateReq check resource state req
type CheckResourceStateReq struct {
	IDs                  []byte   `protobuf:"bytes,1,opt,name=ids,proto3" json:"ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckResourceStateReq) Reset()         { *m = CheckResourceStateReq{} }
func (m *CheckResourceStateReq) String() string { return proto.CompactTextString(m) }
func (*CheckResourceStateReq) ProtoMessage()    {}
func (*CheckResourceStateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{22}
}
func (m *CheckResourceStateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckResourceStateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckResourceStateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckResourceStateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckResourceStateReq.Merge(m, src)
}
func (m *CheckResourceStateReq) XXX_Size() int {
	return m.Size()
}
func (m *CheckResourceStateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckResourceStateReq.DiscardUnknown(m)
}

var xxx_messageInfo_CheckResourceStateReq proto.InternalMessageInfo

func (m *CheckResourceStateReq) GetIDs() []byte {
	if m != nil {
		return m.IDs
	}
	return nil
}

// CheckResourceStateReq check resource state rsp
type CheckResourceStateRsp struct {
	Removed              []uint64 `protobuf:"varint,1,rep,packed,name=removed,proto3" json:"removed,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckResourceStateRsp) Reset()         { *m = CheckResourceStateRsp{} }
func (m *CheckResourceStateRsp) String() string { return proto.CompactTextString(m) }
func (*CheckResourceStateRsp) ProtoMessage()    {}
func (*CheckResourceStateRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{23}
}
func (m *CheckResourceStateRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckResourceStateRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckResourceStateRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckResourceStateRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckResourceStateRsp.Merge(m, src)
}
func (m *CheckResourceStateRsp) XXX_Size() int {
	return m.Size()
}
func (m *CheckResourceStateRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckResourceStateRsp.DiscardUnknown(m)
}

var xxx_messageInfo_CheckResourceStateRsp proto.InternalMessageInfo

func (m *CheckResourceStateRsp) GetRemoved() []uint64 {
	if m != nil {
		return m.Removed
	}
	return nil
}

// PutPlacementRuleReq put placement rule req
type PutPlacementRuleReq struct {
	Rule                 PlacementRule `protobuf:"bytes,1,opt,name=rule,proto3" json:"rule"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *PutPlacementRuleReq) Reset()         { *m = PutPlacementRuleReq{} }
func (m *PutPlacementRuleReq) String() string { return proto.CompactTextString(m) }
func (*PutPlacementRuleReq) ProtoMessage()    {}
func (*PutPlacementRuleReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{24}
}
func (m *PutPlacementRuleReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutPlacementRuleReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutPlacementRuleReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutPlacementRuleReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutPlacementRuleReq.Merge(m, src)
}
func (m *PutPlacementRuleReq) XXX_Size() int {
	return m.Size()
}
func (m *PutPlacementRuleReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PutPlacementRuleReq.DiscardUnknown(m)
}

var xxx_messageInfo_PutPlacementRuleReq proto.InternalMessageInfo

func (m *PutPlacementRuleReq) GetRule() PlacementRule {
	if m != nil {
		return m.Rule
	}
	return PlacementRule{}
}

// PutPlacementRuleRsp put placement rule rsp
type PutPlacementRuleRsp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PutPlacementRuleRsp) Reset()         { *m = PutPlacementRuleRsp{} }
func (m *PutPlacementRuleRsp) String() string { return proto.CompactTextString(m) }
func (*PutPlacementRuleRsp) ProtoMessage()    {}
func (*PutPlacementRuleRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{25}
}
func (m *PutPlacementRuleRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutPlacementRuleRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutPlacementRuleRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutPlacementRuleRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutPlacementRuleRsp.Merge(m, src)
}
func (m *PutPlacementRuleRsp) XXX_Size() int {
	return m.Size()
}
func (m *PutPlacementRuleRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_PutPlacementRuleRsp.DiscardUnknown(m)
}

var xxx_messageInfo_PutPlacementRuleRsp proto.InternalMessageInfo

// GetAppliedRulesReq get applied rules req
type GetAppliedRulesReq struct {
	ResourceID           uint64   `protobuf:"varint,1,opt,name=resourceID,proto3" json:"resourceID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetAppliedRulesReq) Reset()         { *m = GetAppliedRulesReq{} }
func (m *GetAppliedRulesReq) String() string { return proto.CompactTextString(m) }
func (*GetAppliedRulesReq) ProtoMessage()    {}
func (*GetAppliedRulesReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{26}
}
func (m *GetAppliedRulesReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAppliedRulesReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAppliedRulesReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAppliedRulesReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAppliedRulesReq.Merge(m, src)
}
func (m *GetAppliedRulesReq) XXX_Size() int {
	return m.Size()
}
func (m *GetAppliedRulesReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAppliedRulesReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetAppliedRulesReq proto.InternalMessageInfo

func (m *GetAppliedRulesReq) GetResourceID() uint64 {
	if m != nil {
		return m.ResourceID
	}
	return 0
}

// GetAppliedRulesRsp get applied rules rsp
type GetAppliedRulesRsp struct {
	Rules                []PlacementRule `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetAppliedRulesRsp) Reset()         { *m = GetAppliedRulesRsp{} }
func (m *GetAppliedRulesRsp) String() string { return proto.CompactTextString(m) }
func (*GetAppliedRulesRsp) ProtoMessage()    {}
func (*GetAppliedRulesRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{27}
}
func (m *GetAppliedRulesRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAppliedRulesRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAppliedRulesRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAppliedRulesRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAppliedRulesRsp.Merge(m, src)
}
func (m *GetAppliedRulesRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetAppliedRulesRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAppliedRulesRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetAppliedRulesRsp proto.InternalMessageInfo

func (m *GetAppliedRulesRsp) GetRules() []PlacementRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// CreateJobReq create job req
type CreateJobReq struct {
	Job                  metapb.Job `protobuf:"bytes,1,opt,name=job,proto3" json:"job"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *CreateJobReq) Reset()         { *m = CreateJobReq{} }
func (m *CreateJobReq) String() string { return proto.CompactTextString(m) }
func (*CreateJobReq) ProtoMessage()    {}
func (*CreateJobReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{28}
}
func (m *CreateJobReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateJobReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateJobReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateJobReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateJobReq.Merge(m, src)
}
func (m *CreateJobReq) XXX_Size() int {
	return m.Size()
}
func (m *CreateJobReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateJobReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreateJobReq proto.InternalMessageInfo

func (m *CreateJobReq) GetJob() metapb.Job {
	if m != nil {
		return m.Job
	}
	return metapb.Job{}
}

// CreateJobRsp create job rsp
type CreateJobRsp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateJobRsp) Reset()         { *m = CreateJobRsp{} }
func (m *CreateJobRsp) String() string { return proto.CompactTextString(m) }
func (*CreateJobRsp) ProtoMessage()    {}
func (*CreateJobRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{29}
}
func (m *CreateJobRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateJobRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateJobRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateJobRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateJobRsp.Merge(m, src)
}
func (m *CreateJobRsp) XXX_Size() int {
	return m.Size()
}
func (m *CreateJobRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateJobRsp.DiscardUnknown(m)
}

var xxx_messageInfo_CreateJobRsp proto.InternalMessageInfo

// RemoveJobReq Remove job req
type RemoveJobReq struct {
	Job                  metapb.Job `protobuf:"bytes,1,opt,name=job,proto3" json:"job"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RemoveJobReq) Reset()         { *m = RemoveJobReq{} }
func (m *RemoveJobReq) String() string { return proto.CompactTextString(m) }
func (*RemoveJobReq) ProtoMessage()    {}
func (*RemoveJobReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{30}
}
func (m *RemoveJobReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveJobReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveJobReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveJobReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveJobReq.Merge(m, src)
}
func (m *RemoveJobReq) XXX_Size() int {
	return m.Size()
}
func (m *RemoveJobReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveJobReq.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveJobReq proto.InternalMessageInfo

func (m *RemoveJobReq) GetJob() metapb.Job {
	if m != nil {
		return m.Job
	}
	return metapb.Job{}
}

// RemoveJobRsp Remove job rsp
type RemoveJobRsp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoveJobRsp) Reset()         { *m = RemoveJobRsp{} }
func (m *RemoveJobRsp) String() string { return proto.CompactTextString(m) }
func (*RemoveJobRsp) ProtoMessage()    {}
func (*RemoveJobRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{31}
}
func (m *RemoveJobRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveJobRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveJobRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveJobRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveJobRsp.Merge(m, src)
}
func (m *RemoveJobRsp) XXX_Size() int {
	return m.Size()
}
func (m *RemoveJobRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveJobRsp.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveJobRsp proto.InternalMessageInfo

// ExecuteJobReq execute on job request
type ExecuteJobReq struct {
	Job                  metapb.Job `protobuf:"bytes,1,opt,name=job,proto3" json:"job"`
	Data                 []byte     `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ExecuteJobReq) Reset()         { *m = ExecuteJobReq{} }
func (m *ExecuteJobReq) String() string { return proto.CompactTextString(m) }
func (*ExecuteJobReq) ProtoMessage()    {}
func (*ExecuteJobReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{32}
}
func (m *ExecuteJobReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteJobReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteJobReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteJobReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteJobReq.Merge(m, src)
}
func (m *ExecuteJobReq) XXX_Size() int {
	return m.Size()
}
func (m *ExecuteJobReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteJobReq.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteJobReq proto.InternalMessageInfo

func (m *ExecuteJobReq) GetJob() metapb.Job {
	if m != nil {
		return m.Job
	}
	return metapb.Job{}
}

func (m *ExecuteJobReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// ExecuteJobRsp execute on job response
type ExecuteJobRsp struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExecuteJobRsp) Reset()         { *m = ExecuteJobRsp{} }
func (m *ExecuteJobRsp) String() string { return proto.CompactTextString(m) }
func (*ExecuteJobRsp) ProtoMessage()    {}
func (*ExecuteJobRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{33}
}
func (m *ExecuteJobRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteJobRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteJobRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteJobRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteJobRsp.Merge(m, src)
}
func (m *ExecuteJobRsp) XXX_Size() int {
	return m.Size()
}
func (m *ExecuteJobRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteJobRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteJobRsp proto.InternalMessageInfo

func (m *ExecuteJobRsp) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// EventNotify event notify
type EventNotify struct {
	Seq                  uint64                 `protobuf:"varint,1,opt,name=seq,proto3" json:"seq,omitempty"`
	Type                 uint32                 `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	InitEvent            *InitEventData         `protobuf:"bytes,3,opt,name=initEvent,proto3" json:"initEvent,omitempty"`
	ResourceEvent        *ResourceEventData     `protobuf:"bytes,4,opt,name=resourceEvent,proto3" json:"resourceEvent,omitempty"`
	ContainerEvent       *ContainerEventData    `protobuf:"bytes,5,opt,name=containerEvent,proto3" json:"containerEvent,omitempty"`
	ResourceStatsEvent   *metapb.ResourceStats  `protobuf:"bytes,6,opt,name=resourceStatsEvent,proto3" json:"resourceStatsEvent,omitempty"`
	ContainerStatsEvent  *metapb.ContainerStats `protobuf:"bytes,7,opt,name=containerStatsEvent,proto3" json:"containerStatsEvent,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *EventNotify) Reset()         { *m = EventNotify{} }
func (m *EventNotify) String() string { return proto.CompactTextString(m) }
func (*EventNotify) ProtoMessage()    {}
func (*EventNotify) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{34}
}
func (m *EventNotify) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventNotify) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventNotify.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventNotify) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventNotify.Merge(m, src)
}
func (m *EventNotify) XXX_Size() int {
	return m.Size()
}
func (m *EventNotify) XXX_DiscardUnknown() {
	xxx_messageInfo_EventNotify.DiscardUnknown(m)
}

var xxx_messageInfo_EventNotify proto.InternalMessageInfo

func (m *EventNotify) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *EventNotify) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *EventNotify) GetInitEvent() *InitEventData {
	if m != nil {
		return m.InitEvent
	}
	return nil
}

func (m *EventNotify) GetResourceEvent() *ResourceEventData {
	if m != nil {
		return m.ResourceEvent
	}
	return nil
}

func (m *EventNotify) GetContainerEvent() *ContainerEventData {
	if m != nil {
		return m.ContainerEvent
	}
	return nil
}

func (m *EventNotify) GetResourceStatsEvent() *metapb.ResourceStats {
	if m != nil {
		return m.ResourceStatsEvent
	}
	return nil
}

func (m *EventNotify) GetContainerStatsEvent() *metapb.ContainerStats {
	if m != nil {
		return m.ContainerStatsEvent
	}
	return nil
}

// InitEventData init event data
type InitEventData struct {
	Resources            [][]byte `protobuf:"bytes,1,rep,name=resources,proto3" json:"resources,omitempty"`
	Leaders              []uint64 `protobuf:"varint,2,rep,packed,name=leaders,proto3" json:"leaders,omitempty"`
	Containers           [][]byte `protobuf:"bytes,3,rep,name=containers,proto3" json:"containers,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InitEventData) Reset()         { *m = InitEventData{} }
func (m *InitEventData) String() string { return proto.CompactTextString(m) }
func (*InitEventData) ProtoMessage()    {}
func (*InitEventData) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{35}
}
func (m *InitEventData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InitEventData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InitEventData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InitEventData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitEventData.Merge(m, src)
}
func (m *InitEventData) XXX_Size() int {
	return m.Size()
}
func (m *InitEventData) XXX_DiscardUnknown() {
	xxx_messageInfo_InitEventData.DiscardUnknown(m)
}

var xxx_messageInfo_InitEventData proto.InternalMessageInfo

func (m *InitEventData) GetResources() [][]byte {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *InitEventData) GetLeaders() []uint64 {
	if m != nil {
		return m.Leaders
	}
	return nil
}

func (m *InitEventData) GetContainers() [][]byte {
	if m != nil {
		return m.Containers
	}
	return nil
}

// ResourceEventData resource created or updated
type ResourceEventData struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Leader               uint64   `protobuf:"varint,2,opt,name=leader,proto3" json:"leader,omitempty"`
	Removed              bool     `protobuf:"varint,3,opt,name=removed,proto3" json:"removed,omitempty"`
	Create               bool     `protobuf:"varint,4,opt,name=create,proto3" json:"create,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResourceEventData) Reset()         { *m = ResourceEventData{} }
func (m *ResourceEventData) String() string { return proto.CompactTextString(m) }
func (*ResourceEventData) ProtoMessage()    {}
func (*ResourceEventData) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{36}
}
func (m *ResourceEventData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceEventData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceEventData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceEventData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceEventData.Merge(m, src)
}
func (m *ResourceEventData) XXX_Size() int {
	return m.Size()
}
func (m *ResourceEventData) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceEventData.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceEventData proto.InternalMessageInfo

func (m *ResourceEventData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ResourceEventData) GetLeader() uint64 {
	if m != nil {
		return m.Leader
	}
	return 0
}

func (m *ResourceEventData) GetRemoved() bool {
	if m != nil {
		return m.Removed
	}
	return false
}

func (m *ResourceEventData) GetCreate() bool {
	if m != nil {
		return m.Create
	}
	return false
}

// ContainerEventData container created or updated
type ContainerEventData struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ContainerEventData) Reset()         { *m = ContainerEventData{} }
func (m *ContainerEventData) String() string { return proto.CompactTextString(m) }
func (*ContainerEventData) ProtoMessage()    {}
func (*ContainerEventData) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{37}
}
func (m *ContainerEventData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerEventData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerEventData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerEventData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerEventData.Merge(m, src)
}
func (m *ContainerEventData) XXX_Size() int {
	return m.Size()
}
func (m *ContainerEventData) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerEventData.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerEventData proto.InternalMessageInfo

func (m *ContainerEventData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// ChangePeer change peer
type ConfigChange struct {
	Replica              metapb.Replica          `protobuf:"bytes,1,opt,name=replica,proto3" json:"replica"`
	ChangeType           metapb.ConfigChangeType `protobuf:"varint,2,opt,name=changeType,proto3,enum=metapb.ConfigChangeType" json:"changeType,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *ConfigChange) Reset()         { *m = ConfigChange{} }
func (m *ConfigChange) String() string { return proto.CompactTextString(m) }
func (*ConfigChange) ProtoMessage()    {}
func (*ConfigChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{38}
}
func (m *ConfigChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigChange.Merge(m, src)
}
func (m *ConfigChange) XXX_Size() int {
	return m.Size()
}
func (m *ConfigChange) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigChange.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigChange proto.InternalMessageInfo

func (m *ConfigChange) GetReplica() metapb.Replica {
	if m != nil {
		return m.Replica
	}
	return metapb.Replica{}
}

func (m *ConfigChange) GetChangeType() metapb.ConfigChangeType {
	if m != nil {
		return m.ChangeType
	}
	return metapb.ConfigChangeType_AddNode
}

// TransferLeader transfer leader
type TransferLeader struct {
	Replica              metapb.Replica `protobuf:"bytes,1,opt,name=replica,proto3" json:"replica"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TransferLeader) Reset()         { *m = TransferLeader{} }
func (m *TransferLeader) String() string { return proto.CompactTextString(m) }
func (*TransferLeader) ProtoMessage()    {}
func (*TransferLeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{39}
}
func (m *TransferLeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferLeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferLeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferLeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferLeader.Merge(m, src)
}
func (m *TransferLeader) XXX_Size() int {
	return m.Size()
}
func (m *TransferLeader) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferLeader.DiscardUnknown(m)
}

var xxx_messageInfo_TransferLeader proto.InternalMessageInfo

func (m *TransferLeader) GetReplica() metapb.Replica {
	if m != nil {
		return m.Replica
	}
	return metapb.Replica{}
}

// ConfigChangeV2 change peer v2
type ConfigChangeV2 struct {
	// If changes is empty, it means that to exit joint state.
	Changes              []ConfigChange `protobuf:"bytes,1,rep,name=changes,proto3" json:"changes"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ConfigChangeV2) Reset()         { *m = ConfigChangeV2{} }
func (m *ConfigChangeV2) String() string { return proto.CompactTextString(m) }
func (*ConfigChangeV2) ProtoMessage()    {}
func (*ConfigChangeV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{40}
}
func (m *ConfigChangeV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigChangeV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigChangeV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigChangeV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigChangeV2.Merge(m, src)
}
func (m *ConfigChangeV2) XXX_Size() int {
	return m.Size()
}
func (m *ConfigChangeV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigChangeV2.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigChangeV2 proto.InternalMessageInfo

func (m *ConfigChangeV2) GetChanges() []ConfigChange {
	if m != nil {
		return m.Changes
	}
	return nil
}

// Merge merge
type Merge struct {
	// target resource
	Target               []byte   `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Merge) Reset()         { *m = Merge{} }
func (m *Merge) String() string { return proto.CompactTextString(m) }
func (*Merge) ProtoMessage()    {}
func (*Merge) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{41}
}
func (m *Merge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Merge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Merge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Merge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Merge.Merge(m, src)
}
func (m *Merge) XXX_Size() int {
	return m.Size()
}
func (m *Merge) XXX_DiscardUnknown() {
	xxx_messageInfo_Merge.DiscardUnknown(m)
}

var xxx_messageInfo_Merge proto.InternalMessageInfo

func (m *Merge) GetTarget() []byte {
	if m != nil {
		return m.Target
	}
	return nil
}

// SplitResource split resource
type SplitResource struct {
	Policy               metapb.CheckPolicy `protobuf:"varint,1,opt,name=policy,proto3,enum=metapb.CheckPolicy" json:"policy,omitempty"`
	Keys                 [][]byte           `protobuf:"bytes,2,rep,name=keys,proto3" json:"keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *SplitResource) Reset()         { *m = SplitResource{} }
func (m *SplitResource) String() string { return proto.CompactTextString(m) }
func (*SplitResource) ProtoMessage()    {}
func (*SplitResource) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{42}
}
func (m *SplitResource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitResource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitResource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitResource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitResource.Merge(m, src)
}
func (m *SplitResource) XXX_Size() int {
	return m.Size()
}
func (m *SplitResource) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitResource.DiscardUnknown(m)
}

var xxx_messageInfo_SplitResource proto.InternalMessageInfo

func (m *SplitResource) GetPolicy() metapb.CheckPolicy {
	if m != nil {
		return m.Policy
	}
	return metapb.CheckPolicy_SCAN
}

func (m *SplitResource) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

// LabelConstraint is used to filter container when trying to place peer of a resource.
type LabelConstraint struct {
	Key                  string            `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Op                   LabelConstraintOp `protobuf:"varint,2,opt,name=op,proto3,enum=rpcpb.LabelConstraintOp" json:"op,omitempty"`
	Values               []string          `protobuf:"bytes,3,rep,name=values,proto3" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *LabelConstraint) Reset()         { *m = LabelConstraint{} }
func (m *LabelConstraint) String() string { return proto.CompactTextString(m) }
func (*LabelConstraint) ProtoMessage()    {}
func (*LabelConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{43}
}
func (m *LabelConstraint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LabelConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LabelConstraint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LabelConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LabelConstraint.Merge(m, src)
}
func (m *LabelConstraint) XXX_Size() int {
	return m.Size()
}
func (m *LabelConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_LabelConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_LabelConstraint proto.InternalMessageInfo

func (m *LabelConstraint) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *LabelConstraint) GetOp() LabelConstraintOp {
	if m != nil {
		return m.Op
	}
	return In
}

func (m *LabelConstraint) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

// PlacementRule place rule
type PlacementRule struct {
	// ID unique ID within a group
	ID string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// GroupID mark the source that add the rule
	GroupID string `protobuf:"bytes,2,opt,name=groupID,proto3" json:"groupID,omitempty"`
	// Index rule apply order in a group, rule with less ID is applied first when indexes are equal
	Index uint32 `protobuf:"varint,3,opt,name=index,proto3" json:"index,omitempty"`
	// Override when it is true, all rules with less indexes are disabled
	Override bool   `protobuf:"varint,4,opt,name=override,proto3" json:"override,omitempty"`
	StartKey []byte `protobuf:"bytes,5,opt,name=startKey,proto3" json:"startKey,omitempty"`
	EndKey   []byte `protobuf:"bytes,6,opt,name=endKey,proto3" json:"endKey,omitempty"`
	// Role expected role of the peers
	Role ReplicaRoleType `protobuf:"varint,7,opt,name=role,proto3,enum=rpcpb.ReplicaRoleType" json:"role,omitempty"`
	// Count expected count of the peers
	Count uint32 `protobuf:"varint,8,opt,name=count,proto3" json:"count,omitempty"`
	// LabelConstraints used to select containers to place peers
	LabelConstraints []LabelConstraint `protobuf:"bytes,9,rep,name=labelConstraints,proto3" json:"labelConstraints"`
	// LocationLabels used to make peers isolated physically
	LocationLabels []string `protobuf:"bytes,10,rep,name=locationLabels,proto3" json:"locationLabels,omitempty"`
	// IsolationLevelused to isolate replicas explicitly and forcibly
	IsolationLevel       string   `protobuf:"bytes,11,opt,name=isolationLevel,proto3" json:"isolationLevel,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlacementRule) Reset()         { *m = PlacementRule{} }
func (m *PlacementRule) String() string { return proto.CompactTextString(m) }
func (*PlacementRule) ProtoMessage()    {}
func (*PlacementRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{44}
}
func (m *PlacementRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlacementRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlacementRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlacementRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlacementRule.Merge(m, src)
}
func (m *PlacementRule) XXX_Size() int {
	return m.Size()
}
func (m *PlacementRule) XXX_DiscardUnknown() {
	xxx_messageInfo_PlacementRule.DiscardUnknown(m)
}

var xxx_messageInfo_PlacementRule proto.InternalMessageInfo

func (m *PlacementRule) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *PlacementRule) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

func (m *PlacementRule) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *PlacementRule) GetOverride() bool {
	if m != nil {
		return m.Override
	}
	return false
}

func (m *PlacementRule) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *PlacementRule) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *PlacementRule) GetRole() ReplicaRoleType {
	if m != nil {
		return m.Role
	}
	return Voter
}

func (m *PlacementRule) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *PlacementRule) GetLabelConstraints() []LabelConstraint {
	if m != nil {
		return m.LabelConstraints
	}
	return nil
}

func (m *PlacementRule) GetLocationLabels() []string {
	if m != nil {
		return m.LocationLabels
	}
	return nil
}

func (m *PlacementRule) GetIsolationLevel() string {
	if m != nil {
		return m.IsolationLevel
	}
	return ""
}

func init() {
	proto.RegisterEnum("rpcpb.Type", Type_name, Type_value)
	proto.RegisterEnum("rpcpb.ReplicaRoleType", ReplicaRoleType_name, ReplicaRoleType_value)
	proto.RegisterEnum("rpcpb.LabelConstraintOp", LabelConstraintOp_name, LabelConstraintOp_value)
	proto.RegisterType((*Request)(nil), "rpcpb.Request")
	proto.RegisterType((*Response)(nil), "rpcpb.Response")
	proto.RegisterType((*ResourceHeartbeatReq)(nil), "rpcpb.ResourceHeartbeatReq")
	proto.RegisterType((*ResourceHeartbeatRsp)(nil), "rpcpb.ResourceHeartbeatRsp")
	proto.RegisterType((*PutContainerReq)(nil), "rpcpb.PutContainerReq")
	proto.RegisterType((*PutContainerRsp)(nil), "rpcpb.PutContainerRsp")
	proto.RegisterType((*ContainerHeartbeatReq)(nil), "rpcpb.ContainerHeartbeatReq")
	proto.RegisterType((*ContainerHeartbeatRsp)(nil), "rpcpb.ContainerHeartbeatRsp")
	proto.RegisterType((*GetContainerReq)(nil), "rpcpb.GetContainerReq")
	proto.RegisterType((*GetContainerRsp)(nil), "rpcpb.GetContainerRsp")
	proto.RegisterType((*AllocIDReq)(nil), "rpcpb.AllocIDReq")
	proto.RegisterType((*AllocIDRsp)(nil), "rpcpb.AllocIDRsp")
	proto.RegisterType((*AskBatchSplitReq)(nil), "rpcpb.AskBatchSplitReq")
	proto.RegisterType((*AskBatchSplitRsp)(nil), "rpcpb.AskBatchSplitRsp")
	proto.RegisterType((*BatchReportSplitReq)(nil), "rpcpb.BatchReportSplitReq")
	proto.RegisterType((*BatchReportSplitRsp)(nil), "rpcpb.BatchReportSplitRsp")
	proto.RegisterType((*SplitID)(nil), "rpcpb.SplitID")
	proto.RegisterType((*CreateWatcherReq)(nil), "rpcpb.CreateWatcherReq")
	proto.RegisterType((*CreateResourcesReq)(nil), "rpcpb.CreateResourcesReq")
	proto.RegisterType((*CreateResourcesRsp)(nil), "rpcpb.CreateResourcesRsp")
	proto.RegisterType((*RemoveResourcesReq)(nil), "rpcpb.RemoveResourcesReq")
	proto.RegisterType((*RemoveResourcesRsp)(nil), "rpcpb.RemoveResourcesRsp")
	proto.RegisterType((*CheckResourceStateReq)(nil), "rpcpb.CheckResourceStateReq")
	proto.RegisterType((*CheckResourceStateRsp)(nil), "rpcpb.CheckResourceStateRsp")
	proto.RegisterType((*PutPlacementRuleReq)(nil), "rpcpb.PutPlacementRuleReq")
	proto.RegisterType((*PutPlacementRuleRsp)(nil), "rpcpb.PutPlacementRuleRsp")
	proto.RegisterType((*GetAppliedRulesReq)(nil), "rpcpb.GetAppliedRulesReq")
	proto.RegisterType((*GetAppliedRulesRsp)(nil), "rpcpb.GetAppliedRulesRsp")
	proto.RegisterType((*CreateJobReq)(nil), "rpcpb.CreateJobReq")
	proto.RegisterType((*CreateJobRsp)(nil), "rpcpb.CreateJobRsp")
	proto.RegisterType((*RemoveJobReq)(nil), "rpcpb.RemoveJobReq")
	proto.RegisterType((*RemoveJobRsp)(nil), "rpcpb.RemoveJobRsp")
	proto.RegisterType((*ExecuteJobReq)(nil), "rpcpb.ExecuteJobReq")
	proto.RegisterType((*ExecuteJobRsp)(nil), "rpcpb.ExecuteJobRsp")
	proto.RegisterType((*EventNotify)(nil), "rpcpb.EventNotify")
	proto.RegisterType((*InitEventData)(nil), "rpcpb.InitEventData")
	proto.RegisterType((*ResourceEventData)(nil), "rpcpb.ResourceEventData")
	proto.RegisterType((*ContainerEventData)(nil), "rpcpb.ContainerEventData")
	proto.RegisterType((*ConfigChange)(nil), "rpcpb.ConfigChange")
	proto.RegisterType((*TransferLeader)(nil), "rpcpb.TransferLeader")
	proto.RegisterType((*ConfigChangeV2)(nil), "rpcpb.ConfigChangeV2")
	proto.RegisterType((*Merge)(nil), "rpcpb.Merge")
	proto.RegisterType((*SplitResource)(nil), "rpcpb.SplitResource")
	proto.RegisterType((*LabelConstraint)(nil), "rpcpb.LabelConstraint")
	proto.RegisterType((*PlacementRule)(nil), "rpcpb.PlacementRule")
}

func init() { proto.RegisterFile("rpcpb.proto", fileDescriptor_25e491924c678914) }

var fileDescriptor_25e491924c678914 = []byte{
	// 2258 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x59, 0x4b, 0x73, 0x1c, 0xb7,
	0x11, 0xd6, 0xbe, 0xb9, 0xcd, 0x7d, 0x80, 0x58, 0x92, 0x1a, 0x51, 0x32, 0xc9, 0x8c, 0x54, 0x0e,
	0x23, 0x27, 0x64, 0x44, 0x25, 0xe5, 0x94, 0x2b, 0x71, 0xc2, 0x97, 0x2d, 0x2a, 0x8a, 0xac, 0x82,
	0x5c, 0x4a, 0x6e, 0xa9, 0xd9, 0x5d, 0x68, 0x39, 0xd1, 0x70, 0x00, 0x0d, 0xb0, 0x92, 0x78, 0xce,
	0x2f, 0xcb, 0x21, 0x55, 0xce, 0xcd, 0xbf, 0x40, 0x95, 0xe8, 0x98, 0x5b, 0xce, 0xb9, 0xb8, 0xf0,
	0x98, 0xf7, 0xec, 0x8a, 0x3e, 0x71, 0xd1, 0xdd, 0xdf, 0x37, 0x40, 0x0f, 0xf0, 0xa1, 0x7b, 0x08,
	0xab, 0x11, 0x9f, 0xf0, 0xf1, 0x3e, 0x8f, 0x98, 0x64, 0xb8, 0xa5, 0x07, 0x5b, 0x4f, 0x66, 0xbe,
	0xbc, 0x98, 0x8f, 0xf7, 0x27, 0xec, 0xf2, 0xe0, 0xd2, 0x93, 0x91, 0xff, 0x8e, 0x45, 0xfe, 0xcc,
	0x0f, 0xed, 0x60, 0x32, 0x1f, 0xd3, 0x83, 0x09, 0xbb, 0xe4, 0x2c, 0xa4, 0xa1, 0x14, 0x07, 0x3c,
	0x62, 0xfc, 0x82, 0xca, 0x03, 0x3e, 0x3e, 0xb8, 0xa4, 0xd2, 0x4b, 0xfe, 0x18, 0xd2, 0xad, 0x5f,
	0x64, 0xd8, 0x66, 0x6c, 0xc6, 0x0e, 0xb4, 0x79, 0x3c, 0x7f, 0xa9, 0x47, 0x7a, 0xa0, 0x7f, 0x99,
	0x70, 0xf7, 0x5f, 0x5d, 0xe8, 0x10, 0xfa, 0x7a, 0x4e, 0x85, 0xc4, 0x9b, 0x50, 0xf7, 0xa7, 0x4e,
	0x6d, 0xb7, 0xb6, 0xd7, 0x3c, 0x6e, 0x7f, 0x78, 0xbf, 0x53, 0x3f, 0x3f, 0x25, 0x75, 0x7f, 0x8a,
	0x77, 0x61, 0x75, 0xc2, 0x42, 0xe9, 0xf9, 0x21, 0x8d, 0xce, 0x4f, 0x9d, 0xba, 0x0a, 0x20, 0x59,
	0x13, 0xde, 0x81, 0xa6, 0xbc, 0xe2, 0xd4, 0x69, 0xec, 0xd6, 0xf6, 0x06, 0x87, 0xab, 0xfb, 0x66,
	0x95, 0xdf, 0x5e, 0x71, 0x4a, 0xb4, 0x03, 0x7f, 0x03, 0x6b, 0x11, 0x15, 0x6c, 0x1e, 0x4d, 0xe8,
	0x23, 0xea, 0x45, 0x72, 0x4c, 0x3d, 0xe9, 0x34, 0x77, 0x6b, 0x7b, 0xab, 0x87, 0xb7, 0x6d, 0x34,
	0x29, 0xfa, 0x09, 0x7d, 0x7d, 0xdc, 0xfc, 0xee, 0xfd, 0xce, 0x0d, 0x52, 0xc6, 0x62, 0x02, 0x38,
	0x99, 0x40, 0xca, 0xd8, 0xd2, 0x8c, 0x77, 0x2c, 0xe3, 0x49, 0x29, 0x20, 0xa5, 0xac, 0x40, 0xe3,
	0x3f, 0x40, 0x8f, 0xcf, 0x65, 0x82, 0x72, 0xda, 0x9a, 0x6d, 0xd3, 0xb2, 0x3d, 0xcb, 0xb8, 0x52,
	0x9e, 0x1c, 0x42, 0x31, 0xcc, 0x68, 0x86, 0xa1, 0x93, 0x63, 0xf8, 0x9a, 0x56, 0x32, 0x64, 0x11,
	0xf8, 0x01, 0x74, 0xbc, 0x20, 0x60, 0x93, 0xf3, 0x53, 0x67, 0x45, 0x83, 0xd7, 0x2c, 0xf8, 0xc8,
	0x58, 0x53, 0x5c, 0x1c, 0x87, 0x4f, 0xa0, 0xef, 0x89, 0x57, 0xc7, 0x9e, 0x9c, 0x5c, 0x3c, 0xe7,
	0x81, 0x2f, 0x1d, 0xd0, 0xc0, 0x9b, 0x31, 0x30, 0xeb, 0x4b, 0xe1, 0x79, 0x0c, 0x7e, 0x02, 0x68,
	0xac, 0x46, 0x84, 0x72, 0x16, 0x49, 0xc3, 0xd3, 0xd3, 0x3c, 0x5b, 0x96, 0xe7, 0xb8, 0xe0, 0x4e,
	0xa9, 0x4a, 0x48, 0x35, 0xa5, 0x49, 0x44, 0x3d, 0x49, 0xff, 0xac, 0x3c, 0x34, 0x72, 0xfa, 0xb9,
	0x29, 0x9d, 0x64, 0x7d, 0x99, 0x29, 0xe5, 0x30, 0xf8, 0x1c, 0x86, 0xc6, 0x10, 0xef, 0x0c, 0xe1,
	0x0c, 0x34, 0xcd, 0xad, 0x1c, 0x4d, 0xe2, 0x4d, 0x89, 0x8a, 0x38, 0x45, 0x15, 0xd1, 0x4b, 0xf6,
	0x26, 0x43, 0x35, 0xcc, 0x51, 0x91, 0xbc, 0x37, 0x43, 0x55, 0xc0, 0xe9, 0x8d, 0x77, 0x41, 0x27,
	0xaf, 0x62, 0xcb, 0x73, 0xe9, 0x49, 0xea, 0xa0, 0xfc, 0xc6, 0x2b, 0x05, 0x64, 0x37, 0x5e, 0xc9,
	0xa9, 0x92, 0xcf, 0xe7, 0xf2, 0x59, 0xe0, 0x4d, 0xe8, 0x25, 0x0d, 0x25, 0x99, 0x07, 0xd4, 0x59,
	0xcb, 0x25, 0xff, 0x59, 0xc1, 0x9d, 0x49, 0x7e, 0x11, 0xa9, 0x16, 0x3b, 0xa3, 0xf2, 0x88, 0xf3,
	0xc0, 0xa7, 0x53, 0x65, 0x11, 0x0e, 0xce, 0x2d, 0xf6, 0xeb, 0xbc, 0x37, 0xb3, 0xd8, 0x02, 0x0e,
	0x7f, 0x0e, 0x5d, 0x93, 0xca, 0xc7, 0x6c, 0xec, 0x8c, 0x34, 0xc9, 0x28, 0x97, 0xfc, 0xc7, 0x6c,
	0x9c, 0xc2, 0xd3, 0x58, 0x05, 0x34, 0x89, 0x53, 0xc0, 0xf5, 0x1c, 0x90, 0xc4, 0xf6, 0x0c, 0x30,
	0x89, 0xc5, 0x5f, 0x00, 0xd0, 0x77, 0x74, 0x32, 0x37, 0x8f, 0xdc, 0xd0, 0xc8, 0x75, 0x8b, 0x3c,
	0x4b, 0x1c, 0x29, 0x34, 0x13, 0xed, 0xfe, 0xa3, 0x0b, 0x2b, 0x84, 0x0a, 0xce, 0x42, 0x41, 0x17,
	0x8a, 0x59, 0x2c, 0x55, 0xf5, 0x45, 0x52, 0xb5, 0x0e, 0x2d, 0x1a, 0x45, 0x2c, 0xd2, 0x62, 0xd6,
	0x25, 0x66, 0x80, 0x37, 0xa1, 0x1d, 0x50, 0x6f, 0x4a, 0x23, 0xad, 0x5a, 0x5d, 0x62, 0x47, 0xd5,
	0xc2, 0xd6, 0xfa, 0x88, 0xb0, 0x09, 0xfe, 0x63, 0x85, 0xad, 0xfd, 0x31, 0x61, 0x4b, 0x28, 0xaf,
	0x23, 0x6c, 0x9d, 0xc5, 0xc2, 0x96, 0xf0, 0x2c, 0x17, 0xb6, 0x95, 0xc5, 0xc2, 0x96, 0x32, 0x2c,
	0x12, 0xb6, 0x6e, 0xa5, 0xb0, 0x25, 0xb8, 0xc5, 0xc2, 0xb6, 0xba, 0x44, 0xd8, 0x12, 0xf8, 0x35,
	0x84, 0xad, 0xbf, 0x5c, 0xd8, 0x12, 0xaa, 0xb2, 0xb0, 0xed, 0x43, 0x8b, 0xbe, 0xa1, 0xa1, 0xb4,
	0x4a, 0x84, 0xe3, 0x9d, 0xa9, 0x6c, 0x4f, 0x99, 0xf4, 0x5f, 0x5e, 0x59, 0xa8, 0x09, 0xab, 0xd2,
	0xb0, 0xe1, 0x52, 0x0d, 0x4b, 0x9e, 0x7d, 0x1d, 0x0d, 0x43, 0x4b, 0x35, 0x2c, 0xa5, 0xba, 0x9e,
	0x86, 0xad, 0x7d, 0x4c, 0xc3, 0x32, 0x7b, 0xec, 0x7a, 0x1a, 0x86, 0x97, 0x6b, 0x58, 0x9a, 0xe7,
	0xeb, 0x68, 0xd8, 0x68, 0xa9, 0x86, 0xa5, 0x8b, 0x5d, 0xaa, 0x61, 0xeb, 0x0b, 0x34, 0x2c, 0x81,
	0x2f, 0xd2, 0xb0, 0x8d, 0x05, 0x1a, 0x96, 0x02, 0x17, 0x69, 0xd8, 0xe6, 0x22, 0x0d, 0x4b, 0xa0,
	0x59, 0x0d, 0xfb, 0x67, 0x1d, 0xd6, 0xab, 0x2a, 0xa1, 0x62, 0x11, 0x56, 0x2b, 0x17, 0x61, 0x5b,
	0xb0, 0x12, 0xcb, 0x89, 0x56, 0xb7, 0x1e, 0x49, 0xc6, 0x18, 0x43, 0x53, 0xd2, 0xe8, 0x52, 0x6b,
	0x5a, 0x93, 0xe8, 0xdf, 0xf8, 0xa7, 0x39, 0x49, 0x5b, 0x3d, 0x1c, 0xee, 0xdb, 0x42, 0x92, 0x50,
	0x1e, 0xf8, 0x13, 0x2f, 0xd1, 0xb8, 0x2f, 0xa1, 0x37, 0x65, 0x6f, 0x43, 0x6b, 0x16, 0x4e, 0x6b,
	0xb7, 0xa1, 0x57, 0x94, 0x0f, 0x57, 0xdb, 0x40, 0xc4, 0x47, 0x3f, 0x1b, 0x8f, 0x7f, 0x0f, 0x43,
	0x4e, 0xc3, 0xa9, 0x1f, 0xce, 0x12, 0x8a, 0xb6, 0xa6, 0x28, 0x3e, 0x31, 0x7e, 0x85, 0x85, 0x68,
	0xfc, 0x00, 0x5a, 0x42, 0xb1, 0x5b, 0xe1, 0xda, 0x48, 0x61, 0xe9, 0x0e, 0x8c, 0x1f, 0x6d, 0x22,
	0xdd, 0xff, 0x35, 0xaa, 0xf2, 0x28, 0x38, 0xde, 0x06, 0x88, 0xb3, 0x92, 0xa4, 0x31, 0x63, 0xc1,
	0x47, 0xd0, 0x8f, 0x47, 0x67, 0x9c, 0x4d, 0x2e, 0x74, 0x2a, 0x2b, 0x9e, 0xa9, 0x9d, 0xb1, 0xe4,
	0xe4, 0x10, 0xf8, 0xd7, 0xd0, 0x97, 0x5e, 0x34, 0xa3, 0xd2, 0x2e, 0x40, 0x67, 0xbd, 0x22, 0xbf,
	0xf9, 0x28, 0xfc, 0x39, 0xf4, 0x26, 0x2c, 0x7c, 0xe9, 0xcf, 0x4e, 0x2e, 0xbc, 0x70, 0x46, 0xed,
	0x5b, 0x19, 0xa5, 0x9a, 0x9f, 0xb8, 0x48, 0x2e, 0x10, 0xff, 0x0e, 0x06, 0x32, 0xf2, 0x42, 0xf1,
	0x92, 0x46, 0x4f, 0xcc, 0x0b, 0x6d, 0xd9, 0x39, 0xdb, 0xcb, 0x2d, 0xe7, 0x24, 0x85, 0x60, 0xec,
	0x42, 0xeb, 0x92, 0x46, 0x33, 0x6a, 0x2f, 0x99, 0x9e, 0x45, 0xfd, 0x49, 0xd9, 0x88, 0x71, 0xe1,
	0x2f, 0xa0, 0x2f, 0x4c, 0xd1, 0x67, 0x37, 0x58, 0x27, 0xb7, 0xab, 0x9f, 0x67, 0x7d, 0x24, 0x1f,
	0xaa, 0xa6, 0x97, 0x9d, 0xee, 0x8b, 0x43, 0x7b, 0x7b, 0x6c, 0x54, 0xac, 0xec, 0xc5, 0x21, 0x29,
	0x04, 0xe3, 0x3d, 0x18, 0x4e, 0xa9, 0x90, 0x2c, 0xba, 0x3a, 0xf5, 0x23, 0x3a, 0x91, 0xc1, 0x95,
	0xbe, 0x40, 0x56, 0x48, 0xd1, 0xec, 0x1e, 0xc0, 0xb0, 0x50, 0xa4, 0xe3, 0x3b, 0xd0, 0x4d, 0x8e,
	0x88, 0x7e, 0xd9, 0x3d, 0x92, 0x1a, 0xdc, 0xb5, 0x02, 0x40, 0x70, 0xf7, 0xaf, 0xb0, 0x51, 0xd9,
	0x36, 0xe0, 0xc3, 0x78, 0x0f, 0xd6, 0xec, 0xd5, 0x67, 0x5f, 0x66, 0x12, 0x5d, 0xde, 0x84, 0xea,
	0xd4, 0x4d, 0x3d, 0xe9, 0xd9, 0xd3, 0xa8, 0x7f, 0xbb, 0x9f, 0x55, 0x3e, 0x40, 0xf0, 0x24, 0xb8,
	0x96, 0x09, 0xfe, 0x19, 0x0c, 0x0b, 0x4d, 0xc3, 0xa2, 0xba, 0xc6, 0x7d, 0x5e, 0x08, 0xad, 0x66,
	0xc4, 0x3f, 0x8f, 0x97, 0x51, 0x5f, 0xb6, 0x8c, 0xf8, 0x14, 0xf5, 0x00, 0xd2, 0xbe, 0xc3, 0xbd,
	0x97, 0x8e, 0x04, 0x5f, 0x38, 0x91, 0xdf, 0x02, 0x2a, 0xb6, 0x1c, 0x95, 0x33, 0x59, 0x87, 0xd6,
	0x84, 0xcd, 0x43, 0xa9, 0x67, 0xd2, 0x27, 0x66, 0xe0, 0x9e, 0x16, 0xd1, 0x82, 0xe3, 0x5f, 0xc2,
	0x8a, 0xde, 0x51, 0xe7, 0xa7, 0x2a, 0xfb, 0x4a, 0x38, 0x06, 0xd9, 0x7d, 0x77, 0x7e, 0x6a, 0xb3,
	0x9e, 0x44, 0xb9, 0x0f, 0x61, 0x54, 0xd1, 0xae, 0xa8, 0xdd, 0x10, 0x25, 0x97, 0xa7, 0x62, 0xea,
	0x91, 0xd4, 0xe0, 0x6e, 0x54, 0x80, 0x04, 0x77, 0xcf, 0xa0, 0x63, 0x1f, 0xa3, 0xa6, 0x1c, 0xd2,
	0xb7, 0x89, 0x6c, 0x98, 0x01, 0xbe, 0x07, 0xfd, 0x90, 0xbe, 0xb5, 0xa7, 0x58, 0xcd, 0xb1, 0xbe,
	0xdb, 0xd8, 0x6b, 0x92, 0xbc, 0xd1, 0xfd, 0x14, 0x50, 0xb1, 0xed, 0x51, 0x69, 0x79, 0x19, 0x78,
	0x33, 0x4d, 0xd7, 0x27, 0xfa, 0xb7, 0xfb, 0x17, 0xc0, 0xe5, 0xbe, 0x66, 0xf9, 0xcc, 0xd5, 0x0c,
	0x02, 0xea, 0x09, 0x99, 0xc8, 0xab, 0x9d, 0x41, 0xce, 0xe8, 0xae, 0x97, 0x99, 0x05, 0x77, 0x0f,
	0x00, 0x97, 0x9b, 0x1f, 0x7c, 0x0b, 0x1a, 0xfe, 0xd4, 0x3c, 0xa9, 0x79, 0xdc, 0xf9, 0xf0, 0x7e,
	0xa7, 0x71, 0x7e, 0x2a, 0x88, 0xb2, 0x29, 0x9a, 0x72, 0xa5, 0xe1, 0x1e, 0xc2, 0x46, 0x65, 0xd7,
	0x93, 0x32, 0xd5, 0xf6, 0x7a, 0x05, 0xa6, 0x07, 0x95, 0x18, 0xc1, 0xb1, 0x03, 0x1d, 0x73, 0x9b,
	0x4e, 0xcd, 0x0c, 0x48, 0x3c, 0x74, 0xcf, 0x60, 0x54, 0xd1, 0x0a, 0xe1, 0x7d, 0x68, 0x46, 0xaa,
	0xe0, 0xa8, 0xe5, 0x54, 0x29, 0x17, 0x66, 0xf7, 0x88, 0x8e, 0x53, 0xaf, 0xba, 0xa2, 0x1a, 0x71,
	0x7f, 0x05, 0xb8, 0xdc, 0x1b, 0x7d, 0xec, 0xc6, 0x70, 0xbf, 0x2a, 0xa3, 0xf4, 0xa6, 0x6d, 0x45,
	0xba, 0x6e, 0xa9, 0xd9, 0xdb, 0x72, 0xf1, 0x9c, 0x4c, 0xa0, 0xfb, 0x10, 0x7a, 0xd9, 0xa6, 0x0a,
	0xdf, 0x85, 0xc6, 0xdf, 0xd8, 0xd8, 0xae, 0x69, 0x35, 0x3e, 0xa8, 0x8f, 0xd9, 0xd8, 0xc2, 0x94,
	0xd7, 0x1d, 0x64, 0x41, 0x82, 0x2b, 0x92, 0x6c, 0x83, 0x75, 0x6d, 0x92, 0x6c, 0x45, 0xe3, 0x3e,
	0x82, 0x7e, 0xae, 0xd7, 0xba, 0x16, 0x4b, 0xa5, 0xda, 0xdd, 0xcd, 0x31, 0x2d, 0x50, 0xb9, 0xff,
	0xd7, 0x61, 0x35, 0x53, 0x41, 0x63, 0x04, 0x0d, 0x41, 0x5f, 0xdb, 0x4c, 0xab, 0x9f, 0xba, 0x7c,
	0x89, 0x9b, 0xb6, 0xbe, 0xed, 0xd3, 0x0e, 0xa1, 0xeb, 0x87, 0xbe, 0xd4, 0x40, 0x7b, 0xc3, 0xc6,
	0x49, 0x3e, 0x8f, 0xed, 0xa7, 0x9e, 0xf4, 0x48, 0x1a, 0x86, 0xbf, 0xcc, 0x5c, 0xee, 0x1a, 0x67,
	0xee, 0x58, 0xa7, 0xd0, 0xa9, 0xa5, 0xd8, 0x7c, 0x38, 0x3e, 0xd2, 0x57, 0x99, 0x11, 0x4a, 0x43,
	0xd0, 0xca, 0x57, 0xf3, 0x39, 0xa7, 0x66, 0x28, 0x00, 0xf0, 0x19, 0xe0, 0x28, 0x5b, 0xb6, 0x18,
	0x9a, 0xf6, 0x92, 0xc2, 0x86, 0x54, 0x00, 0xf0, 0x23, 0x18, 0x4d, 0x72, 0x92, 0x6d, 0x78, 0x3a,
	0x4b, 0x55, 0xbd, 0x0a, 0xe2, 0xce, 0xa0, 0x9f, 0xcb, 0xd7, 0x47, 0xb4, 0xc6, 0x81, 0x8e, 0x29,
	0x0b, 0x63, 0x95, 0x89, 0x87, 0xea, 0x9c, 0x24, 0xfc, 0xc2, 0x69, 0x68, 0x60, 0xc6, 0xe2, 0xbe,
	0x86, 0xb5, 0x52, 0x82, 0x2b, 0x6f, 0x86, 0xb4, 0xd7, 0x36, 0x9f, 0x1a, 0xe3, 0x3a, 0x34, 0x23,
	0x0b, 0x0d, 0x5d, 0x01, 0xc4, 0x43, 0x85, 0x30, 0x75, 0xbb, 0x7e, 0xa1, 0x2b, 0xc4, 0x8e, 0xdc,
	0x3d, 0xc0, 0xe5, 0x57, 0x52, 0xb9, 0x07, 0xaf, 0xa0, 0x97, 0xad, 0x43, 0xf0, 0x81, 0x7a, 0x96,
	0xa9, 0xde, 0x6a, 0x95, 0xd5, 0x5b, 0xdc, 0xac, 0xda, 0x28, 0xfc, 0x1b, 0x80, 0x89, 0x86, 0x7e,
	0x9b, 0x7e, 0x5d, 0x70, 0x32, 0xef, 0x21, 0xa1, 0xd6, 0x9f, 0x1a, 0x32, 0xb1, 0xee, 0x11, 0x0c,
	0xf2, 0x15, 0xda, 0x8f, 0x7e, 0xb8, 0x7b, 0x06, 0x83, 0x7c, 0x15, 0x85, 0x1f, 0x42, 0xc7, 0x3c,
	0x22, 0x16, 0xa0, 0xaa, 0x3a, 0x32, 0xa6, 0xb1, 0x91, 0xee, 0x0e, 0xb4, 0x74, 0xd5, 0xa7, 0xf2,
	0x69, 0x6a, 0x53, 0x9b, 0x23, 0x3b, 0x72, 0x9f, 0x41, 0x3f, 0x57, 0xea, 0xe1, 0xcf, 0xa0, 0xcd,
	0x59, 0xe0, 0x4f, 0xae, 0x74, 0xe0, 0xe0, 0x70, 0x94, 0xac, 0x58, 0x09, 0xfb, 0x33, 0xed, 0x22,
	0x36, 0x44, 0xe5, 0xfd, 0x15, 0xbd, 0x32, 0xfb, 0xa6, 0x47, 0xf4, 0x6f, 0x97, 0xc2, 0xf0, 0x89,
	0x37, 0xa6, 0xc1, 0x09, 0x0b, 0x85, 0x8c, 0x3c, 0x3f, 0x94, 0xea, 0xf8, 0xbf, 0xa2, 0x86, 0xb0,
	0x4b, 0xd4, 0x4f, 0xbc, 0x07, 0x75, 0xc6, 0x93, 0x9c, 0x9a, 0x75, 0x14, 0x50, 0xdf, 0x70, 0x52,
	0x67, 0xaa, 0x28, 0x69, 0xbf, 0xf1, 0x82, 0x39, 0x35, 0xfb, 0xaf, 0x4b, 0xec, 0xc8, 0xfd, 0x7b,
	0x03, 0xfa, 0xf9, 0x0e, 0x33, 0x2d, 0x5f, 0xba, 0xb9, 0xef, 0x43, 0x0e, 0x74, 0x66, 0x11, 0x9b,
	0x73, 0xfb, 0xa1, 0xbb, 0x4b, 0xe2, 0xa1, 0xba, 0xfd, 0xfd, 0x70, 0x4a, 0xdf, 0xe9, 0xcd, 0xd7,
	0x27, 0x66, 0xa0, 0xba, 0x2e, 0xf6, 0x86, 0x46, 0x91, 0x3f, 0x8d, 0x37, 0x5f, 0x32, 0x56, 0x3e,
	0x21, 0xbd, 0x48, 0xfe, 0x91, 0x5e, 0x69, 0xa1, 0xe8, 0x91, 0x64, 0xac, 0x66, 0x4a, 0xc3, 0xa9,
	0xf2, 0xb4, 0x4d, 0x8a, 0xcd, 0x08, 0xdf, 0x87, 0x66, 0xc4, 0x02, 0x53, 0x60, 0x0f, 0x92, 0x2f,
	0x2c, 0x71, 0xcb, 0xc0, 0x02, 0xb3, 0x7f, 0x74, 0x4c, 0x5a, 0x42, 0xad, 0x64, 0x4a, 0x28, 0xfc,
	0x08, 0x50, 0x90, 0x4f, 0x8e, 0x70, 0xba, 0x7a, 0x0f, 0x6c, 0x56, 0xe7, 0x2e, 0xee, 0xc2, 0x8b,
	0x28, 0xfc, 0x29, 0x0c, 0x02, 0x36, 0xf1, 0xa4, 0xcf, 0x42, 0x0d, 0x11, 0x0e, 0xe8, 0xac, 0x16,
	0xac, 0x2a, 0xce, 0x17, 0x2c, 0x30, 0x26, 0xfa, 0x86, 0x06, 0xfa, 0x4b, 0x4d, 0x97, 0x14, 0xac,
	0xf7, 0xff, 0xdb, 0x86, 0xa6, 0x9a, 0x3e, 0xbe, 0x05, 0x1b, 0x7a, 0x19, 0x74, 0xe6, 0x0b, 0x49,
	0xa3, 0xe4, 0x8c, 0xa2, 0x1b, 0xf8, 0x0e, 0x38, 0xc6, 0x55, 0xee, 0x81, 0x51, 0x6d, 0xb1, 0x57,
	0x70, 0x54, 0xc7, 0x9f, 0xc0, 0x2d, 0xe5, 0xad, 0x2c, 0xe0, 0x51, 0x63, 0x89, 0x5b, 0x70, 0xd4,
	0xc4, 0x37, 0x61, 0xa4, 0xdc, 0x85, 0x16, 0x02, 0xb5, 0x2a, 0x1d, 0x82, 0xa3, 0x76, 0xec, 0x28,
	0x94, 0xe8, 0xa8, 0x53, 0xe9, 0x10, 0x1c, 0xad, 0x60, 0x0c, 0x03, 0xe5, 0x48, 0x8b, 0x6a, 0xd4,
	0x2d, 0xda, 0x04, 0x47, 0x80, 0x1d, 0x58, 0xd7, 0xb6, 0x42, 0x21, 0x8d, 0xfa, 0xd5, 0x1e, 0xc1,
	0xd1, 0x00, 0xdf, 0x86, 0x9b, 0xca, 0x53, 0x51, 0xf8, 0xa2, 0xb5, 0x85, 0x4e, 0xc1, 0x11, 0x8e,
	0x39, 0x8b, 0xf5, 0x29, 0x1a, 0xe1, 0x11, 0x0c, 0x95, 0x27, 0x73, 0x3b, 0xa3, 0x75, 0xbc, 0x05,
	0x9b, 0x69, 0x78, 0xb6, 0x6c, 0x44, 0x1b, 0x8b, 0x7c, 0x82, 0xa3, 0xcd, 0xd8, 0x57, 0x2e, 0x37,
	0xd1, 0xcd, 0x45, 0x3e, 0xc1, 0x91, 0x93, 0xbc, 0xb7, 0xaa, 0xfa, 0x12, 0xdd, 0x5a, 0xe2, 0x16,
	0x1c, 0x6d, 0xc5, 0x2b, 0xaf, 0x28, 0x1b, 0xd1, 0xed, 0x85, 0x4e, 0xc1, 0xd1, 0x9d, 0x78, 0x4e,
	0xe5, 0x92, 0x10, 0x7d, 0xb2, 0xc8, 0x27, 0x38, 0xda, 0xc6, 0xeb, 0x80, 0xd2, 0x1c, 0x98, 0x0a,
	0x0a, 0xed, 0x94, 0xad, 0x82, 0xa3, 0xdd, 0xd8, 0x9a, 0xad, 0xd9, 0xd0, 0x4f, 0xca, 0x56, 0xc1,
	0x91, 0x8b, 0x37, 0x60, 0x4d, 0xbf, 0x8c, 0x6c, 0x69, 0x86, 0xee, 0x56, 0x98, 0x05, 0x47, 0xf7,
	0xee, 0x9f, 0xc0, 0xb0, 0xa0, 0x1a, 0xb8, 0x0b, 0xad, 0x17, 0x4c, 0xea, 0x63, 0x06, 0xd0, 0x36,
	0x97, 0x0d, 0xaa, 0xe1, 0x1e, 0xac, 0x7c, 0xc5, 0x82, 0x80, 0xbd, 0xa5, 0x11, 0xaa, 0xe3, 0x55,
	0xe8, 0x3c, 0xa1, 0x5e, 0xa4, 0x4e, 0x63, 0xe3, 0xfe, 0x11, 0xac, 0x95, 0x84, 0x16, 0xb7, 0xa1,
	0x7e, 0x1e, 0xa2, 0x1b, 0x8a, 0xee, 0x29, 0x93, 0xe7, 0x21, 0xaa, 0x29, 0xba, 0xb3, 0x77, 0xbe,
	0x90, 0x02, 0xd5, 0x71, 0x1f, 0xba, 0x4f, 0x99, 0xb4, 0xc3, 0xc6, 0x31, 0xfa, 0xfe, 0x3f, 0xdb,
	0x37, 0xbe, 0xfb, 0xb0, 0x5d, 0xfb, 0xfe, 0xc3, 0x76, 0xed, 0xdf, 0x1f, 0xb6, 0x6b, 0xe3, 0xb6,
	0xfe, 0xd7, 0xe3, 0xc3, 0x1f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xad, 0x50, 0x25, 0x02, 0x0d, 0x1d,
	0x00, 0x00,
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ID))
	}
	if m.ContainerID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ContainerID))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Type))
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.ResourceHeartbeat.Size()))
	n1, err := m.ResourceHeartbeat.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x2a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.ContainerHeartbeat.Size()))
	n2, err := m.ContainerHeartbeat.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x32
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.PutContainer.Size()))
	n3, err := m.PutContainer.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x3a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.GetContainer.Size()))
	n4, err := m.GetContainer.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	dAtA[i] = 0x42
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.AllocID.Size()))
	n5, err := m.AllocID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x52
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.AskBatchSplit.Size()))
	n6, err := m.AskBatchSplit.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x62
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.BatchReportSplit.Size()))
	n7, err := m.BatchReportSplit.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x6a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.CreateWatcher.Size()))
	n8, err := m.CreateWatcher.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	dAtA[i] = 0x72
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.CreateResources.Size()))
	n9, err := m.CreateResources.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	dAtA[i] = 0x7a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.RemoveResources.Size()))
	n10, err := m.RemoveResources.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	dAtA[i] = 0x82
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.CheckResourceState.Size()))
	n11, err := m.CheckResourceState.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	dAtA[i] = 0x8a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.PutPlacementRule.Size()))
	n12, err := m.PutPlacementRule.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	dAtA[i] = 0x92
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.GetAppliedRules.Size()))
	n13, err := m.GetAppliedRules.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	dAtA[i] = 0x9a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.CreateJob.Size()))
	n14, err := m.CreateJob.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	dAtA[i] = 0xa2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.RemoveJob.Size()))
	n15, err := m.RemoveJob.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	dAtA[i] = 0xaa
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.ExecuteJob.Size()))
	n16, err := m.ExecuteJob.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ID))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Type))
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if len(m.Leader) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Leader)))
		i += copy(dAtA[i:], m.Leader)
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.ResourceHeartbeat.Size()))
	n17, err := m.ResourceHeartbeat.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	dAtA[i] = 0x32
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.ContainerHeartbeat.Size()))
	n18, err := m.ContainerHeartbeat.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	dAtA[i] = 0x3a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.PutContainer.Size()))
	n19, err := m.PutContainer.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	dAtA[i] = 0x42
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.GetContainer.Size()))
	n20, err := m.GetContainer.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	dAtA[i] = 0x4a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.AllocID.Size()))
	n21, err := m.AllocID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n21
	dAtA[i] = 0x5a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.AskBatchSplit.Size()))
	n22, err := m.AskBatchSplit.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n22
	dAtA[i] = 0x6a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.BatchReportSplit.Size()))
	n23, err := m.BatchReportSplit.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n23
	dAtA[i] = 0x72
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Event.Size()))
	n24, err := m.Event.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n24
	dAtA[i] = 0x7a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.CreateResources.Size()))
	n25, err := m.CreateResources.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n25
	dAtA[i] = 0x82
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.RemoveResources.Size()))
	n26, err := m.RemoveResources.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n26
	dAtA[i] = 0x8a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.CheckResourceState.Size()))
	n27, err := m.CheckResourceState.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n27
	dAtA[i] = 0x92
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.PutPlacementRule.Size()))
	n28, err := m.PutPlacementRule.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n28
	dAtA[i] = 0x9a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.GetAppliedRules.Size()))
	n29, err := m.GetAppliedRules.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n29
	dAtA[i] = 0xa2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.CreateJob.Size()))
	n30, err := m.CreateJob.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n30
	dAtA[i] = 0xaa
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.RemoveJob.Size()))
	n31, err := m.RemoveJob.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n31
	dAtA[i] = 0xb2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.ExecuteJob.Size()))
	n32, err := m.ExecuteJob.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n32
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResourceHeartbeatReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceHeartbeatReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ContainerID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ContainerID))
	}
	if len(m.Resource) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Resource)))
		i += copy(dAtA[i:], m.Resource)
	}
	if m.Term != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Term))
	}
	if m.Leader != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Leader.Size()))
		n33, err := m.Leader.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if len(m.DownReplicas) > 0 {
		for _, msg := range m.DownReplicas {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PendingReplicas) > 0 {
		for _, msg := range m.PendingReplicas {
			dAtA[i] = 0x32
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x3a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Stats.Size()))
	n34, err := m.Stats.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n34
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResourceHeartbeatRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceHeartbeatRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ResourceID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ResourceID))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.ResourceEpoch.Size()))
	n35, err := m.ResourceEpoch.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n35
	if m.TargetReplica != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.TargetReplica.Size()))
		n36, err := m.TargetReplica.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n36
	}
	if m.ConfigChange != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ConfigChange.Size()))
		n37, err := m.ConfigChange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.TransferLeader != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.TransferLeader.Size()))
		n38, err := m.TransferLeader.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.Merge != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Merge.Size()))
		n39, err := m.Merge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.SplitResource != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.SplitResource.Size()))
		n40, err := m.SplitResource.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	if m.ConfigChangeV2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ConfigChangeV2.Size()))
		n41, err := m.ConfigChangeV2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if m.DestoryDirectly {
		dAtA[i] = 0x48
		i++
		if m.DestoryDirectly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PutContainerReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutContainerReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Container) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Container)))
		i += copy(dAtA[i:], m.Container)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PutContainerRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutContainerRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ContainerHeartbeatReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerHeartbeatReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Stats.Size()))
	n42, err := m.Stats.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n42
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ContainerHeartbeatRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerHeartbeatRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetContainerReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetContainerReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetContainerRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetContainerRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Stats != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Stats.Size()))
		n43, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n43
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AllocIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocIDReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AllocIDRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocIDRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AskBatchSplitReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AskBatchSplitReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AskBatchSplitRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AskBatchSplitRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SplitIDs) > 0 {
		for _, msg := range m.SplitIDs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BatchReportSplitReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchReportSplitReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for _, b := range m.Resources {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BatchReportSplitRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchReportSplitRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SplitID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NewID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.NewID))
	}
	if len(m.NewReplicaIDs) > 0 {
		dAtA45 := make([]byte, len(m.NewReplicaIDs)*10)
		var j44 int
		for _, num := range m.NewReplicaIDs {
			for num >= 1<<7 {
				dAtA45[j44] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j44++
			}
			dAtA45[j44] = uint8(num)
			j44++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(j44))
		i += copy(dAtA[i:], dAtA45[:j44])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateWatcherReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateWatcherReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flag != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Flag))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateResourcesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateResourcesReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for _, b := range m.Resources {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.LeastReplicas) > 0 {
		dAtA47 := make([]byte, len(m.LeastReplicas)*10)
		var j46 int
		for _, num := range m.LeastReplicas {
			for num >= 1<<7 {
				dAtA47[j46] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j46++
			}
			dAtA47[j46] = uint8(num)
			j46++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(j46))
		i += copy(dAtA[i:], dAtA47[:j46])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateResourcesRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateResourcesRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RemoveResourcesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveResourcesReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IDs) > 0 {
		dAtA49 := make([]byte, len(m.IDs)*10)
		var j48 int
		for _, num := range m.IDs {
			for num >= 1<<7 {
				dAtA49[j48] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j48++
			}
			dAtA49[j48] = uint8(num)
			j48++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(j48))
		i += copy(dAtA[i:], dAtA49[:j48])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RemoveResourcesRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveResourcesRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CheckResourceStateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckResourceStateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IDs) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.IDs)))
		i += copy(dAtA[i:], m.IDs)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CheckResourceStateRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckResourceStateRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Removed) > 0 {
		dAtA51 := make([]byte, len(m.Removed)*10)
		var j50 int
		for _, num := range m.Removed {
			for num >= 1<<7 {
				dAtA51[j50] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j50++
			}
			dAtA51[j50] = uint8(num)
			j50++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(j50))
		i += copy(dAtA[i:], dAtA51[:j50])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PutPlacementRuleReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutPlacementRuleReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Rule.Size()))
	n52, err := m.Rule.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n52
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PutPlacementRuleRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutPlacementRuleRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetAppliedRulesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAppliedRulesReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ResourceID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ResourceID))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetAppliedRulesRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAppliedRulesRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateJobReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateJobReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Job.Size()))
	n53, err := m.Job.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n53
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateJobRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateJobRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RemoveJobReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveJobReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Job.Size()))
	n54, err := m.Job.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n54
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RemoveJobRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveJobRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExecuteJobReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteJobReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Job.Size()))
	n55, err := m.Job.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n55
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExecuteJobRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteJobRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EventNotify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventNotify) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seq != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Seq))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Type))
	}
	if m.InitEvent != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.InitEvent.Size()))
		n56, err := m.InitEvent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n56
	}
	if m.ResourceEvent != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ResourceEvent.Size()))
		n57, err := m.ResourceEvent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n57
	}
	if m.ContainerEvent != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ContainerEvent.Size()))
		n58, err := m.ContainerEvent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n58
	}
	if m.ResourceStatsEvent != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ResourceStatsEvent.Size()))
		n59, err := m.ResourceStatsEvent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n59
	}
	if m.ContainerStatsEvent != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ContainerStatsEvent.Size()))
		n60, err := m.ContainerStatsEvent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n60
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InitEventData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitEventData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for _, b := range m.Resources {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Leaders) > 0 {
		dAtA62 := make([]byte, len(m.Leaders)*10)
		var j61 int
		for _, num := range m.Leaders {
			for num >= 1<<7 {
				dAtA62[j61] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j61++
			}
			dAtA62[j61] = uint8(num)
			j61++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(j61))
		i += copy(dAtA[i:], dAtA62[:j61])
	}
	if len(m.Containers) > 0 {
		for _, b := range m.Containers {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResourceEventData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceEventData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Leader != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Leader))
	}
	if m.Removed {
		dAtA[i] = 0x18
		i++
		if m.Removed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Create {
		dAtA[i] = 0x20
		i++
		if m.Create {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ContainerEventData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerEventData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConfigChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigChange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Replica.Size()))
	n63, err := m.Replica.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n63
	if m.ChangeType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ChangeType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TransferLeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferLeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Replica.Size()))
	n64, err := m.Replica.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n64
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConfigChangeV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigChangeV2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for _, msg := range m.Changes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Merge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Merge) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Target) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Target)))
		i += copy(dAtA[i:], m.Target)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SplitResource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitResource) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Policy != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Policy))
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			dAtA[i] = 0x12
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LabelConstraint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabelConstraint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Op != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Op))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PlacementRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlacementRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.GroupID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.GroupID)))
		i += copy(dAtA[i:], m.GroupID)
	}
	if m.Index != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Index))
	}
	if m.Override {
		dAtA[i] = 0x20
		i++
		if m.Override {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.StartKey) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.StartKey)))
		i += copy(dAtA[i:], m.StartKey)
	}
	if len(m.EndKey) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.EndKey)))
		i += copy(dAtA[i:], m.EndKey)
	}
	if m.Role != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Role))
	}
	if m.Count != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Count))
	}
	if len(m.LabelConstraints) > 0 {
		for _, msg := range m.LabelConstraints {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.LocationLabels) > 0 {
		for _, s := range m.LocationLabels {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.IsolationLevel) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.IsolationLevel)))
		i += copy(dAtA[i:], m.IsolationLevel)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintRpcpb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRpcpb(uint64(m.ID))
	}
	if m.ContainerID != 0 {
		n += 1 + sovRpcpb(uint64(m.ContainerID))
	}
	if m.Type != 0 {
		n += 1 + sovRpcpb(uint64(m.Type))
	}
	l = m.ResourceHeartbeat.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.ContainerHeartbeat.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.PutContainer.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.GetContainer.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.AllocID.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.AskBatchSplit.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.BatchReportSplit.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.CreateWatcher.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.CreateResources.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.RemoveResources.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.CheckResourceState.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.PutPlacementRule.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.GetAppliedRules.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.CreateJob.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.RemoveJob.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.ExecuteJob.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRpcpb(uint64(m.ID))
	}
	if m.Type != 0 {
		n += 1 + sovRpcpb(uint64(m.Type))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = m.ResourceHeartbeat.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.ContainerHeartbeat.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.PutContainer.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.GetContainer.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.AllocID.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.AskBatchSplit.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.BatchReportSplit.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.Event.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.CreateResources.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.RemoveResources.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.CheckResourceState.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.PutPlacementRule.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.GetAppliedRules.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.CreateJob.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.RemoveJob.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.ExecuteJob.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourceHeartbeatReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContainerID != 0 {
		n += 1 + sovRpcpb(uint64(m.ContainerID))
	}
	l = len(m.Resource)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Term != 0 {
		n += 1 + sovRpcpb(uint64(m.Term))
	}
	if m.Leader != nil {
		l = m.Leader.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if len(m.DownReplicas) > 0 {
		for _, e := range m.DownReplicas {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if len(m.PendingReplicas) > 0 {
		for _, e := range m.PendingReplicas {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	l = m.Stats.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourceHeartbeatRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResourceID != 0 {
		n += 1 + sovRpcpb(uint64(m.ResourceID))
	}
	l = m.ResourceEpoch.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.TargetReplica != nil {
		l = m.TargetReplica.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.ConfigChange != nil {
		l = m.ConfigChange.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.TransferLeader != nil {
		l = m.TransferLeader.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Merge != nil {
		l = m.Merge.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.SplitResource != nil {
		l = m.SplitResource.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.ConfigChangeV2 != nil {
		l = m.ConfigChangeV2.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.DestoryDirectly {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutContainerReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Container)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutContainerRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContainerHeartbeatReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Stats.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContainerHeartbeatRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetContainerReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRpcpb(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetContainerRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllocIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllocIDRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRpcpb(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AskBatchSplitReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovRpcpb(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AskBatchSplitRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SplitIDs) > 0 {
		for _, e := range m.SplitIDs {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BatchReportSplitReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for _, b := range m.Resources {
			l = len(b)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BatchReportSplitRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SplitID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewID != 0 {
		n += 1 + sovRpcpb(uint64(m.NewID))
	}
	if len(m.NewReplicaIDs) > 0 {
		l = 0
		for _, e := range m.NewReplicaIDs {
			l += sovRpcpb(uint64(e))
		}
		n += 1 + sovRpcpb(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateWatcherReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flag != 0 {
		n += 1 + sovRpcpb(uint64(m.Flag))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateResourcesReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for _, b := range m.Resources {
			l = len(b)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if len(m.LeastReplicas) > 0 {
		l = 0
		for _, e := range m.LeastReplicas {
			l += sovRpcpb(uint64(e))
		}
		n += 1 + sovRpcpb(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateResourcesRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoveResourcesReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IDs) > 0 {
		l = 0
		for _, e := range m.IDs {
			l += sovRpcpb(uint64(e))
		}
		n += 1 + sovRpcpb(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoveResourcesRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckResourceStateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IDs)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckResourceStateRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Removed) > 0 {
		l = 0
		for _, e := range m.Removed {
			l += sovRpcpb(uint64(e))
		}
		n += 1 + sovRpcpb(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutPlacementRuleReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Rule.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutPlacementRuleRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAppliedRulesReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResourceID != 0 {
		n += 1 + sovRpcpb(uint64(m.ResourceID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAppliedRulesRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateJobReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Job.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateJobRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoveJobReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Job.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoveJobRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteJobReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Job.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteJobRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EventNotify) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seq != 0 {
		n += 1 + sovRpcpb(uint64(m.Seq))
	}
	if m.Type != 0 {
		n += 1 + sovRpcpb(uint64(m.Type))
	}
	if m.InitEvent != nil {
		l = m.InitEvent.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.ResourceEvent != nil {
		l = m.ResourceEvent.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.ContainerEvent != nil {
		l = m.ContainerEvent.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.ResourceStatsEvent != nil {
		l = m.ResourceStatsEvent.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.ContainerStatsEvent != nil {
		l = m.ContainerStatsEvent.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InitEventData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for _, b := range m.Resources {
			l = len(b)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if len(m.Leaders) > 0 {
		l = 0
		for _, e := range m.Leaders {
			l += sovRpcpb(uint64(e))
		}
		n += 1 + sovRpcpb(uint64(l)) + l
	}
	if len(m.Containers) > 0 {
		for _, b := range m.Containers {
			l = len(b)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourceEventData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Leader != 0 {
		n += 1 + sovRpcpb(uint64(m.Leader))
	}
	if m.Removed {
		n += 2
	}
	if m.Create {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContainerEventData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Replica.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.ChangeType != 0 {
		n += 1 + sovRpcpb(uint64(m.ChangeType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransferLeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Replica.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigChangeV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for _, e := range m.Changes {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Merge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SplitResource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Policy != 0 {
		n += 1 + sovRpcpb(uint64(m.Policy))
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LabelConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Op != 0 {
		n += 1 + sovRpcpb(uint64(m.Op))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlacementRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = len(m.GroupID)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovRpcpb(uint64(m.Index))
	}
	if m.Override {
		n += 2
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Role != 0 {
		n += 1 + sovRpcpb(uint64(m.Role))
	}
	if m.Count != 0 {
		n += 1 + sovRpcpb(uint64(m.Count))
	}
	if len(m.LabelConstraints) > 0 {
		for _, e := range m.LabelConstraints {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if len(m.LocationLabels) > 0 {
		for _, s := range m.LocationLabels {
			l = len(s)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	l = len(m.IsolationLevel)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovRpcpb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRpcpb(x uint64) (n int) {
	return sovRpcpb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerID", wireType)
			}
			m.ContainerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceHeartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ContainerHeartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PutContainer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PutContainer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetContainer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetContainer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AllocID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskBatchSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AskBatchSplit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchReportSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BatchReportSplit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateWatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreateWatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreateResources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemoveResources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckResourceState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CheckResourceState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PutPlacementRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PutPlacementRule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetAppliedRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetAppliedRules.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreateJob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemoveJob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecuteJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExecuteJob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceHeartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ContainerHeartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PutContainer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PutContainer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetContainer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetContainer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AllocID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskBatchSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AskBatchSplit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchReportSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BatchReportSplit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Event.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreateResources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveResources", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemoveResources.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckResourceState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CheckResourceState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PutPlacementRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PutPlacementRule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetAppliedRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetAppliedRules.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreateJob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemoveJob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecuteJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExecuteJob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceHeartbeatReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceHeartbeatReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceHeartbeatReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerID", wireType)
			}
			m.ContainerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resource = append(m.Resource[:0], dAtA[iNdEx:postIndex]...)
			if m.Resource == nil {
				m.Resource = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Leader == nil {
				m.Leader = &metapb.Replica{}
			}
			if err := m.Leader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownReplicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownReplicas = append(m.DownReplicas, metapb.ReplicaStats{})
			if err := m.DownReplicas[len(m.DownReplicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingReplicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PendingReplicas = append(m.PendingReplicas, metapb.Replica{})
			if err := m.PendingReplicas[len(m.PendingReplicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceHeartbeatRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceHeartbeatRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceHeartbeatRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceID", wireType)
			}
			m.ResourceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResourceID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetReplica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TargetReplica == nil {
				m.TargetReplica = &metapb.Replica{}
			}
			if err := m.TargetReplica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigChange == nil {
				m.ConfigChange = &ConfigChange{}
			}
			if err := m.ConfigChange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferLeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransferLeader == nil {
				m.TransferLeader = &TransferLeader{}
			}
			if err := m.TransferLeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Merge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Merge == nil {
				m.Merge = &Merge{}
			}
			if err := m.Merge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitResource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SplitResource == nil {
				m.SplitResource = &SplitResource{}
			}
			if err := m.SplitResource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigChangeV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigChangeV2 == nil {
				m.ConfigChangeV2 = &ConfigChangeV2{}
			}
			if err := m.ConfigChangeV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestoryDirectly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DestoryDirectly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutContainerReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutContainerReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutContainerReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Container", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Container = append(m.Container[:0], dAtA[iNdEx:postIndex]...)
			if m.Container == nil {
				m.Container = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutContainerRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutContainerRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutContainerRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerHeartbeatReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerHeartbeatReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerHeartbeatReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerHeartbeatRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerHeartbeatRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerHeartbeatRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetContainerReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetContainerReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetContainerReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetContainerRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetContainerRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetContainerRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &metapb.ContainerStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocIDRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocIDRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocIDRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AskBatchSplitReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AskBatchSplitReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AskBatchSplitReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AskBatchSplitRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AskBatchSplitRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AskBatchSplitRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SplitIDs = append(m.SplitIDs, SplitID{})
			if err := m.SplitIDs[len(m.SplitIDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchReportSplitReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchReportSplitReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchReportSplitReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, make([]byte, postIndex-iNdEx))
			copy(m.Resources[len(m.Resources)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchReportSplitRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchReportSplitRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchReportSplitRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewID", wireType)
			}
			m.NewID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NewReplicaIDs = append(m.NewReplicaIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRpcpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRpcpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NewReplicaIDs) == 0 {
					m.NewReplicaIDs = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NewReplicaIDs = append(m.NewReplicaIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NewReplicaIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateWatcherReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateWatcherReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateWatcherReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateResourcesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateResourcesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateResourcesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, make([]byte, postIndex-iNdEx))
			copy(m.Resources[len(m.Resources)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LeastReplicas = append(m.LeastReplicas, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRpcpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRpcpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LeastReplicas) == 0 {
					m.LeastReplicas = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LeastReplicas = append(m.LeastReplicas, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LeastReplicas", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateResourcesRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateResourcesRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateResourcesRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveResourcesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveResourcesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveResourcesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IDs = append(m.IDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRpcpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRpcpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IDs) == 0 {
					m.IDs = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IDs = append(m.IDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveResourcesRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveResourcesRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveResourcesRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckResourceStateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckResourceStateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckResourceStateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IDs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IDs = append(m.IDs[:0], dAtA[iNdEx:postIndex]...)
			if m.IDs == nil {
				m.IDs = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckResourceStateRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckResourceStateRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckResourceStateRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Removed = append(m.Removed, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRpcpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRpcpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Removed) == 0 {
					m.Removed = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Removed = append(m.Removed, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Removed", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutPlacementRuleReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutPlacementRuleReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutPlacementRuleReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutPlacementRuleRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutPlacementRuleRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutPlacementRuleRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAppliedRulesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAppliedRulesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAppliedRulesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceID", wireType)
			}
			m.ResourceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResourceID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAppliedRulesRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAppliedRulesRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAppliedRulesRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, PlacementRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateJobReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateJobReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateJobReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateJobRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateJobRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateJobRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveJobReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveJobReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveJobReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveJobRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveJobRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveJobRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteJobReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteJobReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteJobReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteJobRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteJobRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteJobRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventNotify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventNotify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventNotify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitEvent == nil {
				m.InitEvent = &InitEventData{}
			}
			if err := m.InitEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceEvent == nil {
				m.ResourceEvent = &ResourceEventData{}
			}
			if err := m.ResourceEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContainerEvent == nil {
				m.ContainerEvent = &ContainerEventData{}
			}
			if err := m.ContainerEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceStatsEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceStatsEvent == nil {
				m.ResourceStatsEvent = &metapb.ResourceStats{}
			}
			if err := m.ResourceStatsEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerStatsEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContainerStatsEvent == nil {
				m.ContainerStatsEvent = &metapb.ContainerStats{}
			}
			if err := m.ContainerStatsEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitEventData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitEventData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitEventData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, make([]byte, postIndex-iNdEx))
			copy(m.Resources[len(m.Resources)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Leaders = append(m.Leaders, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRpcpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRpcpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Leaders) == 0 {
					m.Leaders = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Leaders = append(m.Leaders, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Leaders", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Containers = append(m.Containers, make([]byte, postIndex-iNdEx))
			copy(m.Containers[len(m.Containers)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceEventData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceEventData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceEventData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			m.Leader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leader |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Removed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Removed = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Create", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Create = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerEventData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerEventData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerEventData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Replica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeType", wireType)
			}
			m.ChangeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeType |= metapb.ConfigChangeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferLeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferLeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferLeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Replica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigChangeV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigChangeV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigChangeV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changes = append(m.Changes, ConfigChange{})
			if err := m.Changes[len(m.Changes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Merge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Merge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Merge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = append(m.Target[:0], dAtA[iNdEx:postIndex]...)
			if m.Target == nil {
				m.Target = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitResource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitResource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitResource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			m.Policy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Policy |= metapb.CheckPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabelConstraint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelConstraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelConstraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= LabelConstraintOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlacementRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlacementRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlacementRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Override", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Override = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= ReplicaRoleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelConstraints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LabelConstraints = append(m.LabelConstraints, LabelConstraint{})
			if err := m.LabelConstraints[len(m.LabelConstraints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocationLabels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocationLabels = append(m.LocationLabels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsolationLevel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IsolationLevel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRpcpb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRpcpb
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthRpcpb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRpcpb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthRpcpb
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRpcpb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRpcpb   = fmt.Errorf("proto: integer overflow")
)
