// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: metapb.proto

package metapb

import (
	fmt "fmt"
	io "io"
	math "math"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Action the action while a new node join the cluster
type Action int32

const (
	Action_None     Action = 0
	Action_ScaleOut Action = 1
)

var Action_name = map[int32]string{
	0: "None",
	1: "ScaleOut",
}

var Action_value = map[string]int32{
	"None":     0,
	"ScaleOut": 1,
}

func (x Action) String() string {
	return proto.EnumName(Action_name, int32(x))
}

func (Action) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{0}
}

// ResourceKind the resource king
type ResourceKind int32

const (
	ResourceKind_LeaderKind  ResourceKind = 0
	ResourceKind_ReplicaKind ResourceKind = 1
)

var ResourceKind_name = map[int32]string{
	0: "LeaderKind",
	1: "ReplicaKind",
}

var ResourceKind_value = map[string]int32{
	"LeaderKind":  0,
	"ReplicaKind": 1,
}

func (x ResourceKind) String() string {
	return proto.EnumName(ResourceKind_name, int32(x))
}

func (ResourceKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{1}
}

// State the container state
type ContainerState int32

const (
	// UP is normal state
	ContainerState_UP ContainerState = 0
	// Offline is the unavailable state
	ContainerState_Offline ContainerState = 1
	// Tombstone is the destory state
	ContainerState_Tombstone ContainerState = 2
)

var ContainerState_name = map[int32]string{
	0: "UP",
	1: "Offline",
	2: "Tombstone",
}

var ContainerState_value = map[string]int32{
	"UP":        0,
	"Offline":   1,
	"Tombstone": 2,
}

func (x ContainerState) String() string {
	return proto.EnumName(ContainerState_name, int32(x))
}

func (ContainerState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{2}
}

// ResourceState the resource state
type ResourceState int32

const (
	// Running is serve state
	ResourceState_Running ResourceState = 0
	// Create is the destory state
	ResourceState_WaittingCreate ResourceState = 1
	// Removed is the destory state
	ResourceState_Removed ResourceState = 2
)

var ResourceState_name = map[int32]string{
	0: "Running",
	1: "WaittingCreate",
	2: "Removed",
}

var ResourceState_value = map[string]int32{
	"Running":        0,
	"WaittingCreate": 1,
	"Removed":        2,
}

func (x ResourceState) String() string {
	return proto.EnumName(ResourceState_name, int32(x))
}

func (ResourceState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{3}
}

// ConfigChangeType change replica type
type ConfigChangeType int32

const (
	ConfigChangeType_AddNode        ConfigChangeType = 0
	ConfigChangeType_RemoveNode     ConfigChangeType = 1
	ConfigChangeType_UpdateNode     ConfigChangeType = 2
	ConfigChangeType_AddLearnerNode ConfigChangeType = 3
	ConfigChangeType_ScalePeer      ConfigChangeType = 4
)

var ConfigChangeType_name = map[int32]string{
	0: "AddNode",
	1: "RemoveNode",
	2: "UpdateNode",
	3: "AddLearnerNode",
	4: "ScalePeer",
}

var ConfigChangeType_value = map[string]int32{
	"AddNode":        0,
	"RemoveNode":     1,
	"UpdateNode":     2,
	"AddLearnerNode": 3,
	"ScalePeer":      4,
}

func (x ConfigChangeType) String() string {
	return proto.EnumName(ConfigChangeType_name, int32(x))
}

func (ConfigChangeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{4}
}

// ReplicaRole role of current replica
type ReplicaRole int32

const (
	ReplicaRole_Voter         ReplicaRole = 0
	ReplicaRole_Learner       ReplicaRole = 1
	ReplicaRole_IncomingVoter ReplicaRole = 2
	ReplicaRole_DemotingVoter ReplicaRole = 3
)

var ReplicaRole_name = map[int32]string{
	0: "Voter",
	1: "Learner",
	2: "IncomingVoter",
	3: "DemotingVoter",
}

var ReplicaRole_value = map[string]int32{
	"Voter":         0,
	"Learner":       1,
	"IncomingVoter": 2,
	"DemotingVoter": 3,
}

func (x ReplicaRole) String() string {
	return proto.EnumName(ReplicaRole_name, int32(x))
}

func (ReplicaRole) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{5}
}

// CheckPolicy check policy
type CheckPolicy int32

const (
	CheckPolicy_SCAN        CheckPolicy = 0
	CheckPolicy_APPROXIMATE CheckPolicy = 1
	CheckPolicy_USEKEY      CheckPolicy = 2
)

var CheckPolicy_name = map[int32]string{
	0: "SCAN",
	1: "APPROXIMATE",
	2: "USEKEY",
}

var CheckPolicy_value = map[string]int32{
	"SCAN":        0,
	"APPROXIMATE": 1,
	"USEKEY":      2,
}

func (x CheckPolicy) String() string {
	return proto.EnumName(CheckPolicy_name, int32(x))
}

func (CheckPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{6}
}

// OperatorStatus Operator Status
type OperatorStatus int32

const (
	OperatorStatus_SUCCESS OperatorStatus = 0
	OperatorStatus_TIMEOUT OperatorStatus = 1
	OperatorStatus_CANCEL  OperatorStatus = 2
	OperatorStatus_REPLACE OperatorStatus = 3
	OperatorStatus_RUNNING OperatorStatus = 4
)

var OperatorStatus_name = map[int32]string{
	0: "SUCCESS",
	1: "TIMEOUT",
	2: "CANCEL",
	3: "REPLACE",
	4: "RUNNING",
}

var OperatorStatus_value = map[string]int32{
	"SUCCESS": 0,
	"TIMEOUT": 1,
	"CANCEL":  2,
	"REPLACE": 3,
	"RUNNING": 4,
}

func (x OperatorStatus) String() string {
	return proto.EnumName(OperatorStatus_name, int32(x))
}

func (OperatorStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{7}
}

// JobType job type
type JobType int32

const (
	// RemoveResource remove resource job
	JobType_RemoveResource JobType = 0
	// CreateResourcePool create resource pool
	JobType_CreateResourcePool JobType = 1
	// CustomStartAt custom job
	JobType_CustomStartAt JobType = 100
)

var JobType_name = map[int32]string{
	0:   "RemoveResource",
	1:   "CreateResourcePool",
	100: "CustomStartAt",
}

var JobType_value = map[string]int32{
	"RemoveResource":     0,
	"CreateResourcePool": 1,
	"CustomStartAt":      100,
}

func (x JobType) String() string {
	return proto.EnumName(JobType_name, int32(x))
}

func (JobType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{8}
}

// JobState job state
type JobState int32

const (
	// Created wait to running
	JobState_Created JobState = 0
	// Working job is working
	JobState_Working JobState = 1
	// Completed job completed, need to gc
	JobState_Completed JobState = 2
)

var JobState_name = map[int32]string{
	0: "Created",
	1: "Working",
	2: "Completed",
}

var JobState_value = map[string]int32{
	"Created":   0,
	"Working":   1,
	"Completed": 2,
}

func (x JobState) String() string {
	return proto.EnumName(JobState_name, int32(x))
}

func (JobState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{9}
}

// ResourceEpoch resource epoch
type ResourceEpoch struct {
	// Conf change version, auto increment when add or remove replica
	ConfVer uint64 `protobuf:"varint,1,opt,name=confVer,proto3" json:"confVer,omitempty"`
	// Resource version, auto increment when split or merge
	Version              uint64   `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResourceEpoch) Reset()         { *m = ResourceEpoch{} }
func (m *ResourceEpoch) String() string { return proto.CompactTextString(m) }
func (*ResourceEpoch) ProtoMessage()    {}
func (*ResourceEpoch) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{0}
}
func (m *ResourceEpoch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceEpoch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceEpoch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceEpoch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceEpoch.Merge(m, src)
}
func (m *ResourceEpoch) XXX_Size() int {
	return m.Size()
}
func (m *ResourceEpoch) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceEpoch.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceEpoch proto.InternalMessageInfo

func (m *ResourceEpoch) GetConfVer() uint64 {
	if m != nil {
		return m.ConfVer
	}
	return 0
}

func (m *ResourceEpoch) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

// Replica of the resource
type Replica struct {
	ID                   uint64      `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	ContainerID          uint64      `protobuf:"varint,2,opt,name=containerID,proto3" json:"containerID,omitempty"`
	Role                 ReplicaRole `protobuf:"varint,3,opt,name=role,proto3,enum=metapb.ReplicaRole" json:"role,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Replica) Reset()         { *m = Replica{} }
func (m *Replica) String() string { return proto.CompactTextString(m) }
func (*Replica) ProtoMessage()    {}
func (*Replica) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{1}
}
func (m *Replica) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Replica) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Replica.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Replica) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Replica.Merge(m, src)
}
func (m *Replica) XXX_Size() int {
	return m.Size()
}
func (m *Replica) XXX_DiscardUnknown() {
	xxx_messageInfo_Replica.DiscardUnknown(m)
}

var xxx_messageInfo_Replica proto.InternalMessageInfo

func (m *Replica) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Replica) GetContainerID() uint64 {
	if m != nil {
		return m.ContainerID
	}
	return 0
}

func (m *Replica) GetRole() ReplicaRole {
	if m != nil {
		return m.Role
	}
	return ReplicaRole_Voter
}

// ReplicaStats replica stats
type ReplicaStats struct {
	Replica              Replica  `protobuf:"bytes,1,opt,name=replica,proto3" json:"replica"`
	DownSeconds          uint64   `protobuf:"varint,2,opt,name=downSeconds,proto3" json:"downSeconds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReplicaStats) Reset()         { *m = ReplicaStats{} }
func (m *ReplicaStats) String() string { return proto.CompactTextString(m) }
func (*ReplicaStats) ProtoMessage()    {}
func (*ReplicaStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{2}
}
func (m *ReplicaStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicaStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplicaStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplicaStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicaStats.Merge(m, src)
}
func (m *ReplicaStats) XXX_Size() int {
	return m.Size()
}
func (m *ReplicaStats) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicaStats.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicaStats proto.InternalMessageInfo

func (m *ReplicaStats) GetReplica() Replica {
	if m != nil {
		return m.Replica
	}
	return Replica{}
}

func (m *ReplicaStats) GetDownSeconds() uint64 {
	if m != nil {
		return m.DownSeconds
	}
	return 0
}

// Pair key value pair
type Pair struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Pair) Reset()         { *m = Pair{} }
func (m *Pair) String() string { return proto.CompactTextString(m) }
func (*Pair) ProtoMessage()    {}
func (*Pair) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{3}
}
func (m *Pair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pair.Merge(m, src)
}
func (m *Pair) XXX_Size() int {
	return m.Size()
}
func (m *Pair) XXX_DiscardUnknown() {
	xxx_messageInfo_Pair.DiscardUnknown(m)
}

var xxx_messageInfo_Pair proto.InternalMessageInfo

func (m *Pair) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Pair) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// ResourceStats resource stats
type ResourceStats struct {
	// resource ID
	ResourceID uint64 `protobuf:"varint,1,opt,name=resourceID,proto3" json:"resourceID,omitempty"`
	// bytes written during this period
	WrittenBytes uint64 `protobuf:"varint,2,opt,name=writtenBytes,proto3" json:"writtenBytes,omitempty"`
	// keys written during this period
	WrittenKeys uint64 `protobuf:"varint,3,opt,name=writtenKeys,proto3" json:"writtenKeys,omitempty"`
	// bytes read during this period
	ReadBytes uint64 `protobuf:"varint,4,opt,name=readBytes,proto3" json:"readBytes,omitempty"`
	// keys read during this period
	ReadKeys uint64 `protobuf:"varint,5,opt,name=readKeys,proto3" json:"readKeys,omitempty"`
	// approximate data size in bytes of the resource
	ApproximateSize uint64 `protobuf:"varint,6,opt,name=approximateSize,proto3" json:"approximateSize,omitempty"`
	// approximate count of keys in the resource
	ApproximateKeys uint64 `protobuf:"varint,7,opt,name=approximateKeys,proto3" json:"approximateKeys,omitempty"`
	// Actually reported time interval
	Interval             *TimeInterval `protobuf:"bytes,8,opt,name=interval,proto3" json:"interval,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ResourceStats) Reset()         { *m = ResourceStats{} }
func (m *ResourceStats) String() string { return proto.CompactTextString(m) }
func (*ResourceStats) ProtoMessage()    {}
func (*ResourceStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{4}
}
func (m *ResourceStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceStats.Merge(m, src)
}
func (m *ResourceStats) XXX_Size() int {
	return m.Size()
}
func (m *ResourceStats) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceStats.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceStats proto.InternalMessageInfo

func (m *ResourceStats) GetResourceID() uint64 {
	if m != nil {
		return m.ResourceID
	}
	return 0
}

func (m *ResourceStats) GetWrittenBytes() uint64 {
	if m != nil {
		return m.WrittenBytes
	}
	return 0
}

func (m *ResourceStats) GetWrittenKeys() uint64 {
	if m != nil {
		return m.WrittenKeys
	}
	return 0
}

func (m *ResourceStats) GetReadBytes() uint64 {
	if m != nil {
		return m.ReadBytes
	}
	return 0
}

func (m *ResourceStats) GetReadKeys() uint64 {
	if m != nil {
		return m.ReadKeys
	}
	return 0
}

func (m *ResourceStats) GetApproximateSize() uint64 {
	if m != nil {
		return m.ApproximateSize
	}
	return 0
}

func (m *ResourceStats) GetApproximateKeys() uint64 {
	if m != nil {
		return m.ApproximateKeys
	}
	return 0
}

func (m *ResourceStats) GetInterval() *TimeInterval {
	if m != nil {
		return m.Interval
	}
	return nil
}

// ContainerStats container stats
type ContainerStats struct {
	// Container id
	ContainerID uint64 `protobuf:"varint,1,opt,name=containerID,proto3" json:"containerID,omitempty"`
	// When the container is started (unix timestamp in seconds).
	StartTime uint64 `protobuf:"varint,2,opt,name=startTime,proto3" json:"startTime,omitempty"`
	// Actually reported time interval
	Interval *TimeInterval `protobuf:"bytes,3,opt,name=interval,proto3" json:"interval,omitempty"`
	// Capacity for the container.
	Capacity uint64 `protobuf:"varint,4,opt,name=capacity,proto3" json:"capacity,omitempty"`
	// Available size for the container.
	Available uint64 `protobuf:"varint,5,opt,name=available,proto3" json:"available,omitempty"`
	// Actually used space by db
	UsedSize uint64 `protobuf:"varint,6,opt,name=usedSize,proto3" json:"usedSize,omitempty"`
	// If the container is busy
	IsBusy bool `protobuf:"varint,7,opt,name=isBusy,proto3" json:"isBusy,omitempty"`
	// Total resource count in this container.
	ResourceCount uint64 `protobuf:"varint,8,opt,name=resourceCount,proto3" json:"resourceCount,omitempty"`
	// Current sending snapshot count.
	SendingSnapCount uint64 `protobuf:"varint,9,opt,name=sendingSnapCount,proto3" json:"sendingSnapCount,omitempty"`
	// Current receiving snapshot count.
	ReceivingSnapCount uint64 `protobuf:"varint,10,opt,name=receivingSnapCount,proto3" json:"receivingSnapCount,omitempty"`
	// How many resource is applying snapshot.
	ApplyingSnapCount uint64 `protobuf:"varint,11,opt,name=applyingSnapCount,proto3" json:"applyingSnapCount,omitempty"`
	// Bytes written for the container during this period.
	WrittenBytes uint64 `protobuf:"varint,12,opt,name=writtenBytes,proto3" json:"writtenBytes,omitempty"`
	// Bytes read for the container during this period.
	ReadBytes uint64 `protobuf:"varint,13,opt,name=readBytes,proto3" json:"readBytes,omitempty"`
	// Bytes written for the container during this period.
	WrittenKeys uint64 `protobuf:"varint,14,opt,name=writtenKeys,proto3" json:"writtenKeys,omitempty"`
	// Bytes read for the container during this period.
	ReadKeys uint64 `protobuf:"varint,15,opt,name=readKeys,proto3" json:"readKeys,omitempty"`
	// Threads' CPU usages in the container
	CpuUsages []RecordPair `protobuf:"bytes,16,rep,name=cpuUsages,proto3" json:"cpuUsages"`
	// Threads' read disk I/O rates in the container
	ReadIORates []RecordPair `protobuf:"bytes,17,rep,name=readIORates,proto3" json:"readIORates"`
	// Threads' write disk I/O rates in the container
	WriteIORates []RecordPair `protobuf:"bytes,18,rep,name=writeIORates,proto3" json:"writeIORates"`
	// Operations' latencies in the container
	OpLatencies          []RecordPair `protobuf:"bytes,19,rep,name=opLatencies,proto3" json:"opLatencies"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ContainerStats) Reset()         { *m = ContainerStats{} }
func (m *ContainerStats) String() string { return proto.CompactTextString(m) }
func (*ContainerStats) ProtoMessage()    {}
func (*ContainerStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{5}
}
func (m *ContainerStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerStats.Merge(m, src)
}
func (m *ContainerStats) XXX_Size() int {
	return m.Size()
}
func (m *ContainerStats) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerStats.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerStats proto.InternalMessageInfo

func (m *ContainerStats) GetContainerID() uint64 {
	if m != nil {
		return m.ContainerID
	}
	return 0
}

func (m *ContainerStats) GetStartTime() uint64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *ContainerStats) GetInterval() *TimeInterval {
	if m != nil {
		return m.Interval
	}
	return nil
}

func (m *ContainerStats) GetCapacity() uint64 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

func (m *ContainerStats) GetAvailable() uint64 {
	if m != nil {
		return m.Available
	}
	return 0
}

func (m *ContainerStats) GetUsedSize() uint64 {
	if m != nil {
		return m.UsedSize
	}
	return 0
}

func (m *ContainerStats) GetIsBusy() bool {
	if m != nil {
		return m.IsBusy
	}
	return false
}

func (m *ContainerStats) GetResourceCount() uint64 {
	if m != nil {
		return m.ResourceCount
	}
	return 0
}

func (m *ContainerStats) GetSendingSnapCount() uint64 {
	if m != nil {
		return m.SendingSnapCount
	}
	return 0
}

func (m *ContainerStats) GetReceivingSnapCount() uint64 {
	if m != nil {
		return m.ReceivingSnapCount
	}
	return 0
}

func (m *ContainerStats) GetApplyingSnapCount() uint64 {
	if m != nil {
		return m.ApplyingSnapCount
	}
	return 0
}

func (m *ContainerStats) GetWrittenBytes() uint64 {
	if m != nil {
		return m.WrittenBytes
	}
	return 0
}

func (m *ContainerStats) GetReadBytes() uint64 {
	if m != nil {
		return m.ReadBytes
	}
	return 0
}

func (m *ContainerStats) GetWrittenKeys() uint64 {
	if m != nil {
		return m.WrittenKeys
	}
	return 0
}

func (m *ContainerStats) GetReadKeys() uint64 {
	if m != nil {
		return m.ReadKeys
	}
	return 0
}

func (m *ContainerStats) GetCpuUsages() []RecordPair {
	if m != nil {
		return m.CpuUsages
	}
	return nil
}

func (m *ContainerStats) GetReadIORates() []RecordPair {
	if m != nil {
		return m.ReadIORates
	}
	return nil
}

func (m *ContainerStats) GetWriteIORates() []RecordPair {
	if m != nil {
		return m.WriteIORates
	}
	return nil
}

func (m *ContainerStats) GetOpLatencies() []RecordPair {
	if m != nil {
		return m.OpLatencies
	}
	return nil
}

// RecordPair record pair
type RecordPair struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                uint64   `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RecordPair) Reset()         { *m = RecordPair{} }
func (m *RecordPair) String() string { return proto.CompactTextString(m) }
func (*RecordPair) ProtoMessage()    {}
func (*RecordPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{6}
}
func (m *RecordPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecordPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordPair.Merge(m, src)
}
func (m *RecordPair) XXX_Size() int {
	return m.Size()
}
func (m *RecordPair) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordPair.DiscardUnknown(m)
}

var xxx_messageInfo_RecordPair proto.InternalMessageInfo

func (m *RecordPair) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *RecordPair) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// Member prophet member
type Member struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Addr                 string   `protobuf:"bytes,3,opt,name=addr,proto3" json:"addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Member) Reset()         { *m = Member{} }
func (m *Member) String() string { return proto.CompactTextString(m) }
func (*Member) ProtoMessage()    {}
func (*Member) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{7}
}
func (m *Member) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Member) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Member.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Member) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Member.Merge(m, src)
}
func (m *Member) XXX_Size() int {
	return m.Size()
}
func (m *Member) XXX_DiscardUnknown() {
	xxx_messageInfo_Member.DiscardUnknown(m)
}

var xxx_messageInfo_Member proto.InternalMessageInfo

func (m *Member) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Member) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Member) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

// Cluster prophet cluster
type Cluster struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	MaxReplicaCount      uint32   `protobuf:"varint,2,opt,name=maxReplicaCount,proto3" json:"maxReplicaCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Cluster) Reset()         { *m = Cluster{} }
func (m *Cluster) String() string { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()    {}
func (*Cluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{8}
}
func (m *Cluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster.Merge(m, src)
}
func (m *Cluster) XXX_Size() int {
	return m.Size()
}
func (m *Cluster) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster proto.InternalMessageInfo

func (m *Cluster) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Cluster) GetMaxReplicaCount() uint32 {
	if m != nil {
		return m.MaxReplicaCount
	}
	return 0
}

// TimeInterval time interval
type TimeInterval struct {
	// The unix timestamp in seconds of the start of this period.
	Start uint64 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	// The unix timestamp in seconds of the end of this period.
	End                  uint64   `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TimeInterval) Reset()         { *m = TimeInterval{} }
func (m *TimeInterval) String() string { return proto.CompactTextString(m) }
func (*TimeInterval) ProtoMessage()    {}
func (*TimeInterval) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{9}
}
func (m *TimeInterval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimeInterval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimeInterval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimeInterval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimeInterval.Merge(m, src)
}
func (m *TimeInterval) XXX_Size() int {
	return m.Size()
}
func (m *TimeInterval) XXX_DiscardUnknown() {
	xxx_messageInfo_TimeInterval.DiscardUnknown(m)
}

var xxx_messageInfo_TimeInterval proto.InternalMessageInfo

func (m *TimeInterval) GetStart() uint64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *TimeInterval) GetEnd() uint64 {
	if m != nil {
		return m.End
	}
	return 0
}

// Job job
type Job struct {
	Type                 JobType  `protobuf:"varint,1,opt,name=type,proto3,enum=metapb.JobType" json:"type,omitempty"`
	Content              []byte   `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
	State                JobState `protobuf:"varint,3,opt,name=state,proto3,enum=metapb.JobState" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Job) Reset()         { *m = Job{} }
func (m *Job) String() string { return proto.CompactTextString(m) }
func (*Job) ProtoMessage()    {}
func (*Job) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{10}
}
func (m *Job) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Job) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Job.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Job) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Job.Merge(m, src)
}
func (m *Job) XXX_Size() int {
	return m.Size()
}
func (m *Job) XXX_DiscardUnknown() {
	xxx_messageInfo_Job.DiscardUnknown(m)
}

var xxx_messageInfo_Job proto.InternalMessageInfo

func (m *Job) GetType() JobType {
	if m != nil {
		return m.Type
	}
	return JobType_RemoveResource
}

func (m *Job) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *Job) GetState() JobState {
	if m != nil {
		return m.State
	}
	return JobState_Created
}

// RemoveResourceJob remove resources job
type RemoveResourceJob struct {
	ID                   uint64    `protobuf:"varint,1,opt,name=resourceID,proto3" json:"resourceID,omitempty"`
	Replicass            []Replica `protobuf:"bytes,2,rep,name=replicass,proto3" json:"replicass"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *RemoveResourceJob) Reset()         { *m = RemoveResourceJob{} }
func (m *RemoveResourceJob) String() string { return proto.CompactTextString(m) }
func (*RemoveResourceJob) ProtoMessage()    {}
func (*RemoveResourceJob) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{11}
}
func (m *RemoveResourceJob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveResourceJob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveResourceJob.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveResourceJob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveResourceJob.Merge(m, src)
}
func (m *RemoveResourceJob) XXX_Size() int {
	return m.Size()
}
func (m *RemoveResourceJob) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveResourceJob.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveResourceJob proto.InternalMessageInfo

func (m *RemoveResourceJob) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *RemoveResourceJob) GetReplicass() []Replica {
	if m != nil {
		return m.Replicass
	}
	return nil
}

// ResourcePoolJob resource pool job
type ResourcePoolJob struct {
	Pools                []ResourcePool `protobuf:"bytes,1,rep,name=pools,proto3" json:"pools"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ResourcePoolJob) Reset()         { *m = ResourcePoolJob{} }
func (m *ResourcePoolJob) String() string { return proto.CompactTextString(m) }
func (*ResourcePoolJob) ProtoMessage()    {}
func (*ResourcePoolJob) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{12}
}
func (m *ResourcePoolJob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourcePoolJob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourcePoolJob.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourcePoolJob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourcePoolJob.Merge(m, src)
}
func (m *ResourcePoolJob) XXX_Size() int {
	return m.Size()
}
func (m *ResourcePoolJob) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourcePoolJob.DiscardUnknown(m)
}

var xxx_messageInfo_ResourcePoolJob proto.InternalMessageInfo

func (m *ResourcePoolJob) GetPools() []ResourcePool {
	if m != nil {
		return m.Pools
	}
	return nil
}

// ResourcePool resource pool
type ResourcePool struct {
	Group                uint64   `protobuf:"varint,1,opt,name=group,proto3" json:"group,omitempty"`
	Capacity             uint64   `protobuf:"varint,2,opt,name=capacity,proto3" json:"capacity,omitempty"`
	RangePrefix          []byte   `protobuf:"bytes,3,opt,name=rangePrefix,proto3" json:"rangePrefix,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ResourcePool) Reset()         { *m = ResourcePool{} }
func (m *ResourcePool) String() string { return proto.CompactTextString(m) }
func (*ResourcePool) ProtoMessage()    {}
func (*ResourcePool) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{13}
}
func (m *ResourcePool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourcePool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourcePool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourcePool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourcePool.Merge(m, src)
}
func (m *ResourcePool) XXX_Size() int {
	return m.Size()
}
func (m *ResourcePool) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourcePool.DiscardUnknown(m)
}

var xxx_messageInfo_ResourcePool proto.InternalMessageInfo

func (m *ResourcePool) GetGroup() uint64 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *ResourcePool) GetCapacity() uint64 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

func (m *ResourcePool) GetRangePrefix() []byte {
	if m != nil {
		return m.RangePrefix
	}
	return nil
}

func init() {
	proto.RegisterEnum("metapb.Action", Action_name, Action_value)
	proto.RegisterEnum("metapb.ResourceKind", ResourceKind_name, ResourceKind_value)
	proto.RegisterEnum("metapb.ContainerState", ContainerState_name, ContainerState_value)
	proto.RegisterEnum("metapb.ResourceState", ResourceState_name, ResourceState_value)
	proto.RegisterEnum("metapb.ConfigChangeType", ConfigChangeType_name, ConfigChangeType_value)
	proto.RegisterEnum("metapb.ReplicaRole", ReplicaRole_name, ReplicaRole_value)
	proto.RegisterEnum("metapb.CheckPolicy", CheckPolicy_name, CheckPolicy_value)
	proto.RegisterEnum("metapb.OperatorStatus", OperatorStatus_name, OperatorStatus_value)
	proto.RegisterEnum("metapb.JobType", JobType_name, JobType_value)
	proto.RegisterEnum("metapb.JobState", JobState_name, JobState_value)
	proto.RegisterType((*ResourceEpoch)(nil), "metapb.ResourceEpoch")
	proto.RegisterType((*Replica)(nil), "metapb.Replica")
	proto.RegisterType((*ReplicaStats)(nil), "metapb.ReplicaStats")
	proto.RegisterType((*Pair)(nil), "metapb.Pair")
	proto.RegisterType((*ResourceStats)(nil), "metapb.ResourceStats")
	proto.RegisterType((*ContainerStats)(nil), "metapb.ContainerStats")
	proto.RegisterType((*RecordPair)(nil), "metapb.RecordPair")
	proto.RegisterType((*Member)(nil), "metapb.Member")
	proto.RegisterType((*Cluster)(nil), "metapb.Cluster")
	proto.RegisterType((*TimeInterval)(nil), "metapb.TimeInterval")
	proto.RegisterType((*Job)(nil), "metapb.Job")
	proto.RegisterType((*RemoveResourceJob)(nil), "metapb.RemoveResourceJob")
	proto.RegisterType((*ResourcePoolJob)(nil), "metapb.ResourcePoolJob")
	proto.RegisterType((*ResourcePool)(nil), "metapb.ResourcePool")
}

func init() { proto.RegisterFile("metapb.proto", fileDescriptor_77b4d575d5a68dda) }

var fileDescriptor_77b4d575d5a68dda = []byte{
	// 1266 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x56, 0xdb, 0x6e, 0xdb, 0x46,
	0x13, 0x36, 0x29, 0x59, 0xb6, 0x46, 0xb2, 0x4c, 0x6f, 0x82, 0x40, 0x08, 0x02, 0xc7, 0xe0, 0xff,
	0x23, 0x35, 0x84, 0xd6, 0x0e, 0x92, 0x20, 0x17, 0x45, 0x7b, 0x21, 0xd3, 0x42, 0xa3, 0xd8, 0x91,
	0x05, 0xca, 0x4a, 0xda, 0xcb, 0x15, 0x39, 0x96, 0x17, 0xa1, 0x76, 0x89, 0xe5, 0xd2, 0x89, 0xfa,
	0x10, 0x7d, 0x9b, 0xbe, 0x43, 0x2e, 0xf3, 0x04, 0x41, 0xeb, 0x27, 0x29, 0x76, 0x49, 0xea, 0x98,
	0xd4, 0xbd, 0xe3, 0xcc, 0x7c, 0x73, 0xfa, 0x38, 0x33, 0x24, 0xd4, 0x27, 0xa8, 0x68, 0x3c, 0x3a,
	0x8a, 0xa5, 0x50, 0x82, 0x54, 0x32, 0xe9, 0xe1, 0x0f, 0x63, 0xa6, 0xae, 0xd3, 0xd1, 0x51, 0x20,
	0x26, 0xc7, 0x63, 0x31, 0x16, 0xc7, 0xc6, 0x3c, 0x4a, 0xaf, 0x8c, 0x64, 0x04, 0xf3, 0x94, 0xb9,
	0xb9, 0x1e, 0xec, 0xf8, 0x98, 0x88, 0x54, 0x06, 0xd8, 0x89, 0x45, 0x70, 0x4d, 0x9a, 0xb0, 0x15,
	0x08, 0x7e, 0xf5, 0x16, 0x65, 0xd3, 0x3a, 0xb0, 0x0e, 0xcb, 0x7e, 0x21, 0x6a, 0xcb, 0x0d, 0xca,
	0x84, 0x09, 0xde, 0xb4, 0x33, 0x4b, 0x2e, 0xba, 0x11, 0x6c, 0xf9, 0x18, 0x47, 0x2c, 0xa0, 0xe4,
	0x01, 0xd8, 0x2c, 0xcc, 0x3c, 0x4f, 0x2a, 0xb7, 0x5f, 0x1e, 0xdb, 0xdd, 0x53, 0xdf, 0x66, 0x21,
	0x39, 0x80, 0x5a, 0x20, 0xb8, 0xa2, 0x8c, 0xa3, 0xec, 0x9e, 0xe6, 0x01, 0x16, 0x55, 0xe4, 0x3b,
	0x28, 0x4b, 0x11, 0x61, 0xb3, 0x74, 0x60, 0x1d, 0x36, 0x9e, 0xdd, 0x3b, 0xca, 0xbb, 0xcb, 0x03,
	0xfb, 0x22, 0x42, 0xdf, 0x00, 0x5c, 0x0a, 0xf5, 0x5c, 0x39, 0x50, 0x54, 0x25, 0xe4, 0x18, 0xb6,
	0x64, 0x26, 0x9b, 0xbc, 0xb5, 0x67, 0xbb, 0x2b, 0xbe, 0x27, 0xe5, 0x4f, 0x5f, 0x1e, 0x6f, 0xf8,
	0x05, 0x4a, 0xd7, 0x12, 0x8a, 0x0f, 0x7c, 0x80, 0x81, 0xe0, 0x61, 0x52, 0xd4, 0xb2, 0xa0, 0x72,
	0x8f, 0xa0, 0xdc, 0xa7, 0x4c, 0x12, 0x07, 0x4a, 0xef, 0x71, 0x6a, 0xc2, 0x56, 0x7d, 0xfd, 0x48,
	0xee, 0xc3, 0xe6, 0x0d, 0x8d, 0x52, 0x34, 0x5e, 0x55, 0x3f, 0x13, 0xdc, 0x3f, 0xed, 0x39, 0x8d,
	0x59, 0x51, 0xfb, 0x00, 0x32, 0x57, 0x74, 0x4f, 0x73, 0x26, 0x17, 0x34, 0xc4, 0x85, 0xfa, 0x07,
	0xc9, 0x94, 0x42, 0x7e, 0x32, 0x55, 0x58, 0x14, 0xb1, 0xa4, 0xd3, 0x75, 0xe6, 0xf2, 0x19, 0x4e,
	0x13, 0x43, 0x4c, 0xd9, 0x5f, 0x54, 0x91, 0x47, 0x50, 0x95, 0x48, 0xc3, 0x2c, 0x44, 0xd9, 0xd8,
	0xe7, 0x0a, 0xf2, 0x10, 0xb6, 0xb5, 0x60, 0x9c, 0x37, 0x8d, 0x71, 0x26, 0x93, 0x43, 0xd8, 0xa5,
	0x71, 0x2c, 0xc5, 0x47, 0x36, 0xa1, 0x0a, 0x07, 0xec, 0x77, 0x6c, 0x56, 0x0c, 0x64, 0x55, 0xbd,
	0x82, 0x34, 0xc1, 0xb6, 0xd6, 0x90, 0x26, 0xe6, 0x53, 0xd8, 0x66, 0x5c, 0xa1, 0xbc, 0xa1, 0x51,
	0x73, 0xdb, 0xbc, 0x89, 0xfb, 0xc5, 0x9b, 0xb8, 0x64, 0x13, 0xec, 0xe6, 0x36, 0x7f, 0x86, 0x72,
	0xff, 0xa8, 0x40, 0xc3, 0x2b, 0x66, 0x20, 0x23, 0x6e, 0x65, 0x50, 0xac, 0xf5, 0x41, 0x79, 0x04,
	0xd5, 0x44, 0x51, 0xa9, 0x74, 0xcc, 0x9c, 0xb7, 0xb9, 0x62, 0xa9, 0x88, 0xd2, 0x7f, 0x29, 0x42,
	0xd3, 0x14, 0xd0, 0x98, 0x06, 0x4c, 0x4d, 0x73, 0x0e, 0x67, 0xb2, 0xce, 0x45, 0x6f, 0x28, 0x8b,
	0xe8, 0x28, 0xc2, 0x9c, 0xc3, 0xb9, 0x42, 0x7b, 0xa6, 0x09, 0x86, 0x0b, 0xec, 0xcd, 0x64, 0xf2,
	0x00, 0x2a, 0x2c, 0x39, 0x49, 0x93, 0xa9, 0x61, 0x6b, 0xdb, 0xcf, 0x25, 0xf2, 0x7f, 0xd8, 0x29,
	0xc6, 0xc0, 0x13, 0x29, 0x57, 0x86, 0xa9, 0xb2, 0xbf, 0xac, 0x24, 0x2d, 0x70, 0x12, 0xe4, 0x21,
	0xe3, 0xe3, 0x01, 0xa7, 0x71, 0x06, 0xac, 0x1a, 0xe0, 0x9a, 0x9e, 0x1c, 0x01, 0x91, 0x18, 0x20,
	0xbb, 0x59, 0x42, 0x83, 0x41, 0x7f, 0xc5, 0x42, 0xbe, 0x87, 0x3d, 0x1a, 0xc7, 0xd1, 0x74, 0x09,
	0x5e, 0x33, 0xf0, 0x75, 0xc3, 0xda, 0xa0, 0xd6, 0xbf, 0x32, 0xa8, 0x4b, 0x63, 0xb8, 0xb3, 0x3a,
	0x86, 0x2b, 0x63, 0xdc, 0x58, 0x1f, 0xe3, 0xc5, 0x41, 0xdd, 0x5d, 0x19, 0xd4, 0x97, 0x50, 0x0d,
	0xe2, 0x74, 0x98, 0xd0, 0x31, 0x26, 0x4d, 0xe7, 0xa0, 0x74, 0x58, 0x7b, 0x46, 0xe6, 0xfb, 0x1d,
	0x08, 0x19, 0xea, 0x4d, 0xcd, 0x57, 0x7c, 0x0e, 0x25, 0x3f, 0x42, 0x4d, 0xc7, 0xe8, 0x5e, 0xf8,
	0x54, 0x57, 0xb5, 0x77, 0x87, 0xe7, 0x22, 0x98, 0xfc, 0x94, 0xf5, 0x8c, 0x85, 0x33, 0xb9, 0xc3,
	0x79, 0x09, 0xad, 0x33, 0x8b, 0xf8, 0x9c, 0x2a, 0xe4, 0x01, 0xc3, 0xa4, 0x79, 0xef, 0xae, 0xcc,
	0x0b, 0x60, 0xf7, 0x05, 0xc0, 0x1c, 0x70, 0xd7, 0xf9, 0x29, 0x17, 0xe7, 0xe7, 0x15, 0x54, 0xde,
	0xe0, 0x64, 0x84, 0xf2, 0x9b, 0xe7, 0x97, 0x40, 0x99, 0xd3, 0x49, 0x71, 0xb5, 0xcc, 0xb3, 0xd6,
	0xd1, 0x30, 0x94, 0x66, 0x4b, 0xaa, 0xbe, 0x79, 0x76, 0xcf, 0x60, 0xcb, 0x8b, 0xd2, 0x44, 0xfd,
	0x4b, 0xa8, 0x43, 0xd8, 0x9d, 0xd0, 0x8f, 0xf9, 0x69, 0xcd, 0x86, 0x47, 0x47, 0xdd, 0xf1, 0x57,
	0xd5, 0xee, 0x4b, 0xa8, 0x2f, 0xae, 0x9c, 0x2e, 0xde, 0xec, 0x69, 0xbe, 0xd4, 0x99, 0xa0, 0x9b,
	0x44, 0x1e, 0xe6, 0x0d, 0xe9, 0x47, 0x37, 0x82, 0xd2, 0x6b, 0x31, 0x22, 0xff, 0x83, 0xb2, 0x9a,
	0xc6, 0x68, 0xd0, 0x8d, 0xf9, 0x51, 0x7f, 0x2d, 0x46, 0x97, 0xd3, 0x18, 0x7d, 0x63, 0xcc, 0x3f,
	0x57, 0x0a, 0xf3, 0x2a, 0xea, 0x7e, 0x21, 0x92, 0x27, 0x26, 0x9b, 0x2a, 0x3e, 0x28, 0xce, 0x82,
	0xbf, 0xbe, 0x34, 0xe8, 0x67, 0x66, 0x37, 0x86, 0x3d, 0x1f, 0x27, 0xe2, 0x06, 0x8b, 0x03, 0xae,
	0x73, 0x3f, 0x59, 0x3f, 0xdf, 0x33, 0x12, 0x16, 0xcf, 0xf8, 0x73, 0x3d, 0xf9, 0xa6, 0xe5, 0x44,
	0xdf, 0xf0, 0xd2, 0xb7, 0xbf, 0x3e, 0x73, 0x9c, 0xeb, 0xc1, 0x6e, 0x91, 0xab, 0x2f, 0x44, 0xa4,
	0xf3, 0x3d, 0x85, 0xcd, 0x58, 0x88, 0x28, 0x69, 0x5a, 0x26, 0xc6, 0xfd, 0x79, 0x8c, 0x39, 0x2e,
	0x0f, 0x94, 0x01, 0xdd, 0x91, 0xfe, 0x0a, 0xce, 0x8d, 0x9a, 0xdc, 0xb1, 0x14, 0x69, 0x5c, 0x90,
	0x6b, 0x84, 0xa5, 0xdb, 0x66, 0xaf, 0xdc, 0xb6, 0x03, 0xa8, 0x49, 0xca, 0xc7, 0xd8, 0x97, 0x78,
	0xc5, 0x3e, 0x1a, 0x9a, 0xea, 0xfe, 0xa2, 0xaa, 0x75, 0x00, 0x95, 0x76, 0xa0, 0x98, 0xe0, 0x64,
	0x1b, 0xca, 0x3d, 0xc1, 0xd1, 0xd9, 0x20, 0x75, 0xd8, 0x1e, 0x04, 0x34, 0xc2, 0x8b, 0x54, 0x39,
	0x56, 0xeb, 0x78, 0x5e, 0xc5, 0x19, 0xe3, 0x21, 0x69, 0x00, 0x9c, 0x23, 0x0d, 0x51, 0x6a, 0xc9,
	0xd9, 0x20, 0xbb, 0x50, 0xcb, 0x69, 0x30, 0x0a, 0xab, 0xf5, 0x62, 0xe5, 0xe0, 0x23, 0xa9, 0x80,
	0x3d, 0xec, 0x3b, 0x1b, 0xa4, 0x06, 0x5b, 0x17, 0x57, 0x57, 0x11, 0xe3, 0xe8, 0x58, 0x64, 0x07,
	0xaa, 0x97, 0x62, 0x32, 0x4a, 0x94, 0x4e, 0x6a, 0xb7, 0x7e, 0x5e, 0xfe, 0xbc, 0xa2, 0x06, 0xfb,
	0x29, 0xe7, 0x8c, 0x8f, 0x9d, 0x0d, 0x42, 0xa0, 0xf1, 0x8e, 0x32, 0xa5, 0x18, 0x1f, 0x7b, 0x12,
	0xa9, 0xd2, 0x01, 0x34, 0xc0, 0xbc, 0xd5, 0xd0, 0xb1, 0x5b, 0x23, 0x70, 0x3c, 0xc1, 0xaf, 0xd8,
	0xd8, 0xbb, 0xd6, 0xdd, 0xe9, 0xf1, 0xd1, 0x80, 0x76, 0x18, 0xf6, 0x44, 0xa8, 0x9b, 0x6a, 0xe8,
	0xb5, 0xd3, 0x68, 0x23, 0x5b, 0x5a, 0x1e, 0xc6, 0x21, 0x55, 0x99, 0x6c, 0xeb, 0x0c, 0xed, 0x30,
	0x3c, 0x47, 0x2a, 0x39, 0x4a, 0xa3, 0x2b, 0xe9, 0x12, 0x0d, 0x11, 0x7d, 0x44, 0xe9, 0x94, 0x5b,
	0x67, 0xb3, 0x4e, 0xf5, 0xaf, 0x0a, 0xa9, 0xc2, 0xe6, 0x5b, 0xa1, 0x50, 0x66, 0x8d, 0xe5, 0x9e,
	0x8e, 0x45, 0xf6, 0x60, 0xa7, 0xcb, 0x03, 0x31, 0x61, 0x7c, 0x9c, 0xd9, 0x6d, 0xad, 0x3a, 0xc5,
	0x89, 0x50, 0x33, 0x55, 0xa9, 0xf5, 0x02, 0x6a, 0xde, 0x35, 0x06, 0xef, 0xfb, 0x22, 0x62, 0xc1,
	0x54, 0xb3, 0x3f, 0xf0, 0xda, 0xbd, 0x8c, 0xcf, 0x76, 0xbf, 0xef, 0x5f, 0xfc, 0xda, 0x7d, 0xd3,
	0xbe, 0xec, 0x38, 0x16, 0x01, 0xa8, 0x0c, 0x07, 0x9d, 0xb3, 0xce, 0x6f, 0x8e, 0xdd, 0xea, 0x43,
	0xe3, 0x22, 0x46, 0x49, 0x95, 0x30, 0xd4, 0xa6, 0x89, 0x4e, 0x3d, 0x18, 0x7a, 0x5e, 0x67, 0x30,
	0xc8, 0xea, 0xb8, 0xec, 0xbe, 0xe9, 0x5c, 0x0c, 0x2f, 0x33, 0x3f, 0xaf, 0xdd, 0xf3, 0x3a, 0xe7,
	0x8e, 0x6d, 0xb8, 0xea, 0xf4, 0xcf, 0xdb, 0x5e, 0xc7, 0x29, 0x19, 0x61, 0xd8, 0xeb, 0x75, 0x7b,
	0xbf, 0x38, 0xe5, 0xd6, 0x2b, 0xd8, 0xca, 0xd7, 0x4d, 0x53, 0xb0, 0xbc, 0x26, 0xce, 0x06, 0x79,
	0x00, 0x24, 0x23, 0x7c, 0x71, 0x12, 0xb3, 0x26, 0xbd, 0x34, 0x51, 0x62, 0x32, 0xd0, 0x1b, 0xde,
	0x56, 0x4e, 0xd8, 0x7a, 0x0e, 0xdb, 0xc5, 0xe2, 0xe9, 0x14, 0x99, 0x5b, 0x98, 0x55, 0xf5, 0x4e,
	0xc8, 0xf7, 0xfa, 0x4d, 0x9a, 0xd7, 0xee, 0x89, 0x49, 0x1c, 0xa1, 0xb6, 0xd9, 0x27, 0xce, 0xe7,
	0xbf, 0xf7, 0xad, 0x4f, 0xb7, 0xfb, 0xd6, 0xe7, 0xdb, 0x7d, 0xeb, 0xaf, 0xdb, 0x7d, 0x6b, 0x54,
	0x31, 0x7f, 0xad, 0xcf, 0xff, 0x09, 0x00, 0x00, 0xff, 0xff, 0xe3, 0x3d, 0x5f, 0xc3, 0xfc, 0x0a,
	0x00, 0x00,
}

func (m *ResourceEpoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceEpoch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConfVer != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ConfVer))
	}
	if m.Version != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Version))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Replica) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Replica) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
	}
	if m.ContainerID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ContainerID))
	}
	if m.Role != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Role))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ReplicaStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicaStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Replica.Size()))
	n1, err := m.Replica.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if m.DownSeconds != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.DownSeconds))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Pair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResourceStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ResourceID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ResourceID))
	}
	if m.WrittenBytes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.WrittenBytes))
	}
	if m.WrittenKeys != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.WrittenKeys))
	}
	if m.ReadBytes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ReadBytes))
	}
	if m.ReadKeys != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ReadKeys))
	}
	if m.ApproximateSize != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ApproximateSize))
	}
	if m.ApproximateKeys != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ApproximateKeys))
	}
	if m.Interval != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Interval.Size()))
		n2, err := m.Interval.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ContainerStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ContainerID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ContainerID))
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.StartTime))
	}
	if m.Interval != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Interval.Size()))
		n3, err := m.Interval.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Capacity != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Capacity))
	}
	if m.Available != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Available))
	}
	if m.UsedSize != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.UsedSize))
	}
	if m.IsBusy {
		dAtA[i] = 0x38
		i++
		if m.IsBusy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ResourceCount != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ResourceCount))
	}
	if m.SendingSnapCount != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.SendingSnapCount))
	}
	if m.ReceivingSnapCount != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ReceivingSnapCount))
	}
	if m.ApplyingSnapCount != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ApplyingSnapCount))
	}
	if m.WrittenBytes != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.WrittenBytes))
	}
	if m.ReadBytes != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ReadBytes))
	}
	if m.WrittenKeys != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.WrittenKeys))
	}
	if m.ReadKeys != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ReadKeys))
	}
	if len(m.CpuUsages) > 0 {
		for _, msg := range m.CpuUsages {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ReadIORates) > 0 {
		for _, msg := range m.ReadIORates {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.WriteIORates) > 0 {
		for _, msg := range m.WriteIORates {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OpLatencies) > 0 {
		for _, msg := range m.OpLatencies {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RecordPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordPair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Value != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Member) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Member) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Addr) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Addr)))
		i += copy(dAtA[i:], m.Addr)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
	}
	if m.MaxReplicaCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.MaxReplicaCount))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TimeInterval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeInterval) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Start != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.End))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Job) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Job) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Type))
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if m.State != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RemoveResourceJob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveResourceJob) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
	}
	if len(m.Replicass) > 0 {
		for _, msg := range m.Replicass {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResourcePoolJob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourcePoolJob) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for _, msg := range m.Pools {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResourcePool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourcePool) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Group != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Group))
	}
	if m.Capacity != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Capacity))
	}
	if len(m.RangePrefix) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.RangePrefix)))
		i += copy(dAtA[i:], m.RangePrefix)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintMetapb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ResourceEpoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfVer != 0 {
		n += 1 + sovMetapb(uint64(m.ConfVer))
	}
	if m.Version != 0 {
		n += 1 + sovMetapb(uint64(m.Version))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Replica) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMetapb(uint64(m.ID))
	}
	if m.ContainerID != 0 {
		n += 1 + sovMetapb(uint64(m.ContainerID))
	}
	if m.Role != 0 {
		n += 1 + sovMetapb(uint64(m.Role))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReplicaStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Replica.Size()
	n += 1 + l + sovMetapb(uint64(l))
	if m.DownSeconds != 0 {
		n += 1 + sovMetapb(uint64(m.DownSeconds))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Pair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourceStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResourceID != 0 {
		n += 1 + sovMetapb(uint64(m.ResourceID))
	}
	if m.WrittenBytes != 0 {
		n += 1 + sovMetapb(uint64(m.WrittenBytes))
	}
	if m.WrittenKeys != 0 {
		n += 1 + sovMetapb(uint64(m.WrittenKeys))
	}
	if m.ReadBytes != 0 {
		n += 1 + sovMetapb(uint64(m.ReadBytes))
	}
	if m.ReadKeys != 0 {
		n += 1 + sovMetapb(uint64(m.ReadKeys))
	}
	if m.ApproximateSize != 0 {
		n += 1 + sovMetapb(uint64(m.ApproximateSize))
	}
	if m.ApproximateKeys != 0 {
		n += 1 + sovMetapb(uint64(m.ApproximateKeys))
	}
	if m.Interval != nil {
		l = m.Interval.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ContainerStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContainerID != 0 {
		n += 1 + sovMetapb(uint64(m.ContainerID))
	}
	if m.StartTime != 0 {
		n += 1 + sovMetapb(uint64(m.StartTime))
	}
	if m.Interval != nil {
		l = m.Interval.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.Capacity != 0 {
		n += 1 + sovMetapb(uint64(m.Capacity))
	}
	if m.Available != 0 {
		n += 1 + sovMetapb(uint64(m.Available))
	}
	if m.UsedSize != 0 {
		n += 1 + sovMetapb(uint64(m.UsedSize))
	}
	if m.IsBusy {
		n += 2
	}
	if m.ResourceCount != 0 {
		n += 1 + sovMetapb(uint64(m.ResourceCount))
	}
	if m.SendingSnapCount != 0 {
		n += 1 + sovMetapb(uint64(m.SendingSnapCount))
	}
	if m.ReceivingSnapCount != 0 {
		n += 1 + sovMetapb(uint64(m.ReceivingSnapCount))
	}
	if m.ApplyingSnapCount != 0 {
		n += 1 + sovMetapb(uint64(m.ApplyingSnapCount))
	}
	if m.WrittenBytes != 0 {
		n += 1 + sovMetapb(uint64(m.WrittenBytes))
	}
	if m.ReadBytes != 0 {
		n += 1 + sovMetapb(uint64(m.ReadBytes))
	}
	if m.WrittenKeys != 0 {
		n += 1 + sovMetapb(uint64(m.WrittenKeys))
	}
	if m.ReadKeys != 0 {
		n += 1 + sovMetapb(uint64(m.ReadKeys))
	}
	if len(m.CpuUsages) > 0 {
		for _, e := range m.CpuUsages {
			l = e.Size()
			n += 2 + l + sovMetapb(uint64(l))
		}
	}
	if len(m.ReadIORates) > 0 {
		for _, e := range m.ReadIORates {
			l = e.Size()
			n += 2 + l + sovMetapb(uint64(l))
		}
	}
	if len(m.WriteIORates) > 0 {
		for _, e := range m.WriteIORates {
			l = e.Size()
			n += 2 + l + sovMetapb(uint64(l))
		}
	}
	if len(m.OpLatencies) > 0 {
		for _, e := range m.OpLatencies {
			l = e.Size()
			n += 2 + l + sovMetapb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecordPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovMetapb(uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Member) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMetapb(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMetapb(uint64(m.ID))
	}
	if m.MaxReplicaCount != 0 {
		n += 1 + sovMetapb(uint64(m.MaxReplicaCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TimeInterval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovMetapb(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovMetapb(uint64(m.End))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Job) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMetapb(uint64(m.Type))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovMetapb(uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoveResourceJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMetapb(uint64(m.ID))
	}
	if len(m.Replicass) > 0 {
		for _, e := range m.Replicass {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourcePoolJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for _, e := range m.Pools {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResourcePool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Group != 0 {
		n += 1 + sovMetapb(uint64(m.Group))
	}
	if m.Capacity != 0 {
		n += 1 + sovMetapb(uint64(m.Capacity))
	}
	l = len(m.RangePrefix)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMetapb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMetapb(x uint64) (n int) {
	return sovMetapb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ResourceEpoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfVer", wireType)
			}
			m.ConfVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfVer |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Replica) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Replica: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Replica: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerID", wireType)
			}
			m.ContainerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= ReplicaRole(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicaStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicaStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicaStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Replica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownSeconds", wireType)
			}
			m.DownSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownSeconds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceID", wireType)
			}
			m.ResourceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResourceID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WrittenBytes", wireType)
			}
			m.WrittenBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WrittenBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WrittenKeys", wireType)
			}
			m.WrittenKeys = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WrittenKeys |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadBytes", wireType)
			}
			m.ReadBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadKeys", wireType)
			}
			m.ReadKeys = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadKeys |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproximateSize", wireType)
			}
			m.ApproximateSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApproximateSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproximateKeys", wireType)
			}
			m.ApproximateKeys = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApproximateKeys |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interval == nil {
				m.Interval = &TimeInterval{}
			}
			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerID", wireType)
			}
			m.ContainerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interval == nil {
				m.Interval = &TimeInterval{}
			}
			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capacity", wireType)
			}
			m.Capacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Capacity |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Available", wireType)
			}
			m.Available = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Available |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedSize", wireType)
			}
			m.UsedSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBusy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBusy = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceCount", wireType)
			}
			m.ResourceCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResourceCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendingSnapCount", wireType)
			}
			m.SendingSnapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendingSnapCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceivingSnapCount", wireType)
			}
			m.ReceivingSnapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceivingSnapCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyingSnapCount", wireType)
			}
			m.ApplyingSnapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyingSnapCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WrittenBytes", wireType)
			}
			m.WrittenBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WrittenBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadBytes", wireType)
			}
			m.ReadBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WrittenKeys", wireType)
			}
			m.WrittenKeys = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WrittenKeys |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadKeys", wireType)
			}
			m.ReadKeys = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadKeys |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuUsages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuUsages = append(m.CpuUsages, RecordPair{})
			if err := m.CpuUsages[len(m.CpuUsages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadIORates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadIORates = append(m.ReadIORates, RecordPair{})
			if err := m.ReadIORates[len(m.ReadIORates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteIORates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WriteIORates = append(m.WriteIORates, RecordPair{})
			if err := m.WriteIORates[len(m.WriteIORates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpLatencies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpLatencies = append(m.OpLatencies, RecordPair{})
			if err := m.OpLatencies[len(m.OpLatencies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Member) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Member: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Member: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxReplicaCount", wireType)
			}
			m.MaxReplicaCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxReplicaCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeInterval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeInterval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeInterval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Job) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Job: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Job: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= JobType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= JobState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveResourceJob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveResourceJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveResourceJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicass", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replicass = append(m.Replicass, Replica{})
			if err := m.Replicass[len(m.Replicass)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourcePoolJob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourcePoolJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourcePoolJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pools = append(m.Pools, ResourcePool{})
			if err := m.Pools[len(m.Pools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourcePool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourcePool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourcePool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capacity", wireType)
			}
			m.Capacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Capacity |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangePrefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RangePrefix = append(m.RangePrefix[:0], dAtA[iNdEx:postIndex]...)
			if m.RangePrefix == nil {
				m.RangePrefix = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMetapb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMetapb
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthMetapb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMetapb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMetapb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthMetapb
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMetapb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMetapb   = fmt.Errorf("proto: integer overflow")
)
