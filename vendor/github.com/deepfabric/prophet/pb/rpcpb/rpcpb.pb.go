// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rpcpb.proto

package rpcpb

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	metapb "github.com/deepfabric/prophet/pb/metapb"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Type rpc type
type Type int32

const (
	TypeResourceHeartbeatReq  Type = 0
	TypeResourceHeartbeatRsp  Type = 1
	TypeContainerHeartbeatReq Type = 2
	TypeContainerHeartbeatRsp Type = 3
	TypeGetContainerReq       Type = 4
	TypeGetContainerRsp       Type = 5
	TypeAllocIDReq            Type = 6
	TypeAllocIDRsp            Type = 7
	TypeAskSplitReq           Type = 8
	TypeAskSplitRsp           Type = 9
	TypeAskBatchSplitReq      Type = 10
	TypeAskBatchSplitRsp      Type = 11
	TypeReportSplitReq        Type = 12
	TypeReportSplitRsp        Type = 13
	TypeBatchReportSplitReq   Type = 14
	TypeBatchReportSplitRsp   Type = 15
	TypeTSOReq                Type = 16
	TypeTSORsp                Type = 17
	TypeCreateWatcherReq      Type = 18
	TypeEventNotify           Type = 19
	TypeGetDCLocationsReq     Type = 20
	TypeGetDCLocationsRsp     Type = 21
)

var Type_name = map[int32]string{
	0:  "TypeResourceHeartbeatReq",
	1:  "TypeResourceHeartbeatRsp",
	2:  "TypeContainerHeartbeatReq",
	3:  "TypeContainerHeartbeatRsp",
	4:  "TypeGetContainerReq",
	5:  "TypeGetContainerRsp",
	6:  "TypeAllocIDReq",
	7:  "TypeAllocIDRsp",
	8:  "TypeAskSplitReq",
	9:  "TypeAskSplitRsp",
	10: "TypeAskBatchSplitReq",
	11: "TypeAskBatchSplitRsp",
	12: "TypeReportSplitReq",
	13: "TypeReportSplitRsp",
	14: "TypeBatchReportSplitReq",
	15: "TypeBatchReportSplitRsp",
	16: "TypeTSOReq",
	17: "TypeTSORsp",
	18: "TypeCreateWatcherReq",
	19: "TypeEventNotify",
	20: "TypeGetDCLocationsReq",
	21: "TypeGetDCLocationsRsp",
}

var Type_value = map[string]int32{
	"TypeResourceHeartbeatReq":  0,
	"TypeResourceHeartbeatRsp":  1,
	"TypeContainerHeartbeatReq": 2,
	"TypeContainerHeartbeatRsp": 3,
	"TypeGetContainerReq":       4,
	"TypeGetContainerRsp":       5,
	"TypeAllocIDReq":            6,
	"TypeAllocIDRsp":            7,
	"TypeAskSplitReq":           8,
	"TypeAskSplitRsp":           9,
	"TypeAskBatchSplitReq":      10,
	"TypeAskBatchSplitRsp":      11,
	"TypeReportSplitReq":        12,
	"TypeReportSplitRsp":        13,
	"TypeBatchReportSplitReq":   14,
	"TypeBatchReportSplitRsp":   15,
	"TypeTSOReq":                16,
	"TypeTSORsp":                17,
	"TypeCreateWatcherReq":      18,
	"TypeEventNotify":           19,
	"TypeGetDCLocationsReq":     20,
	"TypeGetDCLocationsRsp":     21,
}

func (x Type) String() string {
	return proto.EnumName(Type_name, int32(x))
}

func (Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{0}
}

// Request the prophet rpc request
type Request struct {
	ID                 uint64                `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	ContainerID        uint64                `protobuf:"varint,2,opt,name=containerID,proto3" json:"containerID,omitempty"`
	Type               Type                  `protobuf:"varint,3,opt,name=type,proto3,enum=rpcpb.Type" json:"type,omitempty"`
	ResourceHeartbeat  ResourceHeartbeatReq  `protobuf:"bytes,4,opt,name=ResourceHeartbeat,proto3" json:"ResourceHeartbeat"`
	ContainerHeartbeat ContainerHeartbeatReq `protobuf:"bytes,5,opt,name=ContainerHeartbeat,proto3" json:"ContainerHeartbeat"`
	GetContainer       GetContainerReq       `protobuf:"bytes,6,opt,name=GetContainer,proto3" json:"GetContainer"`
	AllocID            AllocIDReq            `protobuf:"bytes,7,opt,name=AllocID,proto3" json:"AllocID"`
	AskSplit           AskSplitReq           `protobuf:"bytes,8,opt,name=AskSplit,proto3" json:"AskSplit"`
	AskBatchSplit      AskBatchSplitReq      `protobuf:"bytes,9,opt,name=AskBatchSplit,proto3" json:"AskBatchSplit"`
	ReportSplit        ReportSplitReq        `protobuf:"bytes,10,opt,name=ReportSplit,proto3" json:"ReportSplit"`
	BatchReportSplit   BatchReportSplitReq   `protobuf:"bytes,11,opt,name=BatchReportSplit,proto3" json:"BatchReportSplit"`
	TSO                TSOReq                `protobuf:"bytes,12,opt,name=TSO,proto3" json:"TSO"`
	CreateWatcher      CreateWatcherReq      `protobuf:"bytes,13,opt,name=CreateWatcher,proto3" json:"CreateWatcher"`
	GetDCLocations     GetDCLocationsReq     `protobuf:"bytes,14,opt,name=GetDCLocations,proto3" json:"GetDCLocations"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{0}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Request) GetContainerID() uint64 {
	if m != nil {
		return m.ContainerID
	}
	return 0
}

func (m *Request) GetType() Type {
	if m != nil {
		return m.Type
	}
	return TypeResourceHeartbeatReq
}

func (m *Request) GetResourceHeartbeat() ResourceHeartbeatReq {
	if m != nil {
		return m.ResourceHeartbeat
	}
	return ResourceHeartbeatReq{}
}

func (m *Request) GetContainerHeartbeat() ContainerHeartbeatReq {
	if m != nil {
		return m.ContainerHeartbeat
	}
	return ContainerHeartbeatReq{}
}

func (m *Request) GetGetContainer() GetContainerReq {
	if m != nil {
		return m.GetContainer
	}
	return GetContainerReq{}
}

func (m *Request) GetAllocID() AllocIDReq {
	if m != nil {
		return m.AllocID
	}
	return AllocIDReq{}
}

func (m *Request) GetAskSplit() AskSplitReq {
	if m != nil {
		return m.AskSplit
	}
	return AskSplitReq{}
}

func (m *Request) GetAskBatchSplit() AskBatchSplitReq {
	if m != nil {
		return m.AskBatchSplit
	}
	return AskBatchSplitReq{}
}

func (m *Request) GetReportSplit() ReportSplitReq {
	if m != nil {
		return m.ReportSplit
	}
	return ReportSplitReq{}
}

func (m *Request) GetBatchReportSplit() BatchReportSplitReq {
	if m != nil {
		return m.BatchReportSplit
	}
	return BatchReportSplitReq{}
}

func (m *Request) GetTSO() TSOReq {
	if m != nil {
		return m.TSO
	}
	return TSOReq{}
}

func (m *Request) GetCreateWatcher() CreateWatcherReq {
	if m != nil {
		return m.CreateWatcher
	}
	return CreateWatcherReq{}
}

func (m *Request) GetGetDCLocations() GetDCLocationsReq {
	if m != nil {
		return m.GetDCLocations
	}
	return GetDCLocationsReq{}
}

// Response the prophet rpc response
type Response struct {
	ID                 uint64                `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type               Type                  `protobuf:"varint,2,opt,name=type,proto3,enum=rpcpb.Type" json:"type,omitempty"`
	Error              string                `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	Leader             string                `protobuf:"bytes,4,opt,name=leader,proto3" json:"leader,omitempty"`
	ResourceHeartbeat  ResourceHeartbeatRsp  `protobuf:"bytes,5,opt,name=ResourceHeartbeat,proto3" json:"ResourceHeartbeat"`
	ContainerHeartbeat ContainerHeartbeatRsp `protobuf:"bytes,6,opt,name=ContainerHeartbeat,proto3" json:"ContainerHeartbeat"`
	GetContainer       GetContainerRsp       `protobuf:"bytes,7,opt,name=GetContainer,proto3" json:"GetContainer"`
	AllocID            AllocIDRsp            `protobuf:"bytes,8,opt,name=AllocID,proto3" json:"AllocID"`
	AskSplit           AskSplitRsp           `protobuf:"bytes,9,opt,name=AskSplit,proto3" json:"AskSplit"`
	AskBatchSplit      AskBatchSplitRsp      `protobuf:"bytes,10,opt,name=AskBatchSplit,proto3" json:"AskBatchSplit"`
	ReportSplit        ReportSplitRsp        `protobuf:"bytes,11,opt,name=ReportSplit,proto3" json:"ReportSplit"`
	BatchReportSplit   BatchReportSplitRsp   `protobuf:"bytes,12,opt,name=BatchReportSplit,proto3" json:"BatchReportSplit"`
	TSO                TSORsp                `protobuf:"bytes,13,opt,name=TSO,proto3" json:"TSO"`
	Event              EventNotify           `protobuf:"bytes,14,opt,name=Event,proto3" json:"Event"`
	GetDCLocations     GetDCLocationsRsp     `protobuf:"bytes,15,opt,name=GetDCLocations,proto3" json:"GetDCLocations"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{1}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Response) GetType() Type {
	if m != nil {
		return m.Type
	}
	return TypeResourceHeartbeatReq
}

func (m *Response) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *Response) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

func (m *Response) GetResourceHeartbeat() ResourceHeartbeatRsp {
	if m != nil {
		return m.ResourceHeartbeat
	}
	return ResourceHeartbeatRsp{}
}

func (m *Response) GetContainerHeartbeat() ContainerHeartbeatRsp {
	if m != nil {
		return m.ContainerHeartbeat
	}
	return ContainerHeartbeatRsp{}
}

func (m *Response) GetGetContainer() GetContainerRsp {
	if m != nil {
		return m.GetContainer
	}
	return GetContainerRsp{}
}

func (m *Response) GetAllocID() AllocIDRsp {
	if m != nil {
		return m.AllocID
	}
	return AllocIDRsp{}
}

func (m *Response) GetAskSplit() AskSplitRsp {
	if m != nil {
		return m.AskSplit
	}
	return AskSplitRsp{}
}

func (m *Response) GetAskBatchSplit() AskBatchSplitRsp {
	if m != nil {
		return m.AskBatchSplit
	}
	return AskBatchSplitRsp{}
}

func (m *Response) GetReportSplit() ReportSplitRsp {
	if m != nil {
		return m.ReportSplit
	}
	return ReportSplitRsp{}
}

func (m *Response) GetBatchReportSplit() BatchReportSplitRsp {
	if m != nil {
		return m.BatchReportSplit
	}
	return BatchReportSplitRsp{}
}

func (m *Response) GetTSO() TSORsp {
	if m != nil {
		return m.TSO
	}
	return TSORsp{}
}

func (m *Response) GetEvent() EventNotify {
	if m != nil {
		return m.Event
	}
	return EventNotify{}
}

func (m *Response) GetGetDCLocations() GetDCLocationsRsp {
	if m != nil {
		return m.GetDCLocations
	}
	return GetDCLocationsRsp{}
}

// ResourceHeartbeatReq resource heartbeat request
type ResourceHeartbeatReq struct {
	ContainerID uint64 `protobuf:"varint,1,opt,name=containerID,proto3" json:"containerID,omitempty"`
	Resource    []byte `protobuf:"bytes,2,opt,name=resource,proto3" json:"resource,omitempty"`
	// Term is the term of raft group.
	Term         uint64             `protobuf:"varint,3,opt,name=term,proto3" json:"term,omitempty"`
	Leader       *metapb.Peer       `protobuf:"bytes,4,opt,name=leader,proto3" json:"leader,omitempty"`
	DownPeers    []metapb.PeerStats `protobuf:"bytes,5,rep,name=downPeers,proto3" json:"downPeers"`
	PendingPeers []metapb.Peer      `protobuf:"bytes,6,rep,name=pendingPeers,proto3" json:"pendingPeers"`
	// Bytes read/written during this period.
	BytesWritten uint64 `protobuf:"varint,7,opt,name=bytesWritten,proto3" json:"bytesWritten,omitempty"`
	BytesRead    uint64 `protobuf:"varint,8,opt,name=bytesRead,proto3" json:"bytesRead,omitempty"`
	// Keys read/written during this period.
	KeysWritten uint64 `protobuf:"varint,9,opt,name=keysWritten,proto3" json:"keysWritten,omitempty"`
	KeysRead    uint64 `protobuf:"varint,10,opt,name=keysRead,proto3" json:"keysRead,omitempty"`
	// Approximate  resource size in bytes.
	ApproximateSize uint64 `protobuf:"varint,11,opt,name=approximateSize,proto3" json:"approximateSize,omitempty"`
	// Approximate keys that resource contains.
	ApproximateKeys uint64 `protobuf:"varint,12,opt,name=approximateKeys,proto3" json:"approximateKeys,omitempty"`
	// Actually reported time interval
	Interval *TimeInterval `protobuf:"bytes,13,opt,name=interval,proto3" json:"interval,omitempty"`
}

func (m *ResourceHeartbeatReq) Reset()         { *m = ResourceHeartbeatReq{} }
func (m *ResourceHeartbeatReq) String() string { return proto.CompactTextString(m) }
func (*ResourceHeartbeatReq) ProtoMessage()    {}
func (*ResourceHeartbeatReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{2}
}
func (m *ResourceHeartbeatReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceHeartbeatReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceHeartbeatReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceHeartbeatReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceHeartbeatReq.Merge(m, src)
}
func (m *ResourceHeartbeatReq) XXX_Size() int {
	return m.Size()
}
func (m *ResourceHeartbeatReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceHeartbeatReq.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceHeartbeatReq proto.InternalMessageInfo

func (m *ResourceHeartbeatReq) GetContainerID() uint64 {
	if m != nil {
		return m.ContainerID
	}
	return 0
}

func (m *ResourceHeartbeatReq) GetResource() []byte {
	if m != nil {
		return m.Resource
	}
	return nil
}

func (m *ResourceHeartbeatReq) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *ResourceHeartbeatReq) GetLeader() *metapb.Peer {
	if m != nil {
		return m.Leader
	}
	return nil
}

func (m *ResourceHeartbeatReq) GetDownPeers() []metapb.PeerStats {
	if m != nil {
		return m.DownPeers
	}
	return nil
}

func (m *ResourceHeartbeatReq) GetPendingPeers() []metapb.Peer {
	if m != nil {
		return m.PendingPeers
	}
	return nil
}

func (m *ResourceHeartbeatReq) GetBytesWritten() uint64 {
	if m != nil {
		return m.BytesWritten
	}
	return 0
}

func (m *ResourceHeartbeatReq) GetBytesRead() uint64 {
	if m != nil {
		return m.BytesRead
	}
	return 0
}

func (m *ResourceHeartbeatReq) GetKeysWritten() uint64 {
	if m != nil {
		return m.KeysWritten
	}
	return 0
}

func (m *ResourceHeartbeatReq) GetKeysRead() uint64 {
	if m != nil {
		return m.KeysRead
	}
	return 0
}

func (m *ResourceHeartbeatReq) GetApproximateSize() uint64 {
	if m != nil {
		return m.ApproximateSize
	}
	return 0
}

func (m *ResourceHeartbeatReq) GetApproximateKeys() uint64 {
	if m != nil {
		return m.ApproximateKeys
	}
	return 0
}

func (m *ResourceHeartbeatReq) GetInterval() *TimeInterval {
	if m != nil {
		return m.Interval
	}
	return nil
}

// ResourceHeartbeatRsp resource heartbeat response.
type ResourceHeartbeatRsp struct {
	ResourceID    uint64               `protobuf:"varint,1,opt,name=resourceID,proto3" json:"resourceID,omitempty"`
	ResourceEpoch metapb.ResourceEpoch `protobuf:"bytes,2,opt,name=resourceEpoch,proto3" json:"resourceEpoch"`
	// Leader of the resource at the moment of the corresponding request was made.
	TargetPeer *metapb.Peer `protobuf:"bytes,3,opt,name=targetPeer,proto3" json:"targetPeer,omitempty"`
	// Notice, prophet only allows handling reported epoch >= current prophet's.
	// Leader peer reports resource status with ResourceHeartbeatReq
	// to prophet regularly, prophet will determine whether this resource
	// should do ChangePeer or not.
	// E,g, max peer number is 3, resource A, first only peer 1 in A.
	// 1. prophet resource state -> Peers (1), ConfVer (1).
	// 2. Leader peer 1 reports resource state to prophet, prophet finds the
	// peer number is < 3, so first changes its current resource
	// state -> Peers (1, 2), ConfVer (1), and returns ChangePeer Adding 2.
	// 3. Leader does ChangePeer, then reports Peers (1, 2), ConfVer (2),
	// prophet updates its state -> Peers (1, 2), ConfVer (2).
	// 4. Leader may report old Peers (1), ConfVer (1) to pd before ConfChange
	// finished, pd stills responses ChangePeer Adding 2, of course, we must
	// guarantee the second ChangePeer can't be applied in your application.
	ChangePeer     *ChangePeer     `protobuf:"bytes,4,opt,name=changePeer,proto3" json:"changePeer,omitempty"`
	TransferLeader *TransferLeader `protobuf:"bytes,5,opt,name=transferLeader,proto3" json:"transferLeader,omitempty"`
	Merge          *Merge          `protobuf:"bytes,6,opt,name=merge,proto3" json:"merge,omitempty"`
	SplitResource  *SplitResource  `protobuf:"bytes,7,opt,name=splitResource,proto3" json:"splitResource,omitempty"`
	ChangePeerV2   *ChangePeerV2   `protobuf:"bytes,8,opt,name=changePeerV2,proto3" json:"changePeerV2,omitempty"`
}

func (m *ResourceHeartbeatRsp) Reset()         { *m = ResourceHeartbeatRsp{} }
func (m *ResourceHeartbeatRsp) String() string { return proto.CompactTextString(m) }
func (*ResourceHeartbeatRsp) ProtoMessage()    {}
func (*ResourceHeartbeatRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{3}
}
func (m *ResourceHeartbeatRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceHeartbeatRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceHeartbeatRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceHeartbeatRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceHeartbeatRsp.Merge(m, src)
}
func (m *ResourceHeartbeatRsp) XXX_Size() int {
	return m.Size()
}
func (m *ResourceHeartbeatRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceHeartbeatRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceHeartbeatRsp proto.InternalMessageInfo

func (m *ResourceHeartbeatRsp) GetResourceID() uint64 {
	if m != nil {
		return m.ResourceID
	}
	return 0
}

func (m *ResourceHeartbeatRsp) GetResourceEpoch() metapb.ResourceEpoch {
	if m != nil {
		return m.ResourceEpoch
	}
	return metapb.ResourceEpoch{}
}

func (m *ResourceHeartbeatRsp) GetTargetPeer() *metapb.Peer {
	if m != nil {
		return m.TargetPeer
	}
	return nil
}

func (m *ResourceHeartbeatRsp) GetChangePeer() *ChangePeer {
	if m != nil {
		return m.ChangePeer
	}
	return nil
}

func (m *ResourceHeartbeatRsp) GetTransferLeader() *TransferLeader {
	if m != nil {
		return m.TransferLeader
	}
	return nil
}

func (m *ResourceHeartbeatRsp) GetMerge() *Merge {
	if m != nil {
		return m.Merge
	}
	return nil
}

func (m *ResourceHeartbeatRsp) GetSplitResource() *SplitResource {
	if m != nil {
		return m.SplitResource
	}
	return nil
}

func (m *ResourceHeartbeatRsp) GetChangePeerV2() *ChangePeerV2 {
	if m != nil {
		return m.ChangePeerV2
	}
	return nil
}

// ContainerHeartbeatReq container heartbeat request
type ContainerHeartbeatReq struct {
	Stats ContainerStats `protobuf:"bytes,1,opt,name=stats,proto3" json:"stats"`
}

func (m *ContainerHeartbeatReq) Reset()         { *m = ContainerHeartbeatReq{} }
func (m *ContainerHeartbeatReq) String() string { return proto.CompactTextString(m) }
func (*ContainerHeartbeatReq) ProtoMessage()    {}
func (*ContainerHeartbeatReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{4}
}
func (m *ContainerHeartbeatReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerHeartbeatReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerHeartbeatReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerHeartbeatReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerHeartbeatReq.Merge(m, src)
}
func (m *ContainerHeartbeatReq) XXX_Size() int {
	return m.Size()
}
func (m *ContainerHeartbeatReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerHeartbeatReq.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerHeartbeatReq proto.InternalMessageInfo

func (m *ContainerHeartbeatReq) GetStats() ContainerStats {
	if m != nil {
		return m.Stats
	}
	return ContainerStats{}
}

// ContainerHeartbeatRsp container heartbeat response
type ContainerHeartbeatRsp struct {
}

func (m *ContainerHeartbeatRsp) Reset()         { *m = ContainerHeartbeatRsp{} }
func (m *ContainerHeartbeatRsp) String() string { return proto.CompactTextString(m) }
func (*ContainerHeartbeatRsp) ProtoMessage()    {}
func (*ContainerHeartbeatRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{5}
}
func (m *ContainerHeartbeatRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerHeartbeatRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerHeartbeatRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerHeartbeatRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerHeartbeatRsp.Merge(m, src)
}
func (m *ContainerHeartbeatRsp) XXX_Size() int {
	return m.Size()
}
func (m *ContainerHeartbeatRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerHeartbeatRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerHeartbeatRsp proto.InternalMessageInfo

// GetContainerReq get container request
type GetContainerReq struct {
	ID uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *GetContainerReq) Reset()         { *m = GetContainerReq{} }
func (m *GetContainerReq) String() string { return proto.CompactTextString(m) }
func (*GetContainerReq) ProtoMessage()    {}
func (*GetContainerReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{6}
}
func (m *GetContainerReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetContainerReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetContainerReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetContainerReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetContainerReq.Merge(m, src)
}
func (m *GetContainerReq) XXX_Size() int {
	return m.Size()
}
func (m *GetContainerReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetContainerReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetContainerReq proto.InternalMessageInfo

func (m *GetContainerReq) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

// GetContainerRsp get container response
type GetContainerRsp struct {
	Data  []byte          `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Stats *ContainerStats `protobuf:"bytes,2,opt,name=stats,proto3" json:"stats,omitempty"`
}

func (m *GetContainerRsp) Reset()         { *m = GetContainerRsp{} }
func (m *GetContainerRsp) String() string { return proto.CompactTextString(m) }
func (*GetContainerRsp) ProtoMessage()    {}
func (*GetContainerRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{7}
}
func (m *GetContainerRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetContainerRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetContainerRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetContainerRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetContainerRsp.Merge(m, src)
}
func (m *GetContainerRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetContainerRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetContainerRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetContainerRsp proto.InternalMessageInfo

func (m *GetContainerRsp) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *GetContainerRsp) GetStats() *ContainerStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// AllocIDReq alloc id request
type AllocIDReq struct {
}

func (m *AllocIDReq) Reset()         { *m = AllocIDReq{} }
func (m *AllocIDReq) String() string { return proto.CompactTextString(m) }
func (*AllocIDReq) ProtoMessage()    {}
func (*AllocIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{8}
}
func (m *AllocIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllocIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllocIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocIDReq.Merge(m, src)
}
func (m *AllocIDReq) XXX_Size() int {
	return m.Size()
}
func (m *AllocIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_AllocIDReq proto.InternalMessageInfo

// AllocIDRsp alloc id response
type AllocIDRsp struct {
	ID uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *AllocIDRsp) Reset()         { *m = AllocIDRsp{} }
func (m *AllocIDRsp) String() string { return proto.CompactTextString(m) }
func (*AllocIDRsp) ProtoMessage()    {}
func (*AllocIDRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{9}
}
func (m *AllocIDRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocIDRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllocIDRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllocIDRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocIDRsp.Merge(m, src)
}
func (m *AllocIDRsp) XXX_Size() int {
	return m.Size()
}
func (m *AllocIDRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocIDRsp.DiscardUnknown(m)
}

var xxx_messageInfo_AllocIDRsp proto.InternalMessageInfo

func (m *AllocIDRsp) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

// AskSplitReq ask split request
type AskSplitReq struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *AskSplitReq) Reset()         { *m = AskSplitReq{} }
func (m *AskSplitReq) String() string { return proto.CompactTextString(m) }
func (*AskSplitReq) ProtoMessage()    {}
func (*AskSplitReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{10}
}
func (m *AskSplitReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AskSplitReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AskSplitReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AskSplitReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AskSplitReq.Merge(m, src)
}
func (m *AskSplitReq) XXX_Size() int {
	return m.Size()
}
func (m *AskSplitReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AskSplitReq.DiscardUnknown(m)
}

var xxx_messageInfo_AskSplitReq proto.InternalMessageInfo

func (m *AskSplitReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// AskSplitRsp ask split response
type AskSplitRsp struct {
	SplitID SplitID `protobuf:"bytes,1,opt,name=splitID,proto3" json:"splitID"`
}

func (m *AskSplitRsp) Reset()         { *m = AskSplitRsp{} }
func (m *AskSplitRsp) String() string { return proto.CompactTextString(m) }
func (*AskSplitRsp) ProtoMessage()    {}
func (*AskSplitRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{11}
}
func (m *AskSplitRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AskSplitRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AskSplitRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AskSplitRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AskSplitRsp.Merge(m, src)
}
func (m *AskSplitRsp) XXX_Size() int {
	return m.Size()
}
func (m *AskSplitRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_AskSplitRsp.DiscardUnknown(m)
}

var xxx_messageInfo_AskSplitRsp proto.InternalMessageInfo

func (m *AskSplitRsp) GetSplitID() SplitID {
	if m != nil {
		return m.SplitID
	}
	return SplitID{}
}

// ReportSplitReq report split request
type ReportSplitReq struct {
	Left  []byte `protobuf:"bytes,1,opt,name=left,proto3" json:"left,omitempty"`
	Right []byte `protobuf:"bytes,2,opt,name=right,proto3" json:"right,omitempty"`
}

func (m *ReportSplitReq) Reset()         { *m = ReportSplitReq{} }
func (m *ReportSplitReq) String() string { return proto.CompactTextString(m) }
func (*ReportSplitReq) ProtoMessage()    {}
func (*ReportSplitReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{12}
}
func (m *ReportSplitReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportSplitReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportSplitReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportSplitReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportSplitReq.Merge(m, src)
}
func (m *ReportSplitReq) XXX_Size() int {
	return m.Size()
}
func (m *ReportSplitReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportSplitReq.DiscardUnknown(m)
}

var xxx_messageInfo_ReportSplitReq proto.InternalMessageInfo

func (m *ReportSplitReq) GetLeft() []byte {
	if m != nil {
		return m.Left
	}
	return nil
}

func (m *ReportSplitReq) GetRight() []byte {
	if m != nil {
		return m.Right
	}
	return nil
}

// ReportSplitRsp report split response
type ReportSplitRsp struct {
}

func (m *ReportSplitRsp) Reset()         { *m = ReportSplitRsp{} }
func (m *ReportSplitRsp) String() string { return proto.CompactTextString(m) }
func (*ReportSplitRsp) ProtoMessage()    {}
func (*ReportSplitRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{13}
}
func (m *ReportSplitRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportSplitRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportSplitRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportSplitRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportSplitRsp.Merge(m, src)
}
func (m *ReportSplitRsp) XXX_Size() int {
	return m.Size()
}
func (m *ReportSplitRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportSplitRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ReportSplitRsp proto.InternalMessageInfo

// AskBatchSplitReq ask batch split request
type AskBatchSplitReq struct {
	Data  []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Count uint32 `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *AskBatchSplitReq) Reset()         { *m = AskBatchSplitReq{} }
func (m *AskBatchSplitReq) String() string { return proto.CompactTextString(m) }
func (*AskBatchSplitReq) ProtoMessage()    {}
func (*AskBatchSplitReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{14}
}
func (m *AskBatchSplitReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AskBatchSplitReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AskBatchSplitReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AskBatchSplitReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AskBatchSplitReq.Merge(m, src)
}
func (m *AskBatchSplitReq) XXX_Size() int {
	return m.Size()
}
func (m *AskBatchSplitReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AskBatchSplitReq.DiscardUnknown(m)
}

var xxx_messageInfo_AskBatchSplitReq proto.InternalMessageInfo

func (m *AskBatchSplitReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *AskBatchSplitReq) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

// AskBatchSplitRsp ask batch split response
type AskBatchSplitRsp struct {
	SplitIDs []SplitID `protobuf:"bytes,1,rep,name=splitIDs,proto3" json:"splitIDs"`
}

func (m *AskBatchSplitRsp) Reset()         { *m = AskBatchSplitRsp{} }
func (m *AskBatchSplitRsp) String() string { return proto.CompactTextString(m) }
func (*AskBatchSplitRsp) ProtoMessage()    {}
func (*AskBatchSplitRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{15}
}
func (m *AskBatchSplitRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AskBatchSplitRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AskBatchSplitRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AskBatchSplitRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AskBatchSplitRsp.Merge(m, src)
}
func (m *AskBatchSplitRsp) XXX_Size() int {
	return m.Size()
}
func (m *AskBatchSplitRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_AskBatchSplitRsp.DiscardUnknown(m)
}

var xxx_messageInfo_AskBatchSplitRsp proto.InternalMessageInfo

func (m *AskBatchSplitRsp) GetSplitIDs() []SplitID {
	if m != nil {
		return m.SplitIDs
	}
	return nil
}

// BatchReportSplitReq report split request
type BatchReportSplitReq struct {
	Resources [][]byte `protobuf:"bytes,1,rep,name=resources,proto3" json:"resources,omitempty"`
}

func (m *BatchReportSplitReq) Reset()         { *m = BatchReportSplitReq{} }
func (m *BatchReportSplitReq) String() string { return proto.CompactTextString(m) }
func (*BatchReportSplitReq) ProtoMessage()    {}
func (*BatchReportSplitReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{16}
}
func (m *BatchReportSplitReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchReportSplitReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchReportSplitReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchReportSplitReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchReportSplitReq.Merge(m, src)
}
func (m *BatchReportSplitReq) XXX_Size() int {
	return m.Size()
}
func (m *BatchReportSplitReq) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchReportSplitReq.DiscardUnknown(m)
}

var xxx_messageInfo_BatchReportSplitReq proto.InternalMessageInfo

func (m *BatchReportSplitReq) GetResources() [][]byte {
	if m != nil {
		return m.Resources
	}
	return nil
}

// BatchReportSplitRsp report split response
type BatchReportSplitRsp struct {
}

func (m *BatchReportSplitRsp) Reset()         { *m = BatchReportSplitRsp{} }
func (m *BatchReportSplitRsp) String() string { return proto.CompactTextString(m) }
func (*BatchReportSplitRsp) ProtoMessage()    {}
func (*BatchReportSplitRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{17}
}
func (m *BatchReportSplitRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchReportSplitRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchReportSplitRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchReportSplitRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchReportSplitRsp.Merge(m, src)
}
func (m *BatchReportSplitRsp) XXX_Size() int {
	return m.Size()
}
func (m *BatchReportSplitRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchReportSplitRsp.DiscardUnknown(m)
}

var xxx_messageInfo_BatchReportSplitRsp proto.InternalMessageInfo

// SplitID split id
type SplitID struct {
	NewID      uint64   `protobuf:"varint,1,opt,name=newID,proto3" json:"newID,omitempty"`
	NewPeerIDs []uint64 `protobuf:"varint,2,rep,packed,name=newPeerIDs,proto3" json:"newPeerIDs,omitempty"`
}

func (m *SplitID) Reset()         { *m = SplitID{} }
func (m *SplitID) String() string { return proto.CompactTextString(m) }
func (*SplitID) ProtoMessage()    {}
func (*SplitID) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{18}
}
func (m *SplitID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitID.Merge(m, src)
}
func (m *SplitID) XXX_Size() int {
	return m.Size()
}
func (m *SplitID) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitID.DiscardUnknown(m)
}

var xxx_messageInfo_SplitID proto.InternalMessageInfo

func (m *SplitID) GetNewID() uint64 {
	if m != nil {
		return m.NewID
	}
	return 0
}

func (m *SplitID) GetNewPeerIDs() []uint64 {
	if m != nil {
		return m.NewPeerIDs
	}
	return nil
}

// TSOReq get tso request
type TSOReq struct {
	Count uint32 `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
}

func (m *TSOReq) Reset()         { *m = TSOReq{} }
func (m *TSOReq) String() string { return proto.CompactTextString(m) }
func (*TSOReq) ProtoMessage()    {}
func (*TSOReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{19}
}
func (m *TSOReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TSOReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TSOReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TSOReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TSOReq.Merge(m, src)
}
func (m *TSOReq) XXX_Size() int {
	return m.Size()
}
func (m *TSOReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TSOReq.DiscardUnknown(m)
}

var xxx_messageInfo_TSOReq proto.InternalMessageInfo

func (m *TSOReq) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

// TSORsp get tso response
type TSORsp struct {
	Count     uint32            `protobuf:"varint,1,opt,name=count,proto3" json:"count,omitempty"`
	Timestamp *metapb.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *TSORsp) Reset()         { *m = TSORsp{} }
func (m *TSORsp) String() string { return proto.CompactTextString(m) }
func (*TSORsp) ProtoMessage()    {}
func (*TSORsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{20}
}
func (m *TSORsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TSORsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TSORsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TSORsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TSORsp.Merge(m, src)
}
func (m *TSORsp) XXX_Size() int {
	return m.Size()
}
func (m *TSORsp) XXX_DiscardUnknown() {
	xxx_messageInfo_TSORsp.DiscardUnknown(m)
}

var xxx_messageInfo_TSORsp proto.InternalMessageInfo

func (m *TSORsp) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *TSORsp) GetTimestamp() *metapb.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

// CreateWatcherReq create watcher req
type CreateWatcherReq struct {
	Flag uint32 `protobuf:"varint,1,opt,name=flag,proto3" json:"flag,omitempty"`
}

func (m *CreateWatcherReq) Reset()         { *m = CreateWatcherReq{} }
func (m *CreateWatcherReq) String() string { return proto.CompactTextString(m) }
func (*CreateWatcherReq) ProtoMessage()    {}
func (*CreateWatcherReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{21}
}
func (m *CreateWatcherReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateWatcherReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateWatcherReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateWatcherReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateWatcherReq.Merge(m, src)
}
func (m *CreateWatcherReq) XXX_Size() int {
	return m.Size()
}
func (m *CreateWatcherReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateWatcherReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreateWatcherReq proto.InternalMessageInfo

func (m *CreateWatcherReq) GetFlag() uint32 {
	if m != nil {
		return m.Flag
	}
	return 0
}

// GetDCLocationsReq get dc locations request
type GetDCLocationsReq struct {
}

func (m *GetDCLocationsReq) Reset()         { *m = GetDCLocationsReq{} }
func (m *GetDCLocationsReq) String() string { return proto.CompactTextString(m) }
func (*GetDCLocationsReq) ProtoMessage()    {}
func (*GetDCLocationsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{22}
}
func (m *GetDCLocationsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetDCLocationsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetDCLocationsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetDCLocationsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDCLocationsReq.Merge(m, src)
}
func (m *GetDCLocationsReq) XXX_Size() int {
	return m.Size()
}
func (m *GetDCLocationsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDCLocationsReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetDCLocationsReq proto.InternalMessageInfo

// GetDCLocationsRsp get dc locations response
type GetDCLocationsRsp struct {
	DCLocations map[string]int32 `protobuf:"bytes,1,rep,name=dcLocations,proto3" json:"dcLocations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
}

func (m *GetDCLocationsRsp) Reset()         { *m = GetDCLocationsRsp{} }
func (m *GetDCLocationsRsp) String() string { return proto.CompactTextString(m) }
func (*GetDCLocationsRsp) ProtoMessage()    {}
func (*GetDCLocationsRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{23}
}
func (m *GetDCLocationsRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetDCLocationsRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetDCLocationsRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetDCLocationsRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDCLocationsRsp.Merge(m, src)
}
func (m *GetDCLocationsRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetDCLocationsRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDCLocationsRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetDCLocationsRsp proto.InternalMessageInfo

func (m *GetDCLocationsRsp) GetDCLocations() map[string]int32 {
	if m != nil {
		return m.DCLocations
	}
	return nil
}

// EventNotify event notify
type EventNotify struct {
	Seq            uint64              `protobuf:"varint,1,opt,name=seq,proto3" json:"seq,omitempty"`
	Type           uint32              `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	InitEvent      *InitEventData      `protobuf:"bytes,3,opt,name=initEvent,proto3" json:"initEvent,omitempty"`
	ResourceEvent  *ResourceEventData  `protobuf:"bytes,4,opt,name=resourceEvent,proto3" json:"resourceEvent,omitempty"`
	ContainerEvent *ContainerEventData `protobuf:"bytes,5,opt,name=containerEvent,proto3" json:"containerEvent,omitempty"`
}

func (m *EventNotify) Reset()         { *m = EventNotify{} }
func (m *EventNotify) String() string { return proto.CompactTextString(m) }
func (*EventNotify) ProtoMessage()    {}
func (*EventNotify) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{24}
}
func (m *EventNotify) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventNotify) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventNotify.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventNotify) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventNotify.Merge(m, src)
}
func (m *EventNotify) XXX_Size() int {
	return m.Size()
}
func (m *EventNotify) XXX_DiscardUnknown() {
	xxx_messageInfo_EventNotify.DiscardUnknown(m)
}

var xxx_messageInfo_EventNotify proto.InternalMessageInfo

func (m *EventNotify) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *EventNotify) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *EventNotify) GetInitEvent() *InitEventData {
	if m != nil {
		return m.InitEvent
	}
	return nil
}

func (m *EventNotify) GetResourceEvent() *ResourceEventData {
	if m != nil {
		return m.ResourceEvent
	}
	return nil
}

func (m *EventNotify) GetContainerEvent() *ContainerEventData {
	if m != nil {
		return m.ContainerEvent
	}
	return nil
}

// InitEventData init event data
type InitEventData struct {
	Resources  [][]byte `protobuf:"bytes,1,rep,name=resources,proto3" json:"resources,omitempty"`
	Leaders    []uint64 `protobuf:"varint,2,rep,packed,name=leaders,proto3" json:"leaders,omitempty"`
	Containers [][]byte `protobuf:"bytes,3,rep,name=containers,proto3" json:"containers,omitempty"`
}

func (m *InitEventData) Reset()         { *m = InitEventData{} }
func (m *InitEventData) String() string { return proto.CompactTextString(m) }
func (*InitEventData) ProtoMessage()    {}
func (*InitEventData) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{25}
}
func (m *InitEventData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InitEventData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InitEventData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InitEventData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitEventData.Merge(m, src)
}
func (m *InitEventData) XXX_Size() int {
	return m.Size()
}
func (m *InitEventData) XXX_DiscardUnknown() {
	xxx_messageInfo_InitEventData.DiscardUnknown(m)
}

var xxx_messageInfo_InitEventData proto.InternalMessageInfo

func (m *InitEventData) GetResources() [][]byte {
	if m != nil {
		return m.Resources
	}
	return nil
}

func (m *InitEventData) GetLeaders() []uint64 {
	if m != nil {
		return m.Leaders
	}
	return nil
}

func (m *InitEventData) GetContainers() [][]byte {
	if m != nil {
		return m.Containers
	}
	return nil
}

// ResourceEventData resource created or updated
type ResourceEventData struct {
	Data   []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Leader uint64 `protobuf:"varint,2,opt,name=leader,proto3" json:"leader,omitempty"`
}

func (m *ResourceEventData) Reset()         { *m = ResourceEventData{} }
func (m *ResourceEventData) String() string { return proto.CompactTextString(m) }
func (*ResourceEventData) ProtoMessage()    {}
func (*ResourceEventData) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{26}
}
func (m *ResourceEventData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceEventData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceEventData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceEventData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceEventData.Merge(m, src)
}
func (m *ResourceEventData) XXX_Size() int {
	return m.Size()
}
func (m *ResourceEventData) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceEventData.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceEventData proto.InternalMessageInfo

func (m *ResourceEventData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ResourceEventData) GetLeader() uint64 {
	if m != nil {
		return m.Leader
	}
	return 0
}

// ContainerEventData container created or updated
type ContainerEventData struct {
	Data []byte `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *ContainerEventData) Reset()         { *m = ContainerEventData{} }
func (m *ContainerEventData) String() string { return proto.CompactTextString(m) }
func (*ContainerEventData) ProtoMessage()    {}
func (*ContainerEventData) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{27}
}
func (m *ContainerEventData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerEventData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerEventData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerEventData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerEventData.Merge(m, src)
}
func (m *ContainerEventData) XXX_Size() int {
	return m.Size()
}
func (m *ContainerEventData) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerEventData.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerEventData proto.InternalMessageInfo

func (m *ContainerEventData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// ChangePeer change peer
type ChangePeer struct {
	Peer       metapb.Peer           `protobuf:"bytes,1,opt,name=peer,proto3" json:"peer"`
	ChangeType metapb.ChangePeerType `protobuf:"varint,2,opt,name=changeType,proto3,enum=metapb.ChangePeerType" json:"changeType,omitempty"`
}

func (m *ChangePeer) Reset()         { *m = ChangePeer{} }
func (m *ChangePeer) String() string { return proto.CompactTextString(m) }
func (*ChangePeer) ProtoMessage()    {}
func (*ChangePeer) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{28}
}
func (m *ChangePeer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangePeer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangePeer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangePeer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangePeer.Merge(m, src)
}
func (m *ChangePeer) XXX_Size() int {
	return m.Size()
}
func (m *ChangePeer) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangePeer.DiscardUnknown(m)
}

var xxx_messageInfo_ChangePeer proto.InternalMessageInfo

func (m *ChangePeer) GetPeer() metapb.Peer {
	if m != nil {
		return m.Peer
	}
	return metapb.Peer{}
}

func (m *ChangePeer) GetChangeType() metapb.ChangePeerType {
	if m != nil {
		return m.ChangeType
	}
	return metapb.ChangePeerType_AddNode
}

// TransferLeader transfer leader
type TransferLeader struct {
	Peer metapb.Peer `protobuf:"bytes,1,opt,name=peer,proto3" json:"peer"`
}

func (m *TransferLeader) Reset()         { *m = TransferLeader{} }
func (m *TransferLeader) String() string { return proto.CompactTextString(m) }
func (*TransferLeader) ProtoMessage()    {}
func (*TransferLeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{29}
}
func (m *TransferLeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferLeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferLeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferLeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferLeader.Merge(m, src)
}
func (m *TransferLeader) XXX_Size() int {
	return m.Size()
}
func (m *TransferLeader) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferLeader.DiscardUnknown(m)
}

var xxx_messageInfo_TransferLeader proto.InternalMessageInfo

func (m *TransferLeader) GetPeer() metapb.Peer {
	if m != nil {
		return m.Peer
	}
	return metapb.Peer{}
}

// ChangePeerV2 change peer v2
type ChangePeerV2 struct {
	// If changes is empty, it means that to exit joint state.
	Changes []ChangePeer `protobuf:"bytes,1,rep,name=changes,proto3" json:"changes"`
}

func (m *ChangePeerV2) Reset()         { *m = ChangePeerV2{} }
func (m *ChangePeerV2) String() string { return proto.CompactTextString(m) }
func (*ChangePeerV2) ProtoMessage()    {}
func (*ChangePeerV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{30}
}
func (m *ChangePeerV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangePeerV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangePeerV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangePeerV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangePeerV2.Merge(m, src)
}
func (m *ChangePeerV2) XXX_Size() int {
	return m.Size()
}
func (m *ChangePeerV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangePeerV2.DiscardUnknown(m)
}

var xxx_messageInfo_ChangePeerV2 proto.InternalMessageInfo

func (m *ChangePeerV2) GetChanges() []ChangePeer {
	if m != nil {
		return m.Changes
	}
	return nil
}

// Merge merge
type Merge struct {
	// target resource
	Target []byte `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
}

func (m *Merge) Reset()         { *m = Merge{} }
func (m *Merge) String() string { return proto.CompactTextString(m) }
func (*Merge) ProtoMessage()    {}
func (*Merge) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{31}
}
func (m *Merge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Merge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Merge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Merge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Merge.Merge(m, src)
}
func (m *Merge) XXX_Size() int {
	return m.Size()
}
func (m *Merge) XXX_DiscardUnknown() {
	xxx_messageInfo_Merge.DiscardUnknown(m)
}

var xxx_messageInfo_Merge proto.InternalMessageInfo

func (m *Merge) GetTarget() []byte {
	if m != nil {
		return m.Target
	}
	return nil
}

// SplitResource split resource
type SplitResource struct {
	Policy metapb.CheckPolicy `protobuf:"varint,1,opt,name=policy,proto3,enum=metapb.CheckPolicy" json:"policy,omitempty"`
	Keys   [][]byte           `protobuf:"bytes,2,rep,name=keys,proto3" json:"keys,omitempty"`
}

func (m *SplitResource) Reset()         { *m = SplitResource{} }
func (m *SplitResource) String() string { return proto.CompactTextString(m) }
func (*SplitResource) ProtoMessage()    {}
func (*SplitResource) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{32}
}
func (m *SplitResource) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitResource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitResource.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitResource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitResource.Merge(m, src)
}
func (m *SplitResource) XXX_Size() int {
	return m.Size()
}
func (m *SplitResource) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitResource.DiscardUnknown(m)
}

var xxx_messageInfo_SplitResource proto.InternalMessageInfo

func (m *SplitResource) GetPolicy() metapb.CheckPolicy {
	if m != nil {
		return m.Policy
	}
	return metapb.CheckPolicy_SCAN
}

func (m *SplitResource) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

// TimeInterval time interval
type TimeInterval struct {
	// The unix timestamp in seconds of the start of this period.
	Start uint64 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	// The unix timestamp in seconds of the end of this period.
	End uint64 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *TimeInterval) Reset()         { *m = TimeInterval{} }
func (m *TimeInterval) String() string { return proto.CompactTextString(m) }
func (*TimeInterval) ProtoMessage()    {}
func (*TimeInterval) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{33}
}
func (m *TimeInterval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimeInterval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimeInterval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimeInterval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimeInterval.Merge(m, src)
}
func (m *TimeInterval) XXX_Size() int {
	return m.Size()
}
func (m *TimeInterval) XXX_DiscardUnknown() {
	xxx_messageInfo_TimeInterval.DiscardUnknown(m)
}

var xxx_messageInfo_TimeInterval proto.InternalMessageInfo

func (m *TimeInterval) GetStart() uint64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *TimeInterval) GetEnd() uint64 {
	if m != nil {
		return m.End
	}
	return 0
}

// RecordPair record pair
type RecordPair struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value uint64 `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *RecordPair) Reset()         { *m = RecordPair{} }
func (m *RecordPair) String() string { return proto.CompactTextString(m) }
func (*RecordPair) ProtoMessage()    {}
func (*RecordPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{34}
}
func (m *RecordPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecordPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordPair.Merge(m, src)
}
func (m *RecordPair) XXX_Size() int {
	return m.Size()
}
func (m *RecordPair) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordPair.DiscardUnknown(m)
}

var xxx_messageInfo_RecordPair proto.InternalMessageInfo

func (m *RecordPair) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *RecordPair) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// ContainerStats container stats
type ContainerStats struct {
	// Container id
	ContainerID uint64 `protobuf:"varint,1,opt,name=containerID,proto3" json:"containerID,omitempty"`
	// When the container is started (unix timestamp in seconds).
	StartTime uint64 `protobuf:"varint,2,opt,name=startTime,proto3" json:"startTime,omitempty"`
	// Actually reported time interval
	Interval *TimeInterval `protobuf:"bytes,3,opt,name=interval,proto3" json:"interval,omitempty"`
	// Capacity for the container.
	Capacity uint64 `protobuf:"varint,4,opt,name=capacity,proto3" json:"capacity,omitempty"`
	// Available size for the container.
	Available uint64 `protobuf:"varint,5,opt,name=available,proto3" json:"available,omitempty"`
	// Actually used space by db
	UsedSize uint64 `protobuf:"varint,6,opt,name=usedSize,proto3" json:"usedSize,omitempty"`
	// If the container is busy
	IsBusy bool `protobuf:"varint,7,opt,name=isBusy,proto3" json:"isBusy,omitempty"`
	// Total resource count in this container.
	ResourceCount uint64 `protobuf:"varint,8,opt,name=resourceCount,proto3" json:"resourceCount,omitempty"`
	// Current sending snapshot count.
	SendingSnapCount uint64 `protobuf:"varint,9,opt,name=sendingSnapCount,proto3" json:"sendingSnapCount,omitempty"`
	// Current receiving snapshot count.
	ReceivingSnapCount uint64 `protobuf:"varint,10,opt,name=receivingSnapCount,proto3" json:"receivingSnapCount,omitempty"`
	// How many resource is applying snapshot.
	ApplyingSnapCount uint64 `protobuf:"varint,11,opt,name=applyingSnapCount,proto3" json:"applyingSnapCount,omitempty"`
	// Bytes written for the container during this period.
	BytesWritten uint64 `protobuf:"varint,12,opt,name=bytesWritten,proto3" json:"bytesWritten,omitempty"`
	// Bytes read for the container during this period.
	BytesRead uint64 `protobuf:"varint,13,opt,name=bytesRead,proto3" json:"bytesRead,omitempty"`
	// Bytes written for the container during this period.
	KeysWritten uint64 `protobuf:"varint,14,opt,name=keysWritten,proto3" json:"keysWritten,omitempty"`
	// Bytes read for the container during this period.
	KeysRead uint64 `protobuf:"varint,15,opt,name=keysRead,proto3" json:"keysRead,omitempty"`
	// Threads' CPU usages in the container
	CpuUsages []RecordPair `protobuf:"bytes,16,rep,name=cpuUsages,proto3" json:"cpuUsages"`
	// Threads' read disk I/O rates in the container
	ReadIORates []RecordPair `protobuf:"bytes,17,rep,name=readIORates,proto3" json:"readIORates"`
	// Threads' write disk I/O rates in the container
	WriteIORates []RecordPair `protobuf:"bytes,18,rep,name=writeIORates,proto3" json:"writeIORates"`
	// Operations' latencies in the container
	OpLatencies []RecordPair `protobuf:"bytes,19,rep,name=opLatencies,proto3" json:"opLatencies"`
}

func (m *ContainerStats) Reset()         { *m = ContainerStats{} }
func (m *ContainerStats) String() string { return proto.CompactTextString(m) }
func (*ContainerStats) ProtoMessage()    {}
func (*ContainerStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{35}
}
func (m *ContainerStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContainerStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContainerStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContainerStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContainerStats.Merge(m, src)
}
func (m *ContainerStats) XXX_Size() int {
	return m.Size()
}
func (m *ContainerStats) XXX_DiscardUnknown() {
	xxx_messageInfo_ContainerStats.DiscardUnknown(m)
}

var xxx_messageInfo_ContainerStats proto.InternalMessageInfo

func (m *ContainerStats) GetContainerID() uint64 {
	if m != nil {
		return m.ContainerID
	}
	return 0
}

func (m *ContainerStats) GetStartTime() uint64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *ContainerStats) GetInterval() *TimeInterval {
	if m != nil {
		return m.Interval
	}
	return nil
}

func (m *ContainerStats) GetCapacity() uint64 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

func (m *ContainerStats) GetAvailable() uint64 {
	if m != nil {
		return m.Available
	}
	return 0
}

func (m *ContainerStats) GetUsedSize() uint64 {
	if m != nil {
		return m.UsedSize
	}
	return 0
}

func (m *ContainerStats) GetIsBusy() bool {
	if m != nil {
		return m.IsBusy
	}
	return false
}

func (m *ContainerStats) GetResourceCount() uint64 {
	if m != nil {
		return m.ResourceCount
	}
	return 0
}

func (m *ContainerStats) GetSendingSnapCount() uint64 {
	if m != nil {
		return m.SendingSnapCount
	}
	return 0
}

func (m *ContainerStats) GetReceivingSnapCount() uint64 {
	if m != nil {
		return m.ReceivingSnapCount
	}
	return 0
}

func (m *ContainerStats) GetApplyingSnapCount() uint64 {
	if m != nil {
		return m.ApplyingSnapCount
	}
	return 0
}

func (m *ContainerStats) GetBytesWritten() uint64 {
	if m != nil {
		return m.BytesWritten
	}
	return 0
}

func (m *ContainerStats) GetBytesRead() uint64 {
	if m != nil {
		return m.BytesRead
	}
	return 0
}

func (m *ContainerStats) GetKeysWritten() uint64 {
	if m != nil {
		return m.KeysWritten
	}
	return 0
}

func (m *ContainerStats) GetKeysRead() uint64 {
	if m != nil {
		return m.KeysRead
	}
	return 0
}

func (m *ContainerStats) GetCpuUsages() []RecordPair {
	if m != nil {
		return m.CpuUsages
	}
	return nil
}

func (m *ContainerStats) GetReadIORates() []RecordPair {
	if m != nil {
		return m.ReadIORates
	}
	return nil
}

func (m *ContainerStats) GetWriteIORates() []RecordPair {
	if m != nil {
		return m.WriteIORates
	}
	return nil
}

func (m *ContainerStats) GetOpLatencies() []RecordPair {
	if m != nil {
		return m.OpLatencies
	}
	return nil
}

func init() {
	proto.RegisterEnum("rpcpb.Type", Type_name, Type_value)
	proto.RegisterType((*Request)(nil), "rpcpb.Request")
	proto.RegisterType((*Response)(nil), "rpcpb.Response")
	proto.RegisterType((*ResourceHeartbeatReq)(nil), "rpcpb.ResourceHeartbeatReq")
	proto.RegisterType((*ResourceHeartbeatRsp)(nil), "rpcpb.ResourceHeartbeatRsp")
	proto.RegisterType((*ContainerHeartbeatReq)(nil), "rpcpb.ContainerHeartbeatReq")
	proto.RegisterType((*ContainerHeartbeatRsp)(nil), "rpcpb.ContainerHeartbeatRsp")
	proto.RegisterType((*GetContainerReq)(nil), "rpcpb.GetContainerReq")
	proto.RegisterType((*GetContainerRsp)(nil), "rpcpb.GetContainerRsp")
	proto.RegisterType((*AllocIDReq)(nil), "rpcpb.AllocIDReq")
	proto.RegisterType((*AllocIDRsp)(nil), "rpcpb.AllocIDRsp")
	proto.RegisterType((*AskSplitReq)(nil), "rpcpb.AskSplitReq")
	proto.RegisterType((*AskSplitRsp)(nil), "rpcpb.AskSplitRsp")
	proto.RegisterType((*ReportSplitReq)(nil), "rpcpb.ReportSplitReq")
	proto.RegisterType((*ReportSplitRsp)(nil), "rpcpb.ReportSplitRsp")
	proto.RegisterType((*AskBatchSplitReq)(nil), "rpcpb.AskBatchSplitReq")
	proto.RegisterType((*AskBatchSplitRsp)(nil), "rpcpb.AskBatchSplitRsp")
	proto.RegisterType((*BatchReportSplitReq)(nil), "rpcpb.BatchReportSplitReq")
	proto.RegisterType((*BatchReportSplitRsp)(nil), "rpcpb.BatchReportSplitRsp")
	proto.RegisterType((*SplitID)(nil), "rpcpb.SplitID")
	proto.RegisterType((*TSOReq)(nil), "rpcpb.TSOReq")
	proto.RegisterType((*TSORsp)(nil), "rpcpb.TSORsp")
	proto.RegisterType((*CreateWatcherReq)(nil), "rpcpb.CreateWatcherReq")
	proto.RegisterType((*GetDCLocationsReq)(nil), "rpcpb.GetDCLocationsReq")
	proto.RegisterType((*GetDCLocationsRsp)(nil), "rpcpb.GetDCLocationsRsp")
	proto.RegisterMapType((map[string]int32)(nil), "rpcpb.GetDCLocationsRsp.DcLocationsEntry")
	proto.RegisterType((*EventNotify)(nil), "rpcpb.EventNotify")
	proto.RegisterType((*InitEventData)(nil), "rpcpb.InitEventData")
	proto.RegisterType((*ResourceEventData)(nil), "rpcpb.ResourceEventData")
	proto.RegisterType((*ContainerEventData)(nil), "rpcpb.ContainerEventData")
	proto.RegisterType((*ChangePeer)(nil), "rpcpb.ChangePeer")
	proto.RegisterType((*TransferLeader)(nil), "rpcpb.TransferLeader")
	proto.RegisterType((*ChangePeerV2)(nil), "rpcpb.ChangePeerV2")
	proto.RegisterType((*Merge)(nil), "rpcpb.Merge")
	proto.RegisterType((*SplitResource)(nil), "rpcpb.SplitResource")
	proto.RegisterType((*TimeInterval)(nil), "rpcpb.TimeInterval")
	proto.RegisterType((*RecordPair)(nil), "rpcpb.RecordPair")
	proto.RegisterType((*ContainerStats)(nil), "rpcpb.ContainerStats")
}

func init() { proto.RegisterFile("rpcpb.proto", fileDescriptor_25e491924c678914) }

var fileDescriptor_25e491924c678914 = []byte{
	// 1988 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x58, 0x4b, 0x57, 0xdc, 0xc8,
	0x15, 0xa6, 0x69, 0x75, 0x43, 0xdf, 0x7e, 0x20, 0x0a, 0x8c, 0x65, 0x86, 0x00, 0xd1, 0x71, 0xe6,
	0x30, 0x8f, 0x40, 0xcc, 0x78, 0x9c, 0x89, 0x13, 0xcf, 0x84, 0x87, 0x33, 0x21, 0x71, 0x82, 0x4f,
	0x41, 0x66, 0x36, 0xd9, 0x14, 0xea, 0xa2, 0xd1, 0xa1, 0x91, 0xca, 0xaa, 0x02, 0xa7, 0xb3, 0xcc,
	0x2e, 0xbb, 0xfc, 0x8b, 0xac, 0x33, 0xcb, 0xfc, 0x82, 0x59, 0x7a, 0x99, 0x95, 0x4f, 0x82, 0x77,
	0xf9, 0x15, 0x39, 0xf5, 0x90, 0x4a, 0x52, 0xab, 0x1b, 0x67, 0x45, 0xdf, 0x7b, 0xbf, 0x7b, 0x55,
	0x8f, 0xfb, 0x55, 0x7d, 0x05, 0xb4, 0x13, 0x16, 0xb0, 0xb3, 0x6d, 0x96, 0xc4, 0x22, 0x46, 0x0d,
	0x65, 0xac, 0x3e, 0x1e, 0x84, 0xe2, 0xe2, 0xfa, 0x6c, 0x3b, 0x88, 0xaf, 0x76, 0xfa, 0x94, 0xb2,
	0x73, 0x72, 0x96, 0x84, 0xc1, 0x0e, 0x4b, 0x62, 0x76, 0x41, 0xc5, 0x0e, 0x3b, 0xdb, 0xb9, 0xa2,
	0x82, 0x64, 0x7f, 0x74, 0xf2, 0xea, 0x8f, 0x73, 0x59, 0x83, 0x78, 0x10, 0xef, 0x28, 0xf7, 0xd9,
	0xf5, 0xb9, 0xb2, 0x94, 0xa1, 0x7e, 0x69, 0xb8, 0xff, 0xcf, 0x26, 0xcc, 0x61, 0xfa, 0xea, 0x9a,
	0x72, 0x81, 0x56, 0x60, 0x36, 0xec, 0x7b, 0xb5, 0xcd, 0xda, 0x96, 0xb3, 0xdf, 0xbc, 0x7d, 0xbb,
	0x31, 0x7b, 0x74, 0x88, 0x67, 0xc3, 0x3e, 0xda, 0x84, 0x76, 0x10, 0x47, 0x82, 0x84, 0x11, 0x4d,
	0x8e, 0x0e, 0xbd, 0x59, 0x09, 0xc0, 0x79, 0x17, 0xda, 0x00, 0x47, 0x8c, 0x18, 0xf5, 0xea, 0x9b,
	0xb5, 0xad, 0xde, 0x6e, 0x7b, 0x5b, 0xcf, 0xe6, 0x74, 0xc4, 0x28, 0x56, 0x01, 0x74, 0x0c, 0x8b,
	0x98, 0xf2, 0xf8, 0x3a, 0x09, 0xe8, 0xaf, 0x29, 0x49, 0xc4, 0x19, 0x25, 0xc2, 0x73, 0x36, 0x6b,
	0x5b, 0xed, 0xdd, 0x0f, 0x0c, 0x7a, 0x2c, 0x8e, 0xe9, 0xab, 0x7d, 0xe7, 0xfb, 0xb7, 0x1b, 0x33,
	0x78, 0x3c, 0x17, 0x61, 0x40, 0x07, 0xe9, 0x00, 0x6c, 0xc5, 0x86, 0xaa, 0xb8, 0x66, 0x2a, 0x8e,
	0x03, 0x6c, 0xc9, 0x8a, 0x6c, 0xf4, 0x4b, 0xe8, 0x7c, 0x4d, 0x45, 0x16, 0xf0, 0x9a, 0xaa, 0xda,
	0x8a, 0xa9, 0x96, 0x0f, 0xd9, 0x3a, 0x85, 0x0c, 0xf4, 0x08, 0xe6, 0xf6, 0x86, 0xc3, 0x38, 0x38,
	0x3a, 0xf4, 0xe6, 0x54, 0xf2, 0xa2, 0x49, 0x36, 0x5e, 0x9b, 0x97, 0xe2, 0xd0, 0x63, 0x98, 0xdf,
	0xe3, 0x97, 0x27, 0x6c, 0x18, 0x0a, 0x6f, 0x5e, 0xe5, 0xa0, 0x34, 0xc7, 0xb8, 0x6d, 0x52, 0x86,
	0x44, 0x07, 0xd0, 0xdd, 0xe3, 0x97, 0xfb, 0x44, 0x04, 0x17, 0x3a, 0xb5, 0xa5, 0x52, 0xef, 0xdb,
	0x54, 0x1b, 0xb3, 0xf9, 0xc5, 0x1c, 0xf4, 0x0c, 0xda, 0x98, 0xb2, 0x38, 0x11, 0xba, 0x04, 0xa8,
	0x12, 0xf7, 0xb2, 0xed, 0xc8, 0x22, 0xb6, 0x40, 0x1e, 0x8f, 0x5e, 0x80, 0xab, 0x8a, 0xe5, 0x6b,
	0xb4, 0x55, 0x8d, 0x55, 0x53, 0xa3, 0x1c, 0xb6, 0x85, 0xc6, 0x32, 0xd1, 0x8f, 0xa0, 0x7e, 0x7a,
	0x72, 0xec, 0x75, 0x54, 0x81, 0x6e, 0xda, 0x41, 0x27, 0xc7, 0x36, 0x47, 0xc6, 0xe5, 0xc4, 0x0f,
	0x12, 0x4a, 0x04, 0xfd, 0x56, 0x16, 0xa0, 0x89, 0xd7, 0x2d, 0x4c, 0xbc, 0x10, 0xcb, 0x4d, 0xbc,
	0xe0, 0x47, 0xbf, 0x82, 0xde, 0xd7, 0x54, 0x1c, 0x1e, 0xbc, 0x88, 0x03, 0x22, 0xc2, 0x38, 0xe2,
	0x5e, 0x4f, 0x55, 0xf1, 0xec, 0x56, 0xe7, 0x82, 0xb6, 0x4c, 0x29, 0xcb, 0xff, 0xae, 0x09, 0xf3,
	0x98, 0x72, 0x16, 0x47, 0x9c, 0x4e, 0x64, 0x4f, 0xca, 0x8d, 0xd9, 0x49, 0xdc, 0x58, 0x86, 0x06,
	0x4d, 0x92, 0x38, 0x51, 0xec, 0x69, 0x61, 0x6d, 0xa0, 0x15, 0x68, 0x0e, 0x29, 0xe9, 0xd3, 0x44,
	0xd1, 0xa4, 0x85, 0x8d, 0x55, 0xcd, 0xa4, 0xc6, 0x1d, 0x4c, 0xe2, 0xec, 0xff, 0x65, 0x52, 0xf3,
	0x2e, 0x26, 0x65, 0x25, 0xdf, 0x87, 0x49, 0x73, 0x93, 0x99, 0x94, 0xd5, 0x99, 0xc8, 0xa4, 0xf9,
	0x4a, 0x26, 0x65, 0x79, 0x95, 0x4c, 0x6a, 0x55, 0x33, 0x29, 0x4b, 0x9a, 0xc2, 0x24, 0x98, 0xc2,
	0xa4, 0x2c, 0x7f, 0x3a, 0x93, 0xda, 0x13, 0x99, 0x94, 0x15, 0xb8, 0x93, 0x49, 0x9d, 0xe9, 0x4c,
	0xca, 0x0a, 0x4d, 0x64, 0x52, 0x77, 0x8c, 0x49, 0x59, 0x8e, 0x62, 0xd2, 0x36, 0x34, 0x9e, 0xdf,
	0xd0, 0x48, 0x98, 0xde, 0x4f, 0xd7, 0x4a, 0xf9, 0x7e, 0x1f, 0x8b, 0xf0, 0x7c, 0x64, 0xd0, 0x1a,
	0x56, 0x41, 0x9a, 0x85, 0x69, 0xa4, 0xc9, 0x3e, 0x56, 0x26, 0xcd, 0x5f, 0x1c, 0x58, 0xae, 0x3a,
	0xeb, 0xcb, 0xd7, 0x4c, 0x6d, 0xfc, 0x9a, 0x59, 0x85, 0xf9, 0xc4, 0x64, 0x2a, 0x3a, 0x75, 0x70,
	0x66, 0x23, 0x04, 0x8e, 0xa0, 0xc9, 0x95, 0x22, 0x91, 0x83, 0xd5, 0x6f, 0xf4, 0xb0, 0xc0, 0xa1,
	0xf6, 0x6e, 0x67, 0xdb, 0x5c, 0x95, 0x2f, 0x29, 0x4d, 0x32, 0x46, 0x7d, 0x0e, 0xad, 0x7e, 0xfc,
	0x3a, 0x92, 0x3e, 0xee, 0x35, 0x36, 0xeb, 0xaa, 0xd9, 0x72, 0xc0, 0x13, 0x41, 0x04, 0x37, 0x93,
	0xb1, 0x48, 0xf4, 0x04, 0x3a, 0x8c, 0x46, 0xfd, 0x30, 0x1a, 0xe8, 0xcc, 0xa6, 0xca, 0x2c, 0x7c,
	0x22, 0xed, 0xec, 0x3c, 0x0e, 0xf9, 0xd0, 0x39, 0x1b, 0x09, 0xca, 0xbf, 0x4d, 0x42, 0x21, 0x68,
	0xa4, 0xb8, 0xe1, 0xe0, 0x82, 0x0f, 0xad, 0x41, 0x4b, 0xd9, 0x98, 0x92, 0xbe, 0xea, 0x7f, 0x07,
	0x5b, 0x87, 0x5c, 0xa8, 0x4b, 0x3a, 0xca, 0x0a, 0xb4, 0xf4, 0x42, 0xe5, 0x5c, 0x72, 0xa1, 0xa4,
	0xa9, 0xd2, 0x41, 0x85, 0x33, 0x1b, 0x6d, 0xc1, 0x02, 0x61, 0x2c, 0x89, 0xff, 0x14, 0x5e, 0x11,
	0x41, 0x4f, 0xc2, 0x3f, 0x53, 0xd5, 0xaf, 0x0e, 0x2e, 0xbb, 0x4b, 0xc8, 0xdf, 0xd2, 0x11, 0x57,
	0x5d, 0x59, 0x44, 0x4a, 0x37, 0xda, 0x81, 0xf9, 0x30, 0x12, 0x34, 0xb9, 0x21, 0x43, 0xd3, 0x77,
	0x4b, 0x69, 0xdf, 0x85, 0x57, 0xf4, 0xc8, 0x84, 0x70, 0x06, 0xf2, 0xbf, 0xab, 0x57, 0x35, 0x01,
	0x67, 0x68, 0x1d, 0x20, 0xdd, 0xd2, 0xac, 0x07, 0x72, 0x1e, 0xb4, 0x07, 0xdd, 0xd4, 0x7a, 0xce,
	0xe2, 0xe0, 0x42, 0xf5, 0x81, 0xe4, 0x9a, 0x59, 0x76, 0x9c, 0x0f, 0xa6, 0x64, 0x2d, 0x64, 0xa0,
	0x4f, 0x01, 0x04, 0x49, 0x06, 0x54, 0xc8, 0xfd, 0x50, 0xfd, 0x52, 0xee, 0x8c, 0x5c, 0x1c, 0x3d,
	0x02, 0x08, 0x2e, 0x48, 0x34, 0xa0, 0x0a, 0xed, 0x14, 0xce, 0xa2, 0x83, 0x2c, 0x80, 0x73, 0x20,
	0xf4, 0x0c, 0x7a, 0x22, 0x21, 0x11, 0x3f, 0xa7, 0xc9, 0x0b, 0xdd, 0x7e, 0x8d, 0xc2, 0x81, 0x70,
	0x5a, 0x08, 0xe2, 0x12, 0x18, 0xf9, 0xd0, 0xb8, 0xa2, 0xc9, 0x80, 0x9a, 0x33, 0xb8, 0x63, 0xb2,
	0x7e, 0x27, 0x7d, 0x58, 0x87, 0xd0, 0x53, 0xe8, 0x72, 0x7d, 0xa3, 0x1a, 0x3a, 0xe8, 0x13, 0x76,
	0xd9, 0x60, 0x4f, 0xf2, 0x31, 0x5c, 0x84, 0xa2, 0x9f, 0x42, 0xc7, 0x0e, 0xf6, 0x9b, 0x5d, 0x73,
	0xbe, 0x2e, 0x8d, 0xcd, 0xe9, 0x9b, 0x5d, 0x5c, 0x00, 0xfa, 0xbf, 0x81, 0x7b, 0x95, 0x92, 0x0a,
	0x3d, 0x82, 0x06, 0x97, 0x24, 0x51, 0xfb, 0x65, 0xe7, 0x99, 0x81, 0xf3, 0x0c, 0xd2, 0x48, 0xff,
	0x7e, 0x65, 0x2d, 0xce, 0xfc, 0x8f, 0x60, 0xa1, 0xa4, 0xb4, 0x26, 0xdd, 0xac, 0x3e, 0x2e, 0x41,
	0x39, 0x93, 0xa7, 0x40, 0x9f, 0x08, 0xa2, 0xc0, 0x1d, 0xac, 0x7e, 0xa3, 0x4f, 0xd2, 0xd1, 0xcd,
	0x4e, 0x19, 0x5d, 0x3a, 0xae, 0x0e, 0x80, 0xd5, 0x6a, 0xfe, 0x43, 0x6b, 0x71, 0x36, 0x71, 0x1c,
	0x3f, 0x84, 0x76, 0x4e, 0xab, 0x55, 0x8d, 0xc1, 0x7f, 0x96, 0x83, 0x70, 0x86, 0xb6, 0x61, 0x4e,
	0xed, 0x89, 0x69, 0xf1, 0xf6, 0x6e, 0x2f, 0xbf, 0x71, 0x47, 0x87, 0xe9, 0xd5, 0x66, 0x40, 0xfe,
	0x53, 0xe8, 0x15, 0x65, 0x94, 0xfc, 0xc8, 0x90, 0x9e, 0x8b, 0xf4, 0x23, 0xf2, 0xb7, 0x14, 0x12,
	0x49, 0x38, 0xb8, 0x10, 0xe6, 0x6c, 0xd4, 0x86, 0xef, 0x16, 0x73, 0x39, 0xf3, 0x7f, 0x01, 0x6e,
	0x59, 0x20, 0x56, 0x2e, 0xdc, 0x32, 0x34, 0x82, 0xf8, 0x3a, 0xd2, 0xf5, 0xba, 0x58, 0x1b, 0xfe,
	0x61, 0x39, 0x9b, 0x33, 0xf4, 0x13, 0x98, 0x37, 0x43, 0x95, 0x3d, 0x50, 0x9f, 0x38, 0xa1, 0x0c,
	0xe5, 0x7f, 0x06, 0x4b, 0x15, 0xea, 0x50, 0x1e, 0x7c, 0x29, 0x59, 0x75, 0xa5, 0x0e, 0xb6, 0x0e,
	0xff, 0x5e, 0x45, 0x12, 0x67, 0xfe, 0x57, 0x30, 0x67, 0x3e, 0x23, 0x87, 0x1c, 0xd1, 0xd7, 0xd9,
	0xc9, 0xa1, 0x0d, 0x79, 0xa8, 0x44, 0xf4, 0xb5, 0xec, 0x62, 0x39, 0xc0, 0xd9, 0xcd, 0xba, 0x3c,
	0x54, 0xac, 0xc7, 0x5f, 0x87, 0xa6, 0x56, 0x9a, 0x76, 0xca, 0xb5, 0xfc, 0x94, 0x8f, 0x75, 0x9c,
	0xb3, 0xea, 0x38, 0xda, 0x81, 0x96, 0x08, 0xaf, 0x28, 0x17, 0xe4, 0x8a, 0x99, 0x2e, 0xcb, 0x6e,
	0x90, 0xd3, 0x34, 0x80, 0x2d, 0xc6, 0xff, 0x10, 0xdc, 0xb2, 0x52, 0x95, 0x3b, 0x70, 0x3e, 0x24,
	0x03, 0x53, 0x59, 0xfd, 0xf6, 0x97, 0x60, 0x71, 0x4c, 0x8b, 0xfa, 0xff, 0xa8, 0x8d, 0x79, 0x39,
	0x43, 0x7f, 0x84, 0x76, 0x3f, 0xb0, 0x77, 0xb3, 0xde, 0x85, 0x8f, 0x26, 0xdd, 0xcd, 0xdb, 0x87,
	0x16, 0xfb, 0x3c, 0x12, 0xc9, 0x68, 0x7f, 0xe1, 0xf6, 0xed, 0x46, 0x3b, 0x0f, 0xca, 0x97, 0x5b,
	0xfd, 0x12, 0xdc, 0x72, 0x06, 0x72, 0xa1, 0x7e, 0x49, 0x47, 0x6a, 0xbc, 0x2d, 0x2c, 0x7f, 0xca,
	0xd5, 0xb9, 0x21, 0xc3, 0x6b, 0x7d, 0x39, 0x37, 0xb0, 0x36, 0x9e, 0xce, 0x7e, 0x51, 0xf3, 0xff,
	0x5b, 0x83, 0x76, 0x4e, 0x59, 0xc8, 0x5c, 0x4e, 0x5f, 0x99, 0x5d, 0x92, 0x3f, 0xd5, 0xfd, 0x9d,
	0xca, 0xe4, 0xae, 0x51, 0xc6, 0xbb, 0xd0, 0x0a, 0xa3, 0x50, 0x68, 0x99, 0x52, 0x2f, 0x9c, 0x70,
	0x47, 0xa9, 0xff, 0x90, 0x08, 0x82, 0x2d, 0x0c, 0x7d, 0x99, 0xbb, 0x20, 0x54, 0x9e, 0x53, 0x50,
	0x29, 0x38, 0x1f, 0x53, 0xb9, 0x45, 0x38, 0xda, 0x83, 0x5e, 0x26, 0x39, 0x74, 0x01, 0x7d, 0x78,
	0x3f, 0x28, 0x1f, 0x1b, 0xb6, 0x42, 0x29, 0xc1, 0x1f, 0x40, 0xb7, 0x30, 0xbc, 0xe9, 0x5d, 0x8d,
	0x3c, 0x98, 0xd3, 0x4a, 0x24, 0x6d, 0xcd, 0xd4, 0x94, 0x7d, 0x9b, 0x95, 0xe6, 0x5e, 0x5d, 0x25,
	0xe6, 0x3c, 0xfe, 0x57, 0xf6, 0x2d, 0x60, 0x3f, 0x56, 0xc5, 0x64, 0xfb, 0x98, 0xd0, 0x8f, 0x77,
	0x63, 0xf9, 0x5b, 0x39, 0xed, 0x3f, 0xb5, 0x82, 0x3f, 0x04, 0xb0, 0x37, 0x03, 0xfa, 0x10, 0x1c,
	0x26, 0xaf, 0xc3, 0xda, 0xf8, 0xe5, 0x69, 0x98, 0xae, 0xe2, 0xe8, 0x49, 0x7a, 0x79, 0x9e, 0xda,
	0x17, 0xd0, 0x4a, 0x8a, 0xb6, 0xf5, 0xd4, 0x63, 0x28, 0x87, 0xf4, 0xbf, 0x80, 0x5e, 0xf1, 0x92,
	0x7c, 0xdf, 0x2f, 0xfa, 0x7b, 0xd0, 0xc9, 0xdf, 0x60, 0xf2, 0x1d, 0xa1, 0xeb, 0xa6, 0x94, 0x18,
	0xbf, 0xbb, 0xd3, 0xc3, 0xd6, 0xe0, 0xfc, 0x0d, 0x68, 0xa8, 0xbb, 0x56, 0xae, 0x9a, 0x16, 0x02,
	0x66, 0x25, 0x8c, 0xe5, 0xbf, 0x84, 0x6e, 0xe1, 0x82, 0x45, 0x9f, 0x40, 0x93, 0xc5, 0xc3, 0x30,
	0xd0, 0x64, 0xe8, 0xed, 0x2e, 0xd9, 0x29, 0xd2, 0xe0, 0xf2, 0xa5, 0x0a, 0x61, 0x03, 0x91, 0xab,
	0x2b, 0xb5, 0x98, 0xda, 0xeb, 0x0e, 0x56, 0xbf, 0xfd, 0x27, 0xd0, 0xc9, 0x0b, 0x25, 0x49, 0x24,
	0x2e, 0x48, 0x22, 0xd2, 0x63, 0x4c, 0x19, 0x92, 0x34, 0x34, 0xea, 0x9b, 0x2d, 0x94, 0x3f, 0xfd,
	0xc7, 0x00, 0x98, 0x06, 0x71, 0xd2, 0x7f, 0x49, 0xc2, 0xe4, 0x2e, 0x42, 0x3a, 0x86, 0x90, 0xfe,
	0x5f, 0x9b, 0xd0, 0x2b, 0xde, 0x7e, 0xef, 0xa1, 0xbd, 0xd7, 0xa0, 0xa5, 0x46, 0x21, 0xc7, 0x69,
	0xca, 0x59, 0x47, 0x41, 0x00, 0xd6, 0xdf, 0x43, 0x00, 0x4a, 0x85, 0x1a, 0x10, 0x46, 0x82, 0x50,
	0x8c, 0x14, 0x43, 0x1d, 0x9c, 0xd9, 0xf2, 0x53, 0xe4, 0x86, 0x84, 0x43, 0x72, 0x36, 0xa4, 0x8a,
	0x7d, 0x0e, 0xb6, 0x0e, 0x99, 0x79, 0xcd, 0x69, 0x5f, 0x09, 0xd7, 0xa6, 0xce, 0x4c, 0x6d, 0xb9,
	0x63, 0x21, 0xdf, 0xbf, 0xe6, 0x23, 0xa5, 0x87, 0xe6, 0xb1, 0xb1, 0xd0, 0x43, 0x7b, 0x28, 0x1c,
	0xa8, 0xe3, 0x5b, 0x6b, 0xea, 0xa2, 0x13, 0x7d, 0x0c, 0x2e, 0xd7, 0x4a, 0xfd, 0x24, 0x22, 0x4c,
	0x03, 0xb5, 0xb8, 0x1e, 0xf3, 0xa3, 0x6d, 0x40, 0x09, 0x0d, 0x68, 0x78, 0x53, 0x40, 0x6b, 0xad,
	0x5d, 0x11, 0x41, 0x9f, 0xc2, 0x22, 0x61, 0x6c, 0x38, 0x2a, 0xc0, 0xb5, 0xee, 0x1e, 0x0f, 0x8c,
	0xbd, 0x11, 0x3a, 0x77, 0xbd, 0x11, 0xba, 0x77, 0xbc, 0x11, 0x7a, 0xd3, 0xdf, 0x08, 0x0b, 0xa5,
	0x37, 0xc2, 0xe7, 0xd0, 0x0a, 0xd8, 0xf5, 0x1f, 0x38, 0x91, 0xbc, 0x71, 0x0b, 0xbc, 0xb1, 0xfd,
	0x96, 0x3e, 0x89, 0x32, 0x24, 0xfa, 0x19, 0xb4, 0x13, 0x4a, 0xfa, 0x47, 0xc7, 0x98, 0x08, 0xca,
	0xbd, 0xc5, 0xe9, 0x89, 0x79, 0x2c, 0xfa, 0x39, 0x74, 0x5e, 0x27, 0xa1, 0xa0, 0x69, 0x2e, 0x9a,
	0x9e, 0x5b, 0x00, 0xcb, 0xef, 0xc6, 0xec, 0x05, 0x11, 0x34, 0x0a, 0x42, 0xca, 0xbd, 0xa5, 0x3b,
	0xbe, 0x9b, 0xc3, 0x7e, 0xfc, 0x77, 0x07, 0x1c, 0x79, 0xe4, 0xa0, 0x35, 0xf0, 0xd4, 0x31, 0x54,
	0xf1, 0x32, 0x75, 0x67, 0x26, 0x47, 0x39, 0x73, 0x6b, 0xe8, 0x07, 0xf0, 0x40, 0x46, 0x2b, 0xc5,
	0xb1, 0x3b, 0x3b, 0x25, 0xcc, 0x99, 0x5b, 0x47, 0xf7, 0x61, 0x49, 0x86, 0x4b, 0xaa, 0xd7, 0x75,
	0x2a, 0x03, 0x9c, 0xb9, 0x0d, 0x84, 0xa0, 0x27, 0x03, 0x56, 0xa8, 0xba, 0xcd, 0xb2, 0x8f, 0x33,
	0x77, 0x0e, 0x2d, 0xc1, 0x82, 0xf2, 0x59, 0x71, 0xea, 0xce, 0x8f, 0x39, 0x39, 0x73, 0x5b, 0xc8,
	0x83, 0x65, 0xe3, 0x2c, 0xc8, 0x42, 0x17, 0xaa, 0x23, 0x9c, 0xb9, 0x6d, 0xb4, 0x02, 0x48, 0xaf,
	0x49, 0x5e, 0xc1, 0xb9, 0x9d, 0x2a, 0x3f, 0x67, 0x6e, 0x17, 0x7d, 0x00, 0xf7, 0xa5, 0xbf, 0x42,
	0xf6, 0xb9, 0xbd, 0x89, 0x41, 0xce, 0xdc, 0x05, 0xd4, 0x03, 0x90, 0x41, 0xad, 0xd1, 0x5c, 0x37,
	0x6f, 0x73, 0xe6, 0x2e, 0xa6, 0x63, 0x2c, 0x4b, 0x2a, 0x17, 0xa5, 0x93, 0xcd, 0x49, 0x0f, 0x77,
	0x09, 0x3d, 0x80, 0x7b, 0x66, 0x5d, 0x8b, 0xca, 0xca, 0x5d, 0x9e, 0x10, 0xe2, 0xcc, 0xbd, 0xb7,
	0xbf, 0xf6, 0xe6, 0x3f, 0xeb, 0x33, 0xdf, 0xdf, 0xae, 0xd7, 0xde, 0xdc, 0xae, 0xd7, 0xfe, 0x7d,
	0xbb, 0x5e, 0xfb, 0xdb, 0xbb, 0xf5, 0x99, 0x37, 0xef, 0xd6, 0x67, 0xfe, 0xf5, 0x6e, 0x7d, 0xe6,
	0xac, 0xa9, 0xfe, 0x9d, 0xfe, 0xd9, 0xff, 0x02, 0x00, 0x00, 0xff, 0xff, 0xe7, 0xa8, 0xeb, 0xd4,
	0xc9, 0x17, 0x00, 0x00,
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.GetDCLocations.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	{
		size, err := m.CreateWatcher.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size, err := m.TSO.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size, err := m.BatchReportSplit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size, err := m.ReportSplit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size, err := m.AskBatchSplit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.AskSplit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.AllocID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.GetContainer.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.ContainerHeartbeat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.ResourceHeartbeat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.Type != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.ContainerID != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ContainerID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.GetDCLocations.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	{
		size, err := m.Event.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	{
		size, err := m.TSO.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size, err := m.BatchReportSplit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size, err := m.ReportSplit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size, err := m.AskBatchSplit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size, err := m.AskSplit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.AllocID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.GetContainer.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.ContainerHeartbeat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.ResourceHeartbeat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.Leader) > 0 {
		i -= len(m.Leader)
		copy(dAtA[i:], m.Leader)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Leader)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResourceHeartbeatReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceHeartbeatReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceHeartbeatReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Interval != nil {
		{
			size, err := m.Interval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.ApproximateKeys != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ApproximateKeys))
		i--
		dAtA[i] = 0x60
	}
	if m.ApproximateSize != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ApproximateSize))
		i--
		dAtA[i] = 0x58
	}
	if m.KeysRead != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.KeysRead))
		i--
		dAtA[i] = 0x50
	}
	if m.KeysWritten != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.KeysWritten))
		i--
		dAtA[i] = 0x48
	}
	if m.BytesRead != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.BytesRead))
		i--
		dAtA[i] = 0x40
	}
	if m.BytesWritten != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.BytesWritten))
		i--
		dAtA[i] = 0x38
	}
	if len(m.PendingPeers) > 0 {
		for iNdEx := len(m.PendingPeers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PendingPeers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpcpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.DownPeers) > 0 {
		for iNdEx := len(m.DownPeers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DownPeers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpcpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Leader != nil {
		{
			size, err := m.Leader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Term != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Resource) > 0 {
		i -= len(m.Resource)
		copy(dAtA[i:], m.Resource)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Resource)))
		i--
		dAtA[i] = 0x12
	}
	if m.ContainerID != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ContainerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResourceHeartbeatRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceHeartbeatRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceHeartbeatRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ChangePeerV2 != nil {
		{
			size, err := m.ChangePeerV2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.SplitResource != nil {
		{
			size, err := m.SplitResource.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Merge != nil {
		{
			size, err := m.Merge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.TransferLeader != nil {
		{
			size, err := m.TransferLeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ChangePeer != nil {
		{
			size, err := m.ChangePeer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.TargetPeer != nil {
		{
			size, err := m.TargetPeer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.ResourceEpoch.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.ResourceID != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ResourceID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ContainerHeartbeatReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerHeartbeatReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerHeartbeatReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ContainerHeartbeatRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerHeartbeatRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerHeartbeatRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetContainerReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetContainerReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetContainerReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetContainerRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetContainerRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetContainerRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AllocIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllocIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *AllocIDRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocIDRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllocIDRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AskSplitReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AskSplitReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AskSplitReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AskSplitRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AskSplitRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AskSplitRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.SplitID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ReportSplitReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportSplitReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportSplitReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Right) > 0 {
		i -= len(m.Right)
		copy(dAtA[i:], m.Right)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Right)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Left) > 0 {
		i -= len(m.Left)
		copy(dAtA[i:], m.Left)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Left)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReportSplitRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportSplitRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportSplitRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *AskBatchSplitReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AskBatchSplitReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AskBatchSplitReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AskBatchSplitRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AskBatchSplitRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AskBatchSplitRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SplitIDs) > 0 {
		for iNdEx := len(m.SplitIDs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SplitIDs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpcpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BatchReportSplitReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchReportSplitReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchReportSplitReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for iNdEx := len(m.Resources) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Resources[iNdEx])
			copy(dAtA[i:], m.Resources[iNdEx])
			i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Resources[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BatchReportSplitRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchReportSplitRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchReportSplitRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *SplitID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SplitID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewPeerIDs) > 0 {
		dAtA36 := make([]byte, len(m.NewPeerIDs)*10)
		var j35 int
		for _, num := range m.NewPeerIDs {
			for num >= 1<<7 {
				dAtA36[j35] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j35++
			}
			dAtA36[j35] = uint8(num)
			j35++
		}
		i -= j35
		copy(dAtA[i:], dAtA36[:j35])
		i = encodeVarintRpcpb(dAtA, i, uint64(j35))
		i--
		dAtA[i] = 0x12
	}
	if m.NewID != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.NewID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TSOReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TSOReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TSOReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Count != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TSORsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TSORsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TSORsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != nil {
		{
			size, err := m.Timestamp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Count != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateWatcherReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateWatcherReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateWatcherReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Flag != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Flag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetDCLocationsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDCLocationsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetDCLocationsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *GetDCLocationsRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDCLocationsRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetDCLocationsRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DCLocations) > 0 {
		for k := range m.DCLocations {
			v := m.DCLocations[k]
			baseI := i
			i = encodeVarintRpcpb(dAtA, i, uint64(v))
			i--
			dAtA[i] = 0x10
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintRpcpb(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintRpcpb(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EventNotify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventNotify) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventNotify) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ContainerEvent != nil {
		{
			size, err := m.ContainerEvent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ResourceEvent != nil {
		{
			size, err := m.ResourceEvent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.InitEvent != nil {
		{
			size, err := m.InitEvent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Seq != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InitEventData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitEventData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InitEventData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Containers) > 0 {
		for iNdEx := len(m.Containers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Containers[iNdEx])
			copy(dAtA[i:], m.Containers[iNdEx])
			i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Containers[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Leaders) > 0 {
		dAtA42 := make([]byte, len(m.Leaders)*10)
		var j41 int
		for _, num := range m.Leaders {
			for num >= 1<<7 {
				dAtA42[j41] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j41++
			}
			dAtA42[j41] = uint8(num)
			j41++
		}
		i -= j41
		copy(dAtA[i:], dAtA42[:j41])
		i = encodeVarintRpcpb(dAtA, i, uint64(j41))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Resources) > 0 {
		for iNdEx := len(m.Resources) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Resources[iNdEx])
			copy(dAtA[i:], m.Resources[iNdEx])
			i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Resources[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ResourceEventData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceEventData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceEventData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Leader != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Leader))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContainerEventData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerEventData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerEventData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChangePeer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangePeer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangePeer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ChangeType != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ChangeType))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TransferLeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferLeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferLeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	{
		size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ChangePeerV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangePeerV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangePeerV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for iNdEx := len(m.Changes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Changes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpcpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Merge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Merge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Merge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Target) > 0 {
		i -= len(m.Target)
		copy(dAtA[i:], m.Target)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Target)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SplitResource) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitResource) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SplitResource) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Policy != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Policy))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TimeInterval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeInterval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimeInterval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RecordPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecordPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Value != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContainerStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContainerStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContainerStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OpLatencies) > 0 {
		for iNdEx := len(m.OpLatencies) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.OpLatencies[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpcpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x9a
		}
	}
	if len(m.WriteIORates) > 0 {
		for iNdEx := len(m.WriteIORates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.WriteIORates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpcpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x92
		}
	}
	if len(m.ReadIORates) > 0 {
		for iNdEx := len(m.ReadIORates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ReadIORates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpcpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x8a
		}
	}
	if len(m.CpuUsages) > 0 {
		for iNdEx := len(m.CpuUsages) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.CpuUsages[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpcpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1
			i--
			dAtA[i] = 0x82
		}
	}
	if m.KeysRead != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.KeysRead))
		i--
		dAtA[i] = 0x78
	}
	if m.KeysWritten != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.KeysWritten))
		i--
		dAtA[i] = 0x70
	}
	if m.BytesRead != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.BytesRead))
		i--
		dAtA[i] = 0x68
	}
	if m.BytesWritten != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.BytesWritten))
		i--
		dAtA[i] = 0x60
	}
	if m.ApplyingSnapCount != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ApplyingSnapCount))
		i--
		dAtA[i] = 0x58
	}
	if m.ReceivingSnapCount != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ReceivingSnapCount))
		i--
		dAtA[i] = 0x50
	}
	if m.SendingSnapCount != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.SendingSnapCount))
		i--
		dAtA[i] = 0x48
	}
	if m.ResourceCount != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ResourceCount))
		i--
		dAtA[i] = 0x40
	}
	if m.IsBusy {
		i--
		if m.IsBusy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.UsedSize != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.UsedSize))
		i--
		dAtA[i] = 0x30
	}
	if m.Available != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Available))
		i--
		dAtA[i] = 0x28
	}
	if m.Capacity != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Capacity))
		i--
		dAtA[i] = 0x20
	}
	if m.Interval != nil {
		{
			size, err := m.Interval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.StartTime != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.StartTime))
		i--
		dAtA[i] = 0x10
	}
	if m.ContainerID != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ContainerID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintRpcpb(dAtA []byte, offset int, v uint64) int {
	offset -= sovRpcpb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRpcpb(uint64(m.ID))
	}
	if m.ContainerID != 0 {
		n += 1 + sovRpcpb(uint64(m.ContainerID))
	}
	if m.Type != 0 {
		n += 1 + sovRpcpb(uint64(m.Type))
	}
	l = m.ResourceHeartbeat.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.ContainerHeartbeat.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.GetContainer.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.AllocID.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.AskSplit.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.AskBatchSplit.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.ReportSplit.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.BatchReportSplit.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.TSO.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.CreateWatcher.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.GetDCLocations.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRpcpb(uint64(m.ID))
	}
	if m.Type != 0 {
		n += 1 + sovRpcpb(uint64(m.Type))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = m.ResourceHeartbeat.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.ContainerHeartbeat.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.GetContainer.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.AllocID.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.AskSplit.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.AskBatchSplit.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.ReportSplit.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.BatchReportSplit.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.TSO.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.Event.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.GetDCLocations.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	return n
}

func (m *ResourceHeartbeatReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContainerID != 0 {
		n += 1 + sovRpcpb(uint64(m.ContainerID))
	}
	l = len(m.Resource)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Term != 0 {
		n += 1 + sovRpcpb(uint64(m.Term))
	}
	if m.Leader != nil {
		l = m.Leader.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if len(m.DownPeers) > 0 {
		for _, e := range m.DownPeers {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if len(m.PendingPeers) > 0 {
		for _, e := range m.PendingPeers {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.BytesWritten != 0 {
		n += 1 + sovRpcpb(uint64(m.BytesWritten))
	}
	if m.BytesRead != 0 {
		n += 1 + sovRpcpb(uint64(m.BytesRead))
	}
	if m.KeysWritten != 0 {
		n += 1 + sovRpcpb(uint64(m.KeysWritten))
	}
	if m.KeysRead != 0 {
		n += 1 + sovRpcpb(uint64(m.KeysRead))
	}
	if m.ApproximateSize != 0 {
		n += 1 + sovRpcpb(uint64(m.ApproximateSize))
	}
	if m.ApproximateKeys != 0 {
		n += 1 + sovRpcpb(uint64(m.ApproximateKeys))
	}
	if m.Interval != nil {
		l = m.Interval.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	return n
}

func (m *ResourceHeartbeatRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResourceID != 0 {
		n += 1 + sovRpcpb(uint64(m.ResourceID))
	}
	l = m.ResourceEpoch.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.TargetPeer != nil {
		l = m.TargetPeer.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.ChangePeer != nil {
		l = m.ChangePeer.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.TransferLeader != nil {
		l = m.TransferLeader.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Merge != nil {
		l = m.Merge.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.SplitResource != nil {
		l = m.SplitResource.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.ChangePeerV2 != nil {
		l = m.ChangePeerV2.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	return n
}

func (m *ContainerHeartbeatReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Stats.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	return n
}

func (m *ContainerHeartbeatRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetContainerReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRpcpb(uint64(m.ID))
	}
	return n
}

func (m *GetContainerRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	return n
}

func (m *AllocIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *AllocIDRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRpcpb(uint64(m.ID))
	}
	return n
}

func (m *AskSplitReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	return n
}

func (m *AskSplitRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.SplitID.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	return n
}

func (m *ReportSplitReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Left)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = len(m.Right)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	return n
}

func (m *ReportSplitRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *AskBatchSplitReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovRpcpb(uint64(m.Count))
	}
	return n
}

func (m *AskBatchSplitRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SplitIDs) > 0 {
		for _, e := range m.SplitIDs {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	return n
}

func (m *BatchReportSplitReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for _, b := range m.Resources {
			l = len(b)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	return n
}

func (m *BatchReportSplitRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SplitID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewID != 0 {
		n += 1 + sovRpcpb(uint64(m.NewID))
	}
	if len(m.NewPeerIDs) > 0 {
		l = 0
		for _, e := range m.NewPeerIDs {
			l += sovRpcpb(uint64(e))
		}
		n += 1 + sovRpcpb(uint64(l)) + l
	}
	return n
}

func (m *TSOReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovRpcpb(uint64(m.Count))
	}
	return n
}

func (m *TSORsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Count != 0 {
		n += 1 + sovRpcpb(uint64(m.Count))
	}
	if m.Timestamp != nil {
		l = m.Timestamp.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	return n
}

func (m *CreateWatcherReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flag != 0 {
		n += 1 + sovRpcpb(uint64(m.Flag))
	}
	return n
}

func (m *GetDCLocationsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *GetDCLocationsRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.DCLocations) > 0 {
		for k, v := range m.DCLocations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovRpcpb(uint64(len(k))) + 1 + sovRpcpb(uint64(v))
			n += mapEntrySize + 1 + sovRpcpb(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EventNotify) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seq != 0 {
		n += 1 + sovRpcpb(uint64(m.Seq))
	}
	if m.Type != 0 {
		n += 1 + sovRpcpb(uint64(m.Type))
	}
	if m.InitEvent != nil {
		l = m.InitEvent.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.ResourceEvent != nil {
		l = m.ResourceEvent.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.ContainerEvent != nil {
		l = m.ContainerEvent.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	return n
}

func (m *InitEventData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Resources) > 0 {
		for _, b := range m.Resources {
			l = len(b)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if len(m.Leaders) > 0 {
		l = 0
		for _, e := range m.Leaders {
			l += sovRpcpb(uint64(e))
		}
		n += 1 + sovRpcpb(uint64(l)) + l
	}
	if len(m.Containers) > 0 {
		for _, b := range m.Containers {
			l = len(b)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	return n
}

func (m *ResourceEventData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Leader != 0 {
		n += 1 + sovRpcpb(uint64(m.Leader))
	}
	return n
}

func (m *ContainerEventData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	return n
}

func (m *ChangePeer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Peer.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.ChangeType != 0 {
		n += 1 + sovRpcpb(uint64(m.ChangeType))
	}
	return n
}

func (m *TransferLeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Peer.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	return n
}

func (m *ChangePeerV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for _, e := range m.Changes {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	return n
}

func (m *Merge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	return n
}

func (m *SplitResource) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Policy != 0 {
		n += 1 + sovRpcpb(uint64(m.Policy))
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	return n
}

func (m *TimeInterval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovRpcpb(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovRpcpb(uint64(m.End))
	}
	return n
}

func (m *RecordPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovRpcpb(uint64(m.Value))
	}
	return n
}

func (m *ContainerStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContainerID != 0 {
		n += 1 + sovRpcpb(uint64(m.ContainerID))
	}
	if m.StartTime != 0 {
		n += 1 + sovRpcpb(uint64(m.StartTime))
	}
	if m.Interval != nil {
		l = m.Interval.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Capacity != 0 {
		n += 1 + sovRpcpb(uint64(m.Capacity))
	}
	if m.Available != 0 {
		n += 1 + sovRpcpb(uint64(m.Available))
	}
	if m.UsedSize != 0 {
		n += 1 + sovRpcpb(uint64(m.UsedSize))
	}
	if m.IsBusy {
		n += 2
	}
	if m.ResourceCount != 0 {
		n += 1 + sovRpcpb(uint64(m.ResourceCount))
	}
	if m.SendingSnapCount != 0 {
		n += 1 + sovRpcpb(uint64(m.SendingSnapCount))
	}
	if m.ReceivingSnapCount != 0 {
		n += 1 + sovRpcpb(uint64(m.ReceivingSnapCount))
	}
	if m.ApplyingSnapCount != 0 {
		n += 1 + sovRpcpb(uint64(m.ApplyingSnapCount))
	}
	if m.BytesWritten != 0 {
		n += 1 + sovRpcpb(uint64(m.BytesWritten))
	}
	if m.BytesRead != 0 {
		n += 1 + sovRpcpb(uint64(m.BytesRead))
	}
	if m.KeysWritten != 0 {
		n += 1 + sovRpcpb(uint64(m.KeysWritten))
	}
	if m.KeysRead != 0 {
		n += 1 + sovRpcpb(uint64(m.KeysRead))
	}
	if len(m.CpuUsages) > 0 {
		for _, e := range m.CpuUsages {
			l = e.Size()
			n += 2 + l + sovRpcpb(uint64(l))
		}
	}
	if len(m.ReadIORates) > 0 {
		for _, e := range m.ReadIORates {
			l = e.Size()
			n += 2 + l + sovRpcpb(uint64(l))
		}
	}
	if len(m.WriteIORates) > 0 {
		for _, e := range m.WriteIORates {
			l = e.Size()
			n += 2 + l + sovRpcpb(uint64(l))
		}
	}
	if len(m.OpLatencies) > 0 {
		for _, e := range m.OpLatencies {
			l = e.Size()
			n += 2 + l + sovRpcpb(uint64(l))
		}
	}
	return n
}

func sovRpcpb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRpcpb(x uint64) (n int) {
	return sovRpcpb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerID", wireType)
			}
			m.ContainerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceHeartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ContainerHeartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetContainer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetContainer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AllocID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AskSplit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskBatchSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AskBatchSplit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReportSplit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchReportSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BatchReportSplit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TSO", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TSO.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateWatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreateWatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetDCLocations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetDCLocations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceHeartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ContainerHeartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetContainer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetContainer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AllocID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AskSplit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskBatchSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AskBatchSplit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReportSplit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchReportSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BatchReportSplit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TSO", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TSO.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Event.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetDCLocations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetDCLocations.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceHeartbeatReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceHeartbeatReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceHeartbeatReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerID", wireType)
			}
			m.ContainerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resource", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resource = append(m.Resource[:0], dAtA[iNdEx:postIndex]...)
			if m.Resource == nil {
				m.Resource = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Leader == nil {
				m.Leader = &metapb.Peer{}
			}
			if err := m.Leader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownPeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownPeers = append(m.DownPeers, metapb.PeerStats{})
			if err := m.DownPeers[len(m.DownPeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingPeers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PendingPeers = append(m.PendingPeers, metapb.Peer{})
			if err := m.PendingPeers[len(m.PendingPeers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesWritten", wireType)
			}
			m.BytesWritten = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesWritten |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesRead", wireType)
			}
			m.BytesRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesRead |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeysWritten", wireType)
			}
			m.KeysWritten = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeysWritten |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeysRead", wireType)
			}
			m.KeysRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeysRead |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproximateSize", wireType)
			}
			m.ApproximateSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApproximateSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproximateKeys", wireType)
			}
			m.ApproximateKeys = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApproximateKeys |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interval == nil {
				m.Interval = &TimeInterval{}
			}
			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceHeartbeatRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceHeartbeatRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceHeartbeatRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceID", wireType)
			}
			m.ResourceID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResourceID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ResourceEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetPeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TargetPeer == nil {
				m.TargetPeer = &metapb.Peer{}
			}
			if err := m.TargetPeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangePeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangePeer == nil {
				m.ChangePeer = &ChangePeer{}
			}
			if err := m.ChangePeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferLeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransferLeader == nil {
				m.TransferLeader = &TransferLeader{}
			}
			if err := m.TransferLeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Merge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Merge == nil {
				m.Merge = &Merge{}
			}
			if err := m.Merge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitResource", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SplitResource == nil {
				m.SplitResource = &SplitResource{}
			}
			if err := m.SplitResource.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangePeerV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangePeerV2 == nil {
				m.ChangePeerV2 = &ChangePeerV2{}
			}
			if err := m.ChangePeerV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerHeartbeatReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerHeartbeatReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerHeartbeatReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerHeartbeatRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerHeartbeatRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerHeartbeatRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetContainerReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetContainerReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetContainerReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetContainerRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetContainerRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetContainerRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &ContainerStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocIDRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocIDRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocIDRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AskSplitReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AskSplitReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AskSplitReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AskSplitRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AskSplitRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AskSplitRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.SplitID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportSplitReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportSplitReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportSplitReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Left", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Left = append(m.Left[:0], dAtA[iNdEx:postIndex]...)
			if m.Left == nil {
				m.Left = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Right", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Right = append(m.Right[:0], dAtA[iNdEx:postIndex]...)
			if m.Right == nil {
				m.Right = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportSplitRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportSplitRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportSplitRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AskBatchSplitReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AskBatchSplitReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AskBatchSplitReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AskBatchSplitRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AskBatchSplitRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AskBatchSplitRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SplitIDs = append(m.SplitIDs, SplitID{})
			if err := m.SplitIDs[len(m.SplitIDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchReportSplitReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchReportSplitReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchReportSplitReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, make([]byte, postIndex-iNdEx))
			copy(m.Resources[len(m.Resources)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchReportSplitRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchReportSplitRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchReportSplitRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewID", wireType)
			}
			m.NewID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NewPeerIDs = append(m.NewPeerIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRpcpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRpcpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NewPeerIDs) == 0 {
					m.NewPeerIDs = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NewPeerIDs = append(m.NewPeerIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPeerIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TSOReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TSOReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TSOReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TSORsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TSORsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TSORsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timestamp == nil {
				m.Timestamp = &metapb.Timestamp{}
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateWatcherReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateWatcherReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateWatcherReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDCLocationsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDCLocationsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDCLocationsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDCLocationsRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDCLocationsRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDCLocationsRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DCLocations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DCLocations == nil {
				m.DCLocations = make(map[string]int32)
			}
			var mapkey string
			var mapvalue int32
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthRpcpb
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthRpcpb
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvalue |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRpcpb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthRpcpb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.DCLocations[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventNotify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventNotify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventNotify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitEvent == nil {
				m.InitEvent = &InitEventData{}
			}
			if err := m.InitEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResourceEvent == nil {
				m.ResourceEvent = &ResourceEventData{}
			}
			if err := m.ResourceEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContainerEvent == nil {
				m.ContainerEvent = &ContainerEventData{}
			}
			if err := m.ContainerEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitEventData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitEventData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitEventData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Resources", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Resources = append(m.Resources, make([]byte, postIndex-iNdEx))
			copy(m.Resources[len(m.Resources)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Leaders = append(m.Leaders, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRpcpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRpcpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Leaders) == 0 {
					m.Leaders = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Leaders = append(m.Leaders, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Leaders", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Containers", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Containers = append(m.Containers, make([]byte, postIndex-iNdEx))
			copy(m.Containers[len(m.Containers)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceEventData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceEventData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceEventData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			m.Leader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leader |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerEventData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerEventData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerEventData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangePeer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangePeer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangePeer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeType", wireType)
			}
			m.ChangeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeType |= metapb.ChangePeerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferLeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferLeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferLeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangePeerV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangePeerV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangePeerV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changes = append(m.Changes, ChangePeer{})
			if err := m.Changes[len(m.Changes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Merge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Merge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Merge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = append(m.Target[:0], dAtA[iNdEx:postIndex]...)
			if m.Target == nil {
				m.Target = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitResource) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitResource: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitResource: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			m.Policy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Policy |= metapb.CheckPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeInterval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeInterval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeInterval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContainerStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContainerStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContainerStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerID", wireType)
			}
			m.ContainerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interval == nil {
				m.Interval = &TimeInterval{}
			}
			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capacity", wireType)
			}
			m.Capacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Capacity |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Available", wireType)
			}
			m.Available = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Available |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedSize", wireType)
			}
			m.UsedSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBusy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBusy = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceCount", wireType)
			}
			m.ResourceCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResourceCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendingSnapCount", wireType)
			}
			m.SendingSnapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendingSnapCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceivingSnapCount", wireType)
			}
			m.ReceivingSnapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceivingSnapCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyingSnapCount", wireType)
			}
			m.ApplyingSnapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyingSnapCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesWritten", wireType)
			}
			m.BytesWritten = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesWritten |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesRead", wireType)
			}
			m.BytesRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesRead |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeysWritten", wireType)
			}
			m.KeysWritten = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeysWritten |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeysRead", wireType)
			}
			m.KeysRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeysRead |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuUsages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuUsages = append(m.CpuUsages, RecordPair{})
			if err := m.CpuUsages[len(m.CpuUsages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadIORates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadIORates = append(m.ReadIORates, RecordPair{})
			if err := m.ReadIORates[len(m.ReadIORates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteIORates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WriteIORates = append(m.WriteIORates, RecordPair{})
			if err := m.WriteIORates[len(m.WriteIORates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpLatencies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpLatencies = append(m.OpLatencies, RecordPair{})
			if err := m.OpLatencies[len(m.OpLatencies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRpcpb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRpcpb
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRpcpb
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRpcpb
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRpcpb        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRpcpb          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRpcpb = fmt.Errorf("proto: unexpected end of group")
)
