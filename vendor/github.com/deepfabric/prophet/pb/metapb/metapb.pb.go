// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: metapb.proto

package metapb

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Action the action while a new node join the cluster
type Action int32

const (
	Action_None     Action = 0
	Action_ScaleOut Action = 1
)

var Action_name = map[int32]string{
	0: "None",
	1: "ScaleOut",
}

var Action_value = map[string]int32{
	"None":     0,
	"ScaleOut": 1,
}

func (x Action) String() string {
	return proto.EnumName(Action_name, int32(x))
}

func (Action) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{0}
}

// ResourceKind the resource king
type ResourceKind int32

const (
	ResourceKind_LeaderKind  ResourceKind = 0
	ResourceKind_ReplicaKind ResourceKind = 1
)

var ResourceKind_name = map[int32]string{
	0: "LeaderKind",
	1: "ReplicaKind",
}

var ResourceKind_value = map[string]int32{
	"LeaderKind":  0,
	"ReplicaKind": 1,
}

func (x ResourceKind) String() string {
	return proto.EnumName(ResourceKind_name, int32(x))
}

func (ResourceKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{1}
}

// State the container state
type ContainerState int32

const (
	// UP is normal state
	ContainerState_UP ContainerState = 0
	// Offline is the unavailable state
	ContainerState_Offline ContainerState = 1
	// Tombstone is the destory state
	ContainerState_Tombstone ContainerState = 2
)

var ContainerState_name = map[int32]string{
	0: "UP",
	1: "Offline",
	2: "Tombstone",
}

var ContainerState_value = map[string]int32{
	"UP":        0,
	"Offline":   1,
	"Tombstone": 2,
}

func (x ContainerState) String() string {
	return proto.EnumName(ContainerState_name, int32(x))
}

func (ContainerState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{2}
}

// ChangePeerType change peer type
type ChangePeerType int32

const (
	ChangePeerType_AddNode        ChangePeerType = 0
	ChangePeerType_RemoveNode     ChangePeerType = 1
	ChangePeerType_AddLearnerNode ChangePeerType = 2
	ChangePeerType_ScalePeer      ChangePeerType = 3
)

var ChangePeerType_name = map[int32]string{
	0: "AddNode",
	1: "RemoveNode",
	2: "AddLearnerNode",
	3: "ScalePeer",
}

var ChangePeerType_value = map[string]int32{
	"AddNode":        0,
	"RemoveNode":     1,
	"AddLearnerNode": 2,
	"ScalePeer":      3,
}

func (x ChangePeerType) String() string {
	return proto.EnumName(ChangePeerType_name, int32(x))
}

func (ChangePeerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{3}
}

// PeerRole role of current peer
type PeerRole int32

const (
	PeerRole_Voter         PeerRole = 0
	PeerRole_Learner       PeerRole = 1
	PeerRole_IncomingVoter PeerRole = 2
	PeerRole_DemotingVoter PeerRole = 3
)

var PeerRole_name = map[int32]string{
	0: "Voter",
	1: "Learner",
	2: "IncomingVoter",
	3: "DemotingVoter",
}

var PeerRole_value = map[string]int32{
	"Voter":         0,
	"Learner":       1,
	"IncomingVoter": 2,
	"DemotingVoter": 3,
}

func (x PeerRole) String() string {
	return proto.EnumName(PeerRole_name, int32(x))
}

func (PeerRole) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{4}
}

// CheckPolicy check policy
type CheckPolicy int32

const (
	CheckPolicy_SCAN        CheckPolicy = 0
	CheckPolicy_APPROXIMATE CheckPolicy = 1
	CheckPolicy_USEKEY      CheckPolicy = 2
)

var CheckPolicy_name = map[int32]string{
	0: "SCAN",
	1: "APPROXIMATE",
	2: "USEKEY",
}

var CheckPolicy_value = map[string]int32{
	"SCAN":        0,
	"APPROXIMATE": 1,
	"USEKEY":      2,
}

func (x CheckPolicy) String() string {
	return proto.EnumName(CheckPolicy_name, int32(x))
}

func (CheckPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{5}
}

// OperatorStatus Operator Status
type OperatorStatus int32

const (
	OperatorStatus_SUCCESS OperatorStatus = 0
	OperatorStatus_TIMEOUT OperatorStatus = 1
	OperatorStatus_CANCEL  OperatorStatus = 2
	OperatorStatus_REPLACE OperatorStatus = 3
	OperatorStatus_RUNNING OperatorStatus = 4
)

var OperatorStatus_name = map[int32]string{
	0: "SUCCESS",
	1: "TIMEOUT",
	2: "CANCEL",
	3: "REPLACE",
	4: "RUNNING",
}

var OperatorStatus_value = map[string]int32{
	"SUCCESS": 0,
	"TIMEOUT": 1,
	"CANCEL":  2,
	"REPLACE": 3,
	"RUNNING": 4,
}

func (x OperatorStatus) String() string {
	return proto.EnumName(OperatorStatus_name, int32(x))
}

func (OperatorStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{6}
}

// ResourceEpoch resource epoch
type ResourceEpoch struct {
	// Conf change version, auto increment when add or remove peer
	ConfVer uint64 `protobuf:"varint,1,opt,name=confVer,proto3" json:"confVer,omitempty"`
	// Resource version, auto increment when split or merge
	Version uint64 `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *ResourceEpoch) Reset()         { *m = ResourceEpoch{} }
func (m *ResourceEpoch) String() string { return proto.CompactTextString(m) }
func (*ResourceEpoch) ProtoMessage()    {}
func (*ResourceEpoch) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{0}
}
func (m *ResourceEpoch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceEpoch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceEpoch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceEpoch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceEpoch.Merge(m, src)
}
func (m *ResourceEpoch) XXX_Size() int {
	return m.Size()
}
func (m *ResourceEpoch) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceEpoch.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceEpoch proto.InternalMessageInfo

func (m *ResourceEpoch) GetConfVer() uint64 {
	if m != nil {
		return m.ConfVer
	}
	return 0
}

func (m *ResourceEpoch) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

// Peer is a replica of the resource, we called peer
type Peer struct {
	ID          uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	ContainerID uint64   `protobuf:"varint,2,opt,name=containerID,proto3" json:"containerID,omitempty"`
	Role        PeerRole `protobuf:"varint,3,opt,name=role,proto3,enum=metapb.PeerRole" json:"role,omitempty"`
}

func (m *Peer) Reset()         { *m = Peer{} }
func (m *Peer) String() string { return proto.CompactTextString(m) }
func (*Peer) ProtoMessage()    {}
func (*Peer) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{1}
}
func (m *Peer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Peer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Peer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Peer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Peer.Merge(m, src)
}
func (m *Peer) XXX_Size() int {
	return m.Size()
}
func (m *Peer) XXX_DiscardUnknown() {
	xxx_messageInfo_Peer.DiscardUnknown(m)
}

var xxx_messageInfo_Peer proto.InternalMessageInfo

func (m *Peer) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Peer) GetContainerID() uint64 {
	if m != nil {
		return m.ContainerID
	}
	return 0
}

func (m *Peer) GetRole() PeerRole {
	if m != nil {
		return m.Role
	}
	return PeerRole_Voter
}

// PeerStats peer stats
type PeerStats struct {
	Peer        Peer   `protobuf:"bytes,1,opt,name=peer,proto3" json:"peer"`
	DownSeconds uint64 `protobuf:"varint,2,opt,name=downSeconds,proto3" json:"downSeconds,omitempty"`
}

func (m *PeerStats) Reset()         { *m = PeerStats{} }
func (m *PeerStats) String() string { return proto.CompactTextString(m) }
func (*PeerStats) ProtoMessage()    {}
func (*PeerStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{2}
}
func (m *PeerStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PeerStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PeerStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PeerStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PeerStats.Merge(m, src)
}
func (m *PeerStats) XXX_Size() int {
	return m.Size()
}
func (m *PeerStats) XXX_DiscardUnknown() {
	xxx_messageInfo_PeerStats.DiscardUnknown(m)
}

var xxx_messageInfo_PeerStats proto.InternalMessageInfo

func (m *PeerStats) GetPeer() Peer {
	if m != nil {
		return m.Peer
	}
	return Peer{}
}

func (m *PeerStats) GetDownSeconds() uint64 {
	if m != nil {
		return m.DownSeconds
	}
	return 0
}

// Pair key value pair
type Pair struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *Pair) Reset()         { *m = Pair{} }
func (m *Pair) String() string { return proto.CompactTextString(m) }
func (*Pair) ProtoMessage()    {}
func (*Pair) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{3}
}
func (m *Pair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pair.Merge(m, src)
}
func (m *Pair) XXX_Size() int {
	return m.Size()
}
func (m *Pair) XXX_DiscardUnknown() {
	xxx_messageInfo_Pair.DiscardUnknown(m)
}

var xxx_messageInfo_Pair proto.InternalMessageInfo

func (m *Pair) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Pair) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Timestamp tso timestamp
type Timestamp struct {
	Physical int64 `protobuf:"varint,1,opt,name=physical,proto3" json:"physical,omitempty"`
	Logical  int64 `protobuf:"varint,2,opt,name=logical,proto3" json:"logical,omitempty"`
}

func (m *Timestamp) Reset()         { *m = Timestamp{} }
func (m *Timestamp) String() string { return proto.CompactTextString(m) }
func (*Timestamp) ProtoMessage()    {}
func (*Timestamp) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{4}
}
func (m *Timestamp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Timestamp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Timestamp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Timestamp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Timestamp.Merge(m, src)
}
func (m *Timestamp) XXX_Size() int {
	return m.Size()
}
func (m *Timestamp) XXX_DiscardUnknown() {
	xxx_messageInfo_Timestamp.DiscardUnknown(m)
}

var xxx_messageInfo_Timestamp proto.InternalMessageInfo

func (m *Timestamp) GetPhysical() int64 {
	if m != nil {
		return m.Physical
	}
	return 0
}

func (m *Timestamp) GetLogical() int64 {
	if m != nil {
		return m.Logical
	}
	return 0
}

// ResourceStat resource stat
type ResourceStat struct {
	// Bytes written for the container during this period.
	BytesWritten uint64 `protobuf:"varint,1,opt,name=bytesWritten,proto3" json:"bytesWritten,omitempty"`
	// Bytes read for the container during this period.
	BytesRead uint64 `protobuf:"varint,2,opt,name=bytesRead,proto3" json:"bytesRead,omitempty"`
	// Bytes written for the container during this period.
	KeysWritten uint64 `protobuf:"varint,3,opt,name=keysWritten,proto3" json:"keysWritten,omitempty"`
	// Bytes read for the container during this period.
	KeysRead uint64 `protobuf:"varint,4,opt,name=keysRead,proto3" json:"keysRead,omitempty"`
}

func (m *ResourceStat) Reset()         { *m = ResourceStat{} }
func (m *ResourceStat) String() string { return proto.CompactTextString(m) }
func (*ResourceStat) ProtoMessage()    {}
func (*ResourceStat) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{5}
}
func (m *ResourceStat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResourceStat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResourceStat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResourceStat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResourceStat.Merge(m, src)
}
func (m *ResourceStat) XXX_Size() int {
	return m.Size()
}
func (m *ResourceStat) XXX_DiscardUnknown() {
	xxx_messageInfo_ResourceStat.DiscardUnknown(m)
}

var xxx_messageInfo_ResourceStat proto.InternalMessageInfo

func (m *ResourceStat) GetBytesWritten() uint64 {
	if m != nil {
		return m.BytesWritten
	}
	return 0
}

func (m *ResourceStat) GetBytesRead() uint64 {
	if m != nil {
		return m.BytesRead
	}
	return 0
}

func (m *ResourceStat) GetKeysWritten() uint64 {
	if m != nil {
		return m.KeysWritten
	}
	return 0
}

func (m *ResourceStat) GetKeysRead() uint64 {
	if m != nil {
		return m.KeysRead
	}
	return 0
}

// Member prophet member
type Member struct {
	ID   uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Addr string `protobuf:"bytes,3,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *Member) Reset()         { *m = Member{} }
func (m *Member) String() string { return proto.CompactTextString(m) }
func (*Member) ProtoMessage()    {}
func (*Member) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{6}
}
func (m *Member) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Member) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Member.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Member) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Member.Merge(m, src)
}
func (m *Member) XXX_Size() int {
	return m.Size()
}
func (m *Member) XXX_DiscardUnknown() {
	xxx_messageInfo_Member.DiscardUnknown(m)
}

var xxx_messageInfo_Member proto.InternalMessageInfo

func (m *Member) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Member) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Member) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

// Cluster prophet cluster
type Cluster struct {
	ID           uint64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	MaxPeerCount uint32 `protobuf:"varint,2,opt,name=maxPeerCount,proto3" json:"maxPeerCount,omitempty"`
}

func (m *Cluster) Reset()         { *m = Cluster{} }
func (m *Cluster) String() string { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()    {}
func (*Cluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{7}
}
func (m *Cluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster.Merge(m, src)
}
func (m *Cluster) XXX_Size() int {
	return m.Size()
}
func (m *Cluster) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster proto.InternalMessageInfo

func (m *Cluster) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Cluster) GetMaxPeerCount() uint32 {
	if m != nil {
		return m.MaxPeerCount
	}
	return 0
}

func init() {
	proto.RegisterEnum("metapb.Action", Action_name, Action_value)
	proto.RegisterEnum("metapb.ResourceKind", ResourceKind_name, ResourceKind_value)
	proto.RegisterEnum("metapb.ContainerState", ContainerState_name, ContainerState_value)
	proto.RegisterEnum("metapb.ChangePeerType", ChangePeerType_name, ChangePeerType_value)
	proto.RegisterEnum("metapb.PeerRole", PeerRole_name, PeerRole_value)
	proto.RegisterEnum("metapb.CheckPolicy", CheckPolicy_name, CheckPolicy_value)
	proto.RegisterEnum("metapb.OperatorStatus", OperatorStatus_name, OperatorStatus_value)
	proto.RegisterType((*ResourceEpoch)(nil), "metapb.ResourceEpoch")
	proto.RegisterType((*Peer)(nil), "metapb.Peer")
	proto.RegisterType((*PeerStats)(nil), "metapb.PeerStats")
	proto.RegisterType((*Pair)(nil), "metapb.Pair")
	proto.RegisterType((*Timestamp)(nil), "metapb.Timestamp")
	proto.RegisterType((*ResourceStat)(nil), "metapb.ResourceStat")
	proto.RegisterType((*Member)(nil), "metapb.Member")
	proto.RegisterType((*Cluster)(nil), "metapb.Cluster")
}

func init() { proto.RegisterFile("metapb.proto", fileDescriptor_77b4d575d5a68dda) }

var fileDescriptor_77b4d575d5a68dda = []byte{
	// 728 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x54, 0xdd, 0x8e, 0xda, 0x46,
	0x18, 0xc5, 0xc6, 0x61, 0xd7, 0x1f, 0x2c, 0x75, 0x47, 0x55, 0xb5, 0x8a, 0x22, 0xb2, 0xb2, 0xaa,
	0x2a, 0x42, 0x2a, 0x2b, 0xa5, 0x79, 0x01, 0xaf, 0xd7, 0x6a, 0x50, 0x58, 0xb0, 0xc6, 0x90, 0xb6,
	0x97, 0x83, 0xfd, 0x01, 0xd6, 0xda, 0x33, 0x96, 0x3d, 0xde, 0x96, 0x97, 0xa8, 0xfa, 0x58, 0xb9,
	0xdc, 0xcb, 0x5e, 0x45, 0x2d, 0xfb, 0x22, 0xd5, 0x8c, 0x81, 0x90, 0x9b, 0xbd, 0xfb, 0xce, 0x39,
	0x9c, 0xef, 0xe7, 0x78, 0x04, 0xf4, 0x72, 0x94, 0xac, 0x58, 0x8e, 0x8a, 0x52, 0x48, 0x41, 0x3a,
	0x0d, 0x7a, 0xf9, 0xd3, 0x3a, 0x95, 0x9b, 0x7a, 0x39, 0x8a, 0x45, 0x7e, 0xbd, 0x16, 0x6b, 0x71,
	0xad, 0xe5, 0x65, 0xbd, 0xd2, 0x48, 0x03, 0x5d, 0x35, 0x36, 0xd7, 0x87, 0x0b, 0x8a, 0x95, 0xa8,
	0xcb, 0x18, 0x83, 0x42, 0xc4, 0x1b, 0x72, 0x09, 0x67, 0xb1, 0xe0, 0xab, 0x8f, 0x58, 0x5e, 0x1a,
	0x57, 0xc6, 0x1b, 0x8b, 0x1e, 0xa0, 0x52, 0x1e, 0xb0, 0xac, 0x52, 0xc1, 0x2f, 0xcd, 0x46, 0xd9,
	0x43, 0x77, 0x05, 0x56, 0x88, 0x58, 0x92, 0xef, 0xc1, 0x4c, 0x93, 0xc6, 0x76, 0xd3, 0xd9, 0x7d,
	0x7e, 0x6d, 0x8e, 0x6f, 0xa9, 0x99, 0x26, 0xe4, 0x0a, 0xba, 0xb1, 0xe0, 0x92, 0xa5, 0x1c, 0xcb,
	0xf1, 0xed, 0xde, 0x7d, 0x4a, 0x91, 0x1f, 0xc0, 0x2a, 0x45, 0x86, 0x97, 0xed, 0x2b, 0xe3, 0x4d,
	0xff, 0xad, 0x33, 0xda, 0x9f, 0xa6, 0xba, 0x52, 0x91, 0x21, 0xd5, 0xaa, 0xbb, 0x00, 0x5b, 0x31,
	0x91, 0x64, 0xb2, 0x22, 0x3f, 0x82, 0x55, 0xe0, 0x7e, 0xcb, 0xee, 0xdb, 0xde, 0xa9, 0xe5, 0xc6,
	0xfa, 0xf4, 0xf9, 0x75, 0x8b, 0x6a, 0x5d, 0x0d, 0x4f, 0xc4, 0x1f, 0x3c, 0xc2, 0x58, 0xf0, 0xa4,
	0x3a, 0x0c, 0x3f, 0xa1, 0xdc, 0x11, 0x58, 0x21, 0x4b, 0x4b, 0xe2, 0x40, 0xfb, 0x1e, 0xb7, 0xba,
	0xa1, 0x4d, 0x55, 0x49, 0xbe, 0x83, 0x17, 0x0f, 0x2c, 0xab, 0x51, 0xbb, 0x6c, 0xda, 0x00, 0xd7,
	0x03, 0x7b, 0x9e, 0xe6, 0x58, 0x49, 0x96, 0x17, 0xe4, 0x25, 0x9c, 0x17, 0x9b, 0x6d, 0x95, 0xc6,
	0x2c, 0xd3, 0xce, 0x36, 0x3d, 0x62, 0x95, 0x58, 0x26, 0xd6, 0x5a, 0x32, 0xb5, 0x74, 0x80, 0xee,
	0x5f, 0x06, 0xf4, 0x0e, 0xb9, 0xab, 0x73, 0x88, 0x0b, 0xbd, 0xe5, 0x56, 0x62, 0xf5, 0x6b, 0x99,
	0x4a, 0x89, 0x7c, 0x9f, 0xfd, 0x57, 0x1c, 0x79, 0x05, 0xb6, 0xc6, 0x14, 0x59, 0xb2, 0xbf, 0xe3,
	0x0b, 0xa1, 0xee, 0xbc, 0xc7, 0xed, 0xb1, 0x41, 0xbb, 0xb9, 0xf3, 0x84, 0x52, 0xab, 0x2a, 0xa8,
	0xed, 0x96, 0x96, 0x8f, 0xd8, 0x7d, 0x0f, 0x9d, 0x3b, 0xcc, 0x97, 0xcf, 0x7c, 0x44, 0x02, 0x16,
	0x67, 0xf9, 0x21, 0x0a, 0x5d, 0x2b, 0x8e, 0x25, 0x49, 0xa9, 0x87, 0xd9, 0x54, 0xd7, 0x6e, 0x00,
	0x67, 0x7e, 0x56, 0x57, 0xf2, 0x99, 0x56, 0x2e, 0xf4, 0x72, 0xf6, 0xa7, 0xfa, 0x52, 0xbe, 0xa8,
	0xb9, 0xd4, 0x2d, 0x2f, 0xe8, 0x57, 0xdc, 0xf0, 0x0a, 0x3a, 0x5e, 0x2c, 0x53, 0xc1, 0xc9, 0x39,
	0x58, 0x53, 0xc1, 0xd1, 0x69, 0x91, 0x1e, 0x9c, 0x47, 0x31, 0xcb, 0x70, 0x56, 0x4b, 0xc7, 0x18,
	0x5e, 0x7f, 0x89, 0xf0, 0x43, 0xca, 0x13, 0xd2, 0x07, 0x98, 0x20, 0x4b, 0xb0, 0x54, 0xc8, 0x69,
	0x91, 0x6f, 0xa0, 0x4b, 0xb1, 0xc8, 0xd2, 0x98, 0x69, 0xc2, 0x18, 0xbe, 0x83, 0xbe, 0x7f, 0x78,
	0x73, 0x2a, 0x74, 0x24, 0x1d, 0x30, 0x17, 0xa1, 0xd3, 0x22, 0x5d, 0x38, 0x9b, 0xad, 0x56, 0x59,
	0xca, 0xd1, 0x31, 0xc8, 0x05, 0xd8, 0x73, 0x91, 0x2f, 0x2b, 0xa9, 0x86, 0x9a, 0xc3, 0x10, 0xfa,
	0xfe, 0x86, 0xf1, 0x35, 0xaa, 0xdd, 0xe6, 0xdb, 0x02, 0xd5, 0xaf, 0xbd, 0x24, 0x99, 0x8a, 0x44,
	0xed, 0xd4, 0x07, 0xa0, 0x98, 0x8b, 0x07, 0xd4, 0xd8, 0x20, 0x04, 0xfa, 0x5e, 0x92, 0x4c, 0x90,
	0x95, 0x1c, 0x4b, 0xcd, 0x99, 0xaa, 0xa3, 0xde, 0x5b, 0x75, 0x70, 0xda, 0xc3, 0xf7, 0x70, 0x7e,
	0x78, 0xd8, 0xc4, 0x86, 0x17, 0x1f, 0x85, 0xc4, 0xb2, 0x59, 0x62, 0x6f, 0x73, 0x0c, 0xf2, 0x2d,
	0x5c, 0x8c, 0x79, 0x2c, 0xf2, 0x94, 0xaf, 0x1b, 0xdd, 0x54, 0xd4, 0x2d, 0xe6, 0x42, 0x1e, 0xa9,
	0xf6, 0xf0, 0x1d, 0x74, 0xfd, 0x0d, 0xc6, 0xf7, 0xa1, 0xc8, 0xd2, 0x78, 0xab, 0x92, 0x8a, 0x7c,
	0x6f, 0xda, 0xdc, 0xee, 0x85, 0x21, 0x9d, 0xfd, 0x36, 0xbe, 0xf3, 0xe6, 0x81, 0x63, 0x10, 0x80,
	0xce, 0x22, 0x0a, 0x3e, 0x04, 0xbf, 0x37, 0x17, 0xcd, 0x0a, 0x2c, 0x99, 0x14, 0x3a, 0x86, 0xba,
	0x52, 0xa3, 0xa3, 0x85, 0xef, 0x07, 0x51, 0xd4, 0xec, 0x31, 0x1f, 0xdf, 0x05, 0xb3, 0xc5, 0xbc,
	0xf1, 0xf9, 0xde, 0xd4, 0x0f, 0x26, 0x8e, 0xa9, 0x04, 0x1a, 0x84, 0x13, 0xcf, 0x0f, 0x9c, 0xb6,
	0x06, 0x8b, 0xe9, 0x74, 0x3c, 0xfd, 0xc5, 0xb1, 0x6e, 0x5e, 0x3d, 0xfe, 0x37, 0x30, 0x3e, 0xed,
	0x06, 0xc6, 0xe3, 0x6e, 0x60, 0xfc, 0xbb, 0x1b, 0x18, 0x7f, 0x3f, 0x0d, 0x5a, 0x8f, 0x4f, 0x83,
	0xd6, 0x3f, 0x4f, 0x83, 0xd6, 0xb2, 0xa3, 0xff, 0x6a, 0x7e, 0xfe, 0x3f, 0x00, 0x00, 0xff, 0xff,
	0x67, 0x56, 0xde, 0xae, 0xb1, 0x04, 0x00, 0x00,
}

func (m *ResourceEpoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceEpoch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceEpoch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Version != 0 {
		i = encodeVarintMetapb(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if m.ConfVer != 0 {
		i = encodeVarintMetapb(dAtA, i, uint64(m.ConfVer))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Peer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Peer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Peer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Role != 0 {
		i = encodeVarintMetapb(dAtA, i, uint64(m.Role))
		i--
		dAtA[i] = 0x18
	}
	if m.ContainerID != 0 {
		i = encodeVarintMetapb(dAtA, i, uint64(m.ContainerID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PeerStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PeerStats) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PeerStats) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.DownSeconds != 0 {
		i = encodeVarintMetapb(dAtA, i, uint64(m.DownSeconds))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintMetapb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Pair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Timestamp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Timestamp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Timestamp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Logical != 0 {
		i = encodeVarintMetapb(dAtA, i, uint64(m.Logical))
		i--
		dAtA[i] = 0x10
	}
	if m.Physical != 0 {
		i = encodeVarintMetapb(dAtA, i, uint64(m.Physical))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ResourceStat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResourceStat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResourceStat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.KeysRead != 0 {
		i = encodeVarintMetapb(dAtA, i, uint64(m.KeysRead))
		i--
		dAtA[i] = 0x20
	}
	if m.KeysWritten != 0 {
		i = encodeVarintMetapb(dAtA, i, uint64(m.KeysWritten))
		i--
		dAtA[i] = 0x18
	}
	if m.BytesRead != 0 {
		i = encodeVarintMetapb(dAtA, i, uint64(m.BytesRead))
		i--
		dAtA[i] = 0x10
	}
	if m.BytesWritten != 0 {
		i = encodeVarintMetapb(dAtA, i, uint64(m.BytesWritten))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Member) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Member) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Member) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x12
	}
	if m.ID != 0 {
		i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cluster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxPeerCount != 0 {
		i = encodeVarintMetapb(dAtA, i, uint64(m.MaxPeerCount))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintMetapb(dAtA []byte, offset int, v uint64) int {
	offset -= sovMetapb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ResourceEpoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfVer != 0 {
		n += 1 + sovMetapb(uint64(m.ConfVer))
	}
	if m.Version != 0 {
		n += 1 + sovMetapb(uint64(m.Version))
	}
	return n
}

func (m *Peer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMetapb(uint64(m.ID))
	}
	if m.ContainerID != 0 {
		n += 1 + sovMetapb(uint64(m.ContainerID))
	}
	if m.Role != 0 {
		n += 1 + sovMetapb(uint64(m.Role))
	}
	return n
}

func (m *PeerStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Peer.Size()
	n += 1 + l + sovMetapb(uint64(l))
	if m.DownSeconds != 0 {
		n += 1 + sovMetapb(uint64(m.DownSeconds))
	}
	return n
}

func (m *Pair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	return n
}

func (m *Timestamp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Physical != 0 {
		n += 1 + sovMetapb(uint64(m.Physical))
	}
	if m.Logical != 0 {
		n += 1 + sovMetapb(uint64(m.Logical))
	}
	return n
}

func (m *ResourceStat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BytesWritten != 0 {
		n += 1 + sovMetapb(uint64(m.BytesWritten))
	}
	if m.BytesRead != 0 {
		n += 1 + sovMetapb(uint64(m.BytesRead))
	}
	if m.KeysWritten != 0 {
		n += 1 + sovMetapb(uint64(m.KeysWritten))
	}
	if m.KeysRead != 0 {
		n += 1 + sovMetapb(uint64(m.KeysRead))
	}
	return n
}

func (m *Member) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMetapb(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	return n
}

func (m *Cluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMetapb(uint64(m.ID))
	}
	if m.MaxPeerCount != 0 {
		n += 1 + sovMetapb(uint64(m.MaxPeerCount))
	}
	return n
}

func sovMetapb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMetapb(x uint64) (n int) {
	return sovMetapb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ResourceEpoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfVer", wireType)
			}
			m.ConfVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfVer |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Peer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Peer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Peer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerID", wireType)
			}
			m.ContainerID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= PeerRole(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PeerStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PeerStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PeerStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownSeconds", wireType)
			}
			m.DownSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownSeconds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Timestamp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timestamp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timestamp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Physical", wireType)
			}
			m.Physical = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Physical |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Logical", wireType)
			}
			m.Logical = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Logical |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResourceStat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResourceStat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResourceStat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesWritten", wireType)
			}
			m.BytesWritten = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesWritten |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BytesRead", wireType)
			}
			m.BytesRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BytesRead |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeysWritten", wireType)
			}
			m.KeysWritten = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeysWritten |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeysRead", wireType)
			}
			m.KeysRead = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeysRead |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Member) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Member: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Member: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPeerCount", wireType)
			}
			m.MaxPeerCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPeerCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMetapb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMetapb
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMetapb
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMetapb
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMetapb        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMetapb          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMetapb = fmt.Errorf("proto: unexpected end of group")
)
