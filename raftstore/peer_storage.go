package raftstore

import (
	"bytes"
	"errors"
	"fmt"
	"sync"
	"sync/atomic"

	"github.com/deepfabric/beehive/pb/bhmetapb"
	"github.com/deepfabric/beehive/pb/bhraftpb"
	"github.com/deepfabric/beehive/storage"
	"github.com/deepfabric/beehive/util"
	"github.com/fagongzi/util/protoc"
	"github.com/fagongzi/util/task"
	"go.etcd.io/etcd/raft"
	"go.etcd.io/etcd/raft/raftpb"
)

const (
	// When we create a shard peer, we should initialize its log term/index > 0,
	// so that we can force the follower peer to sync the snapshot first.
	raftInitLogTerm  = 5
	raftInitLogIndex = 5

	maxSnapTryCnt = 5
)

type snapshotState int

var (
	relax        = snapshotState(1)
	generating   = snapshotState(2)
	applying     = snapshotState(3)
	applyAborted = snapshotState(4)
)

const (
	pending = iota
	running
	cancelling
	cancelled
	finished
	failed
)

var (
	emptyEntry = raftpb.Entry{}
)

type peerStorage struct {
	store *store
	shard bhmetapb.Shard

	lastTerm         uint64
	appliedIndexTerm uint64
	lastReadyIndex   uint64
	lastCompactIndex uint64
	raftState        bhraftpb.RaftLocalState
	applyState       bhraftpb.RaftApplyState

	genSnapJob       *task.Job
	applySnapJob     *task.Job
	applySnapJobLock sync.RWMutex

	pendingReads *readIndexQueue
}

func newPeerStorage(store *store, shard bhmetapb.Shard) (*peerStorage, error) {
	s := new(peerStorage)
	s.store = store
	s.shard = shard
	s.appliedIndexTerm = raftInitLogTerm

	err := s.initRaftState()
	if err != nil {
		return nil, err
	}
	logger.Infof("shard %d init with raft state %+v",
		shard.ID,
		s.raftState)

	err = s.initApplyState()
	if err != nil {
		return nil, err
	}
	logger.Infof("shard %d init apply state, state=<%+v>",
		shard.ID,
		s.applyState)

	err = s.initLastTerm()
	if err != nil {
		return nil, err
	}
	logger.Infof("shard %d init last term, last term=<%d>",
		shard.ID,
		s.lastTerm)

	s.lastReadyIndex = s.getAppliedIndex()
	s.pendingReads = new(readIndexQueue)

	return s, nil
}

func (ps *peerStorage) initRaftState() error {
	v, err := ps.store.MetadataStorage().Get(getRaftStateKey(ps.shard.ID))
	if err != nil {
		return err
	}

	if len(v) > 0 {
		s := &bhraftpb.RaftLocalState{}
		err = s.Unmarshal(v)
		if err != nil {
			return err
		}

		ps.raftState = *s
		return nil
	}

	s := &bhraftpb.RaftLocalState{}
	if len(ps.shard.Peers) > 0 {
		s.LastIndex = raftInitLogIndex
	}

	ps.raftState = *s
	return nil
}

func (ps *peerStorage) initApplyState() error {
	v, err := ps.store.MetadataStorage().Get(getApplyStateKey(ps.shard.ID))
	if err != nil {
		return err
	}

	if len(v) > 0 && len(ps.shard.Peers) > 0 {
		s := &bhraftpb.RaftApplyState{}
		err = s.Unmarshal(v)
		if err != nil {
			return err
		}

		ps.applyState = *s
		return nil
	}

	if len(ps.shard.Peers) > 0 {
		ps.applyState.AppliedIndex = raftInitLogIndex
		ps.applyState.TruncatedState.Index = raftInitLogIndex
		ps.applyState.TruncatedState.Term = raftInitLogTerm
	}

	return nil
}

func (ps *peerStorage) initLastTerm() error {
	lastIndex := ps.raftState.LastIndex

	if lastIndex == 0 {
		ps.lastTerm = lastIndex
		return nil
	} else if lastIndex == raftInitLogIndex {
		ps.lastTerm = raftInitLogTerm
		return nil
	} else if lastIndex == ps.applyState.TruncatedState.Index {
		ps.lastTerm = ps.applyState.TruncatedState.Term
		return nil
	} else if lastIndex < raftInitLogIndex {
		logger.Fatalf("shard %d error raft last index %d",
			ps.shard.ID,
			lastIndex)
		return nil
	}

	v, err := ps.store.MetadataStorage().Get(getRaftLogKey(ps.shard.ID, lastIndex))
	if err != nil {
		return err
	}

	if nil == v {
		return fmt.Errorf("shard %d entry at index<%d> doesn't exist, may lose data",
			ps.shard.ID,
			lastIndex)
	}

	s := &raftpb.Entry{}
	err = s.Unmarshal(v)
	if err != nil {
		return err
	}

	ps.lastTerm = s.Term
	return nil
}

func (ps *peerStorage) isApplyComplete() bool {
	return ps.getCommittedIndex() == ps.getAppliedIndex()
}

func (ps *peerStorage) getAppliedIndex() uint64 {
	return ps.applyState.AppliedIndex
}

func (ps *peerStorage) getCommittedIndex() uint64 {
	return ps.raftState.HardState.Commit
}

func (ps *peerStorage) getTruncatedIndex() uint64 {
	return ps.applyState.TruncatedState.Index
}

func (ps *peerStorage) getTruncatedTerm() uint64 {
	return ps.applyState.TruncatedState.Term
}

func (ps *peerStorage) validateSnap(snap *raftpb.Snapshot) bool {
	snapData := &bhraftpb.SnapshotMessage{}
	err := snapData.Unmarshal(snap.Data)
	if err != nil {
		logger.Errorf("shard %d decode snapshot failed with %+v",
			ps.shard.ID,
			err)
		return false
	}

	snapEpoch := snapData.Header.Shard.Epoch
	lastEpoch := ps.shard.Epoch

	if snapEpoch.ConfVer < lastEpoch.ConfVer {
		logger.Infof("shard %d snapshot epoch %d/%d stale, generate again.",
			ps.shard.ID,
			snapEpoch.ConfVer,
			lastEpoch.ConfVer)
		return false
	}

	return true
}

func (ps *peerStorage) isInitialized() bool {
	return len(ps.shard.Peers) != 0
}

func (ps *peerStorage) isApplyingSnapshot() bool {
	return ps.applySnapJob != nil && ps.applySnapJob.IsNotComplete()
}

func (ps *peerStorage) checkRange(low, high uint64) error {
	if low > high {
		return fmt.Errorf("shard %d low %d is greater that high %d",
			ps.shard.ID,
			low,
			high)
	} else if low <= ps.getTruncatedIndex() {
		return raft.ErrCompacted
	} else {
		i, err := ps.LastIndex()
		if err != nil {
			return err
		}

		if high > i+1 {
			return fmt.Errorf("shard %d entries' high is out of bound lastindex, hight=<%d> lastindex=<%d>",
				ps.shard.ID,
				high,
				i)
		}
	}

	return nil
}

func (ps *peerStorage) loadLogEntry(index uint64) (raftpb.Entry, error) {
	key := getRaftLogKey(ps.shard.ID, index)
	v, err := ps.store.MetadataStorage().Get(key)
	if err != nil {
		logger.Errorf("shard %d load entry failed at %d with %+v",
			ps.shard.ID,
			index,
			err)
		return emptyEntry, err
	} else if len(v) == 0 {
		logger.Errorf("shard %d entry %d not found",
			ps.shard.ID,
			index)
		return emptyEntry, fmt.Errorf("log entry at %d not found", index)
	}

	return ps.unmarshal(v, index)
}

func (ps *peerStorage) loadLocalState(job *task.Job) (*bhraftpb.ShardLocalState, error) {
	if nil != job &&
		job.IsCancelling() {
		return nil, task.ErrJobCancelled
	}

	return loadLocalState(ps.shard.ID, ps.store.MetadataStorage(), false)
}

func (ps *peerStorage) applySnapshot(job *task.Job) error {
	if nil != job &&
		job.IsCancelling() {
		return task.ErrJobCancelled
	}

	snap := &bhraftpb.SnapshotMessage{}
	snap.Header = bhraftpb.SnapshotMessageHeader{
		Shard: ps.shard,
		Term:  ps.applyState.TruncatedState.Term,
		Index: ps.applyState.TruncatedState.Index,
	}

	return ps.store.snapshotManager.Apply(snap)
}

func (ps *peerStorage) loadApplyState() (*bhraftpb.RaftApplyState, error) {
	key := getApplyStateKey(ps.shard.ID)
	v, err := ps.store.MetadataStorage().Get(key)
	if err != nil {
		logger.Errorf("shard %d load apply state failed with %d",
			ps.shard.ID,
			err)
		return nil, err
	}

	if len(v) == 0 {
		return nil, errors.New("shard apply state not found")
	}

	applyState := &bhraftpb.RaftApplyState{}
	err = applyState.Unmarshal(v)
	return applyState, err
}

func (ps *peerStorage) unmarshal(v []byte, expectIndex uint64) (raftpb.Entry, error) {
	e := raftpb.Entry{}
	protoc.MustUnmarshal(&e, v)
	if e.Index != expectIndex {
		logger.Fatalf("shard %d raft log index not match, logIndex %d expect %d",
			ps.shard.ID,
			e.Index,
			expectIndex)
	}

	return e, nil
}

/// Delete all data belong to the shard.
/// If return Err, data may get partial deleted.
func (ps *peerStorage) clearData() error {
	shard := ps.shard

	shardID := shard.ID
	startKey := encStartKey(&shard)
	endKey := encEndKey(&shard)

	err := ps.store.addSnapJob(ps.shard.Group, func() error {
		logger.Infof("shard %d deleting data in [%+v, %+v)",
			shardID,
			startKey,
			endKey)
		err := ps.deleteAllInRange(startKey, endKey, nil)
		if err != nil {
			logger.Errorf("shard %d failed to delete data in [%+v, %+v) with %+v",
				shardID,
				startKey,
				endKey,
				err)
		}

		return err
	}, nil)

	return err
}

// Delete all data that is not covered by `newShard`.
func (ps *peerStorage) clearExtraData(newShard bhmetapb.Shard) error {
	shard := ps.shard

	oldStartKey := encStartKey(&shard)
	oldEndKey := encEndKey(&shard)

	newStartKey := encStartKey(&newShard)
	newEndKey := encEndKey(&newShard)

	if bytes.Compare(oldStartKey, newStartKey) < 0 {
		err := ps.startDestroyDataJob(newShard.ID, oldStartKey, newStartKey)

		if err != nil {
			return err
		}
	}

	if bytes.Compare(newEndKey, oldEndKey) < 0 {
		err := ps.startDestroyDataJob(newShard.ID, newEndKey, oldEndKey)

		if err != nil {
			return err
		}
	}

	return nil
}

func (ps *peerStorage) startDestroyDataJob(shardID uint64, start, end []byte) error {
	pr := ps.store.getPR(shardID, false)
	if pr != nil {
		err := ps.store.addApplyJob(pr.applyWorker, "doDestroyDataJob", func() error {
			return ps.doDestroyDataJob(shardID, start, end)
		}, nil)

		return err
	}

	return nil
}

func (ps *peerStorage) doDestroyDataJob(shardID uint64, startKey, endKey []byte) error {
	logger.Infof("shard %d deleting data, start=<%v>, end=<%v>",
		shardID,
		startKey,
		endKey)

	err := ps.deleteAllInRange(startKey, endKey, nil)
	if err != nil {
		logger.Errorf("shard %d failed to delete data, start=<%v> end=<%v> errors:\n %+v",
			shardID,
			startKey,
			endKey,
			err)
	}

	return err
}

func (ps *peerStorage) updatePeerState(shard bhmetapb.Shard, state bhraftpb.PeerState, wb *util.WriteBatch) error {
	shardState := &bhraftpb.ShardLocalState{}
	shardState.State = state
	shardState.Shard = shard

	if wb != nil {
		return wb.Set(getStateKey(shard.ID), protoc.MustMarshal(shardState))
	}

	return ps.store.MetadataStorage().Set(getStateKey(shard.ID), protoc.MustMarshal(shardState))
}

func (ps *peerStorage) writeInitialState(shardID uint64, wb *util.WriteBatch) error {
	raftState := new(bhraftpb.RaftLocalState)
	raftState.LastIndex = raftInitLogIndex
	raftState.HardState.Term = raftInitLogTerm
	raftState.HardState.Commit = raftInitLogIndex

	applyState := new(bhraftpb.RaftApplyState)
	applyState.AppliedIndex = raftInitLogIndex
	applyState.TruncatedState.Index = raftInitLogIndex
	applyState.TruncatedState.Term = raftInitLogTerm

	err := wb.Set(getRaftStateKey(shardID), protoc.MustMarshal(raftState))
	if err != nil {
		return err
	}

	return wb.Set(getApplyStateKey(shardID), protoc.MustMarshal(applyState))
}

func (ps *peerStorage) deleteAllInRange(start, end []byte, job *task.Job) error {
	if job != nil &&
		job.IsCancelling() {
		return task.ErrJobCancelled
	}

	return ps.store.DataStorageByGroup(ps.shard.Group, ps.shard.ID).RangeDelete(start, end)
}

func compactRaftLog(shardID uint64, state *bhraftpb.RaftApplyState, compactIndex, compactTerm uint64) error {
	logger.Debugf("shard %d compact log entries to index %d",
		shardID,
		compactIndex)
	if compactIndex <= state.TruncatedState.Index {
		return errors.New("try to truncate compacted entries")
	} else if compactIndex > state.AppliedIndex {
		return fmt.Errorf("compact index %d > applied index %d", compactIndex, state.AppliedIndex)
	}

	// we don't actually delete the logs now, we add an async task to do it.
	state.TruncatedState.Index = compactIndex
	state.TruncatedState.Term = compactTerm

	return nil
}

func loadLocalState(shardID uint64, driver storage.MetadataStorage, allowNotFound bool) (*bhraftpb.ShardLocalState, error) {
	key := getStateKey(shardID)
	v, err := driver.Get(key)
	if err != nil {
		logger.Errorf("shard %d load raft state failed with %+v",
			shardID,
			err)
		return nil, err
	} else if len(v) == 0 {
		if allowNotFound {
			return nil, nil
		}

		return nil, errors.New("shard state not found")
	}

	stat := &bhraftpb.ShardLocalState{}
	err = stat.Unmarshal(v)

	return stat, err
}

func (ps *peerStorage) isGeneratingSnap() bool {
	return ps.genSnapJob != nil && ps.genSnapJob.IsNotComplete()
}

func (ps *peerStorage) isGenSnapJobComplete() bool {
	return ps.genSnapJob != nil && ps.genSnapJob.IsComplete()
}

// ============================ etcd raft storage interface method
func (ps *peerStorage) InitialState() (raftpb.HardState, raftpb.ConfState, error) {
	confState := raftpb.ConfState{}
	if ps.raftState.HardState.Commit == 0 &&
		ps.raftState.HardState.Term == 0 &&
		ps.raftState.HardState.Vote == 0 {
		if ps.isInitialized() {
			logger.Fatalf("shard %d shard is initialized but local state has empty hard state, hardState=<%v>",
				ps.shard.ID,
				ps.raftState.HardState)
		}

		return ps.raftState.HardState, confState, nil
	}

	for _, p := range ps.shard.Peers {
		confState.Voters = append(confState.Voters, p.ID)
	}

	return ps.raftState.HardState, confState, nil
}

func (ps *peerStorage) Entries(low, high, maxSize uint64) ([]raftpb.Entry, error) {
	err := ps.checkRange(low, high)
	if err != nil {
		return nil, err
	}

	var ents []raftpb.Entry
	if low == high {
		return ents, nil
	}

	var totalSize uint64
	nextIndex := low
	exceededMaxSize := false

	startKey := getRaftLogKey(ps.shard.ID, low)

	if low+1 == high {
		// If election happens in inactive shards, they will just try
		// to fetch one empty log.
		v, err := ps.store.MetadataStorage().Get(startKey)
		if err != nil {
			return nil, err
		}

		if len(v) == 0 {
			return nil, raft.ErrUnavailable
		}

		e, err := ps.unmarshal(v, low)
		if err != nil {
			return nil, err
		}

		ents = append(ents, e)
		return ents, nil
	}

	endKey := getRaftLogKey(ps.shard.ID, high)
	err = ps.store.MetadataStorage().Scan(startKey, endKey, func(key, value []byte) (bool, error) {
		e := raftpb.Entry{}
		protoc.MustUnmarshal(&e, value)

		// May meet gap or has been compacted.
		if e.Index != nextIndex {
			return false, nil
		}

		nextIndex++
		totalSize += uint64(len(value))

		exceededMaxSize = totalSize > maxSize
		if !exceededMaxSize || len(ents) == 0 {
			ents = append(ents, e)
		}

		return !exceededMaxSize, nil
	}, false)

	if err != nil {
		return nil, err
	}

	// If we get the correct number of entries the total size exceeds max_size, returns.
	if len(ents) == int(high-low) || exceededMaxSize {
		return ents, nil
	}

	return nil, raft.ErrUnavailable
}

func (ps *peerStorage) Term(idx uint64) (uint64, error) {
	if idx == ps.getTruncatedIndex() {
		return ps.getTruncatedTerm(), nil
	}

	err := ps.checkRange(idx, idx+1)
	if err != nil {
		return 0, err
	}

	lastIdx, err := ps.LastIndex()
	if err != nil {
		return 0, err
	}

	if ps.getTruncatedTerm() == ps.lastTerm || idx == lastIdx {
		return ps.lastTerm, nil
	}

	key := getRaftLogKey(ps.shard.ID, idx)
	v, err := ps.store.MetadataStorage().Get(key)
	if err != nil {
		return 0, err
	}

	if v == nil {
		return 0, raft.ErrUnavailable
	}

	e, err := ps.unmarshal(v, idx)
	if err != nil {
		return 0, err
	}

	return e.Term, nil
}

func (ps *peerStorage) LastIndex() (uint64, error) {
	return atomic.LoadUint64(&ps.raftState.LastIndex), nil
}

func (ps *peerStorage) FirstIndex() (uint64, error) {
	return ps.getTruncatedIndex() + 1, nil
}

func (ps *peerStorage) Snapshot() (raftpb.Snapshot, error) {
	if ps.isGeneratingSnap() {
		return raftpb.Snapshot{}, raft.ErrSnapshotTemporarilyUnavailable
	}

	if ps.isGenSnapJobComplete() {
		result := ps.genSnapJob.GetResult()
		// snapshot failure, we will continue try do snapshot
		if nil == result {
			logger.Warningf("shard %d snapshot generating failed",
				ps.shard.ID)
		} else {
			snap := result.(raftpb.Snapshot)
			if ps.validateSnap(&snap) {
				ps.resetGenSnapJob()
				return snap, nil
			}
		}
	}

	logger.Infof("shard %d start snapshot, epoch=<%+v>",
		ps.shard.ID,
		ps.shard.Epoch)

	err := ps.store.addSnapJob(ps.shard.Group, ps.doGenerateSnapshotJob, ps.setGenSnapJob)
	if err != nil {
		logger.Fatalf("shard %d add generate job failed, errors:\n %+v",
			ps.shard.ID,
			err)
	}

	return raftpb.Snapshot{}, raft.ErrSnapshotTemporarilyUnavailable
}

func (ps *peerStorage) setGenSnapJob(job *task.Job) {
	ps.genSnapJob = job
}

func (ps *peerStorage) setApplySnapJob(job *task.Job) {
	ps.applySnapJob = job
}
