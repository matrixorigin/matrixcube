// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: raftcmdpb.proto

package raftcmdpb

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	bhmetapb "github.com/deepfabric/beehive/pb/bhmetapb"
	errorpb "github.com/deepfabric/beehive/pb/errorpb"
	metapb "github.com/deepfabric/prophet/pb/metapb"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CMDType int32

const (
	CMDType_Invalid   CMDType = 0
	CMDType_RaftError CMDType = 1
	CMDType_Snap      CMDType = 2
	CMDType_Write     CMDType = 3
	CMDType_Read      CMDType = 4
)

var CMDType_name = map[int32]string{
	0: "Invalid",
	1: "RaftError",
	2: "Snap",
	3: "Write",
	4: "Read",
}

var CMDType_value = map[string]int32{
	"Invalid":   0,
	"RaftError": 1,
	"Snap":      2,
	"Write":     3,
	"Read":      4,
}

func (x CMDType) String() string {
	return proto.EnumName(CMDType_name, int32(x))
}

func (CMDType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{0}
}

// AdminCmdType admin cmd type
type AdminCmdType int32

const (
	AdminCmdType_InvalidAdmin   AdminCmdType = 0
	AdminCmdType_ChangePeer     AdminCmdType = 1
	AdminCmdType_CompactLog     AdminCmdType = 2
	AdminCmdType_TransferLeader AdminCmdType = 3
	AdminCmdType_ComputeHash    AdminCmdType = 4
	AdminCmdType_VerifyHash     AdminCmdType = 5
	AdminCmdType_BatchSplit     AdminCmdType = 6
	AdminCmdType_ChangePeerV2   AdminCmdType = 7
)

var AdminCmdType_name = map[int32]string{
	0: "InvalidAdmin",
	1: "ChangePeer",
	2: "CompactLog",
	3: "TransferLeader",
	4: "ComputeHash",
	5: "VerifyHash",
	6: "BatchSplit",
	7: "ChangePeerV2",
}

var AdminCmdType_value = map[string]int32{
	"InvalidAdmin":   0,
	"ChangePeer":     1,
	"CompactLog":     2,
	"TransferLeader": 3,
	"ComputeHash":    4,
	"VerifyHash":     5,
	"BatchSplit":     6,
	"ChangePeerV2":   7,
}

func (x AdminCmdType) String() string {
	return proto.EnumName(AdminCmdType_name, int32(x))
}

func (AdminCmdType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{1}
}

// RaftRequestHeader raft request header, it contains the shard's metadata
type RaftRequestHeader struct {
	ID                   []byte               `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	ShardID              uint64               `protobuf:"varint,2,opt,name=shardID,proto3" json:"shardID,omitempty"`
	Peer                 metapb.Peer          `protobuf:"bytes,3,opt,name=peer,proto3" json:"peer"`
	Epoch                metapb.ResourceEpoch `protobuf:"bytes,5,opt,name=epoch,proto3" json:"epoch"`
	Term                 uint64               `protobuf:"varint,6,opt,name=term,proto3" json:"term,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *RaftRequestHeader) Reset()         { *m = RaftRequestHeader{} }
func (m *RaftRequestHeader) String() string { return proto.CompactTextString(m) }
func (*RaftRequestHeader) ProtoMessage()    {}
func (*RaftRequestHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{0}
}
func (m *RaftRequestHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftRequestHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftRequestHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftRequestHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftRequestHeader.Merge(m, src)
}
func (m *RaftRequestHeader) XXX_Size() int {
	return m.Size()
}
func (m *RaftRequestHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftRequestHeader.DiscardUnknown(m)
}

var xxx_messageInfo_RaftRequestHeader proto.InternalMessageInfo

func (m *RaftRequestHeader) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *RaftRequestHeader) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *RaftRequestHeader) GetPeer() metapb.Peer {
	if m != nil {
		return m.Peer
	}
	return metapb.Peer{}
}

func (m *RaftRequestHeader) GetEpoch() metapb.ResourceEpoch {
	if m != nil {
		return m.Epoch
	}
	return metapb.ResourceEpoch{}
}

func (m *RaftRequestHeader) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

type RaftResponseHeader struct {
	ID                   []byte        `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Error                errorpb.Error `protobuf:"bytes,2,opt,name=error,proto3" json:"error"`
	CurrentTerm          uint64        `protobuf:"varint,3,opt,name=currentTerm,proto3" json:"currentTerm,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *RaftResponseHeader) Reset()         { *m = RaftResponseHeader{} }
func (m *RaftResponseHeader) String() string { return proto.CompactTextString(m) }
func (*RaftResponseHeader) ProtoMessage()    {}
func (*RaftResponseHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{1}
}
func (m *RaftResponseHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftResponseHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftResponseHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftResponseHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftResponseHeader.Merge(m, src)
}
func (m *RaftResponseHeader) XXX_Size() int {
	return m.Size()
}
func (m *RaftResponseHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftResponseHeader.DiscardUnknown(m)
}

var xxx_messageInfo_RaftResponseHeader proto.InternalMessageInfo

func (m *RaftResponseHeader) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *RaftResponseHeader) GetError() errorpb.Error {
	if m != nil {
		return m.Error
	}
	return errorpb.Error{}
}

func (m *RaftResponseHeader) GetCurrentTerm() uint64 {
	if m != nil {
		return m.CurrentTerm
	}
	return 0
}

// RaftCMDRequest we can't include both normal requests and administrator request
// at same time.
type RaftCMDRequest struct {
	Header               *RaftRequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Requests             []*Request         `protobuf:"bytes,2,rep,name=requests,proto3" json:"requests,omitempty"`
	AdminRequest         *AdminRequest      `protobuf:"bytes,3,opt,name=adminRequest,proto3" json:"adminRequest,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *RaftCMDRequest) Reset()         { *m = RaftCMDRequest{} }
func (m *RaftCMDRequest) String() string { return proto.CompactTextString(m) }
func (*RaftCMDRequest) ProtoMessage()    {}
func (*RaftCMDRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{2}
}
func (m *RaftCMDRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftCMDRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftCMDRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftCMDRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftCMDRequest.Merge(m, src)
}
func (m *RaftCMDRequest) XXX_Size() int {
	return m.Size()
}
func (m *RaftCMDRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftCMDRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RaftCMDRequest proto.InternalMessageInfo

func (m *RaftCMDRequest) GetHeader() *RaftRequestHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *RaftCMDRequest) GetRequests() []*Request {
	if m != nil {
		return m.Requests
	}
	return nil
}

func (m *RaftCMDRequest) GetAdminRequest() *AdminRequest {
	if m != nil {
		return m.AdminRequest
	}
	return nil
}

type RaftCMDResponse struct {
	Header               *RaftResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Responses            []*Response         `protobuf:"bytes,2,rep,name=responses,proto3" json:"responses,omitempty"`
	AdminResponse        *AdminResponse      `protobuf:"bytes,3,opt,name=adminResponse,proto3" json:"adminResponse,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *RaftCMDResponse) Reset()         { *m = RaftCMDResponse{} }
func (m *RaftCMDResponse) String() string { return proto.CompactTextString(m) }
func (*RaftCMDResponse) ProtoMessage()    {}
func (*RaftCMDResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{3}
}
func (m *RaftCMDResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftCMDResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftCMDResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftCMDResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftCMDResponse.Merge(m, src)
}
func (m *RaftCMDResponse) XXX_Size() int {
	return m.Size()
}
func (m *RaftCMDResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftCMDResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RaftCMDResponse proto.InternalMessageInfo

func (m *RaftCMDResponse) GetHeader() *RaftResponseHeader {
	if m != nil {
		return m.Header
	}
	return nil
}

func (m *RaftCMDResponse) GetResponses() []*Response {
	if m != nil {
		return m.Responses
	}
	return nil
}

func (m *RaftCMDResponse) GetAdminResponse() *AdminResponse {
	if m != nil {
		return m.AdminResponse
	}
	return nil
}

// AdminRequest admin request
type AdminRequest struct {
	CmdType              AdminCmdType           `protobuf:"varint,1,opt,name=cmdType,proto3,enum=raftcmdpb.AdminCmdType" json:"cmdType,omitempty"`
	ChangePeer           *ChangePeerRequest     `protobuf:"bytes,2,opt,name=changePeer,proto3" json:"changePeer,omitempty"`
	CompactLog           *CompactLogRequest     `protobuf:"bytes,3,opt,name=compactLog,proto3" json:"compactLog,omitempty"`
	TransferLeader       *TransferLeaderRequest `protobuf:"bytes,4,opt,name=transferLeader,proto3" json:"transferLeader,omitempty"`
	VerifyHash           *VerifyHashRequest     `protobuf:"bytes,5,opt,name=verifyHash,proto3" json:"verifyHash,omitempty"`
	Splits               *BatchSplitRequest     `protobuf:"bytes,6,opt,name=splits,proto3" json:"splits,omitempty"`
	ChangePeerV2         *ChangePeerV2Request   `protobuf:"bytes,7,opt,name=changePeerV2,proto3" json:"changePeerV2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *AdminRequest) Reset()         { *m = AdminRequest{} }
func (m *AdminRequest) String() string { return proto.CompactTextString(m) }
func (*AdminRequest) ProtoMessage()    {}
func (*AdminRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{4}
}
func (m *AdminRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdminRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdminRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminRequest.Merge(m, src)
}
func (m *AdminRequest) XXX_Size() int {
	return m.Size()
}
func (m *AdminRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AdminRequest proto.InternalMessageInfo

func (m *AdminRequest) GetCmdType() AdminCmdType {
	if m != nil {
		return m.CmdType
	}
	return AdminCmdType_InvalidAdmin
}

func (m *AdminRequest) GetChangePeer() *ChangePeerRequest {
	if m != nil {
		return m.ChangePeer
	}
	return nil
}

func (m *AdminRequest) GetCompactLog() *CompactLogRequest {
	if m != nil {
		return m.CompactLog
	}
	return nil
}

func (m *AdminRequest) GetTransferLeader() *TransferLeaderRequest {
	if m != nil {
		return m.TransferLeader
	}
	return nil
}

func (m *AdminRequest) GetVerifyHash() *VerifyHashRequest {
	if m != nil {
		return m.VerifyHash
	}
	return nil
}

func (m *AdminRequest) GetSplits() *BatchSplitRequest {
	if m != nil {
		return m.Splits
	}
	return nil
}

func (m *AdminRequest) GetChangePeerV2() *ChangePeerV2Request {
	if m != nil {
		return m.ChangePeerV2
	}
	return nil
}

// AdminResponse admin response
type AdminResponse struct {
	CmdType              AdminCmdType            `protobuf:"varint,1,opt,name=cmdType,proto3,enum=raftcmdpb.AdminCmdType" json:"cmdType,omitempty"`
	ChangePeer           *ChangePeerResponse     `protobuf:"bytes,2,opt,name=changePeer,proto3" json:"changePeer,omitempty"`
	CompactLog           *CompactLogResponse     `protobuf:"bytes,3,opt,name=compactLog,proto3" json:"compactLog,omitempty"`
	TransferLeader       *TransferLeaderResponse `protobuf:"bytes,4,opt,name=transferLeader,proto3" json:"transferLeader,omitempty"`
	VerifyHash           *VerifyHashResponse     `protobuf:"bytes,5,opt,name=verifyHash,proto3" json:"verifyHash,omitempty"`
	Splits               *BatchSplitResponse     `protobuf:"bytes,9,opt,name=splits,proto3" json:"splits,omitempty"`
	ChangePeerV2         *ChangePeerV2Response   `protobuf:"bytes,10,opt,name=changePeerV2,proto3" json:"changePeerV2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *AdminResponse) Reset()         { *m = AdminResponse{} }
func (m *AdminResponse) String() string { return proto.CompactTextString(m) }
func (*AdminResponse) ProtoMessage()    {}
func (*AdminResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{5}
}
func (m *AdminResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AdminResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AdminResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AdminResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AdminResponse.Merge(m, src)
}
func (m *AdminResponse) XXX_Size() int {
	return m.Size()
}
func (m *AdminResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AdminResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AdminResponse proto.InternalMessageInfo

func (m *AdminResponse) GetCmdType() AdminCmdType {
	if m != nil {
		return m.CmdType
	}
	return AdminCmdType_InvalidAdmin
}

func (m *AdminResponse) GetChangePeer() *ChangePeerResponse {
	if m != nil {
		return m.ChangePeer
	}
	return nil
}

func (m *AdminResponse) GetCompactLog() *CompactLogResponse {
	if m != nil {
		return m.CompactLog
	}
	return nil
}

func (m *AdminResponse) GetTransferLeader() *TransferLeaderResponse {
	if m != nil {
		return m.TransferLeader
	}
	return nil
}

func (m *AdminResponse) GetVerifyHash() *VerifyHashResponse {
	if m != nil {
		return m.VerifyHash
	}
	return nil
}

func (m *AdminResponse) GetSplits() *BatchSplitResponse {
	if m != nil {
		return m.Splits
	}
	return nil
}

func (m *AdminResponse) GetChangePeerV2() *ChangePeerV2Response {
	if m != nil {
		return m.ChangePeerV2
	}
	return nil
}

// Request request
type Request struct {
	ID                   []byte   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Group                uint64   `protobuf:"varint,2,opt,name=group,proto3" json:"group,omitempty"`
	Type                 CMDType  `protobuf:"varint,3,opt,name=type,proto3,enum=raftcmdpb.CMDType" json:"type,omitempty"`
	CustemType           uint64   `protobuf:"varint,4,opt,name=custemType,proto3" json:"custemType,omitempty"`
	Key                  []byte   `protobuf:"bytes,5,opt,name=key,proto3" json:"key,omitempty"`
	Cmd                  []byte   `protobuf:"bytes,6,opt,name=cmd,proto3" json:"cmd,omitempty"`
	SID                  int64    `protobuf:"varint,7,opt,name=sid,proto3" json:"sid,omitempty"`
	PID                  int64    `protobuf:"varint,8,opt,name=pid,proto3" json:"pid,omitempty"`
	StopAt               int64    `protobuf:"varint,9,opt,name=stopAt,proto3" json:"stopAt,omitempty"`
	ToShard              uint64   `protobuf:"varint,10,opt,name=toShard,proto3" json:"toShard,omitempty"`
	AllowFollower        bool     `protobuf:"varint,11,opt,name=allowFollower,proto3" json:"allowFollower,omitempty"`
	LastBroadcast        bool     `protobuf:"varint,12,opt,name=lastBroadcast,proto3" json:"lastBroadcast,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{6}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *Request) GetGroup() uint64 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *Request) GetType() CMDType {
	if m != nil {
		return m.Type
	}
	return CMDType_Invalid
}

func (m *Request) GetCustemType() uint64 {
	if m != nil {
		return m.CustemType
	}
	return 0
}

func (m *Request) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Request) GetCmd() []byte {
	if m != nil {
		return m.Cmd
	}
	return nil
}

func (m *Request) GetSID() int64 {
	if m != nil {
		return m.SID
	}
	return 0
}

func (m *Request) GetPID() int64 {
	if m != nil {
		return m.PID
	}
	return 0
}

func (m *Request) GetStopAt() int64 {
	if m != nil {
		return m.StopAt
	}
	return 0
}

func (m *Request) GetToShard() uint64 {
	if m != nil {
		return m.ToShard
	}
	return 0
}

func (m *Request) GetAllowFollower() bool {
	if m != nil {
		return m.AllowFollower
	}
	return false
}

func (m *Request) GetLastBroadcast() bool {
	if m != nil {
		return m.LastBroadcast
	}
	return false
}

// Response response
type Response struct {
	ID                   []byte        `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Type                 CMDType       `protobuf:"varint,2,opt,name=type,proto3,enum=raftcmdpb.CMDType" json:"type,omitempty"`
	Value                []byte        `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	OriginRequest        *Request      `protobuf:"bytes,4,opt,name=originRequest,proto3" json:"originRequest,omitempty"`
	SID                  int64         `protobuf:"varint,5,opt,name=sid,proto3" json:"sid,omitempty"`
	PID                  int64         `protobuf:"varint,6,opt,name=pid,proto3" json:"pid,omitempty"`
	Error                errorpb.Error `protobuf:"bytes,7,opt,name=error,proto3" json:"error"`
	ContinueBroadcast    bool          `protobuf:"varint,8,opt,name=continueBroadcast,proto3" json:"continueBroadcast,omitempty"`
	Stale                bool          `protobuf:"varint,9,opt,name=stale,proto3" json:"stale,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{7}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *Response) GetType() CMDType {
	if m != nil {
		return m.Type
	}
	return CMDType_Invalid
}

func (m *Response) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Response) GetOriginRequest() *Request {
	if m != nil {
		return m.OriginRequest
	}
	return nil
}

func (m *Response) GetSID() int64 {
	if m != nil {
		return m.SID
	}
	return 0
}

func (m *Response) GetPID() int64 {
	if m != nil {
		return m.PID
	}
	return 0
}

func (m *Response) GetError() errorpb.Error {
	if m != nil {
		return m.Error
	}
	return errorpb.Error{}
}

func (m *Response) GetContinueBroadcast() bool {
	if m != nil {
		return m.ContinueBroadcast
	}
	return false
}

func (m *Response) GetStale() bool {
	if m != nil {
		return m.Stale
	}
	return false
}

type ChangePeerRequest struct {
	// This can be only called in internal RaftStore now.
	ChangeType           metapb.ChangePeerType `protobuf:"varint,1,opt,name=changeType,proto3,enum=metapb.ChangePeerType" json:"changeType,omitempty"`
	Peer                 metapb.Peer           `protobuf:"bytes,2,opt,name=peer,proto3" json:"peer"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ChangePeerRequest) Reset()         { *m = ChangePeerRequest{} }
func (m *ChangePeerRequest) String() string { return proto.CompactTextString(m) }
func (*ChangePeerRequest) ProtoMessage()    {}
func (*ChangePeerRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{8}
}
func (m *ChangePeerRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangePeerRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangePeerRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangePeerRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangePeerRequest.Merge(m, src)
}
func (m *ChangePeerRequest) XXX_Size() int {
	return m.Size()
}
func (m *ChangePeerRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangePeerRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ChangePeerRequest proto.InternalMessageInfo

func (m *ChangePeerRequest) GetChangeType() metapb.ChangePeerType {
	if m != nil {
		return m.ChangeType
	}
	return metapb.ChangePeerType_AddNode
}

func (m *ChangePeerRequest) GetPeer() metapb.Peer {
	if m != nil {
		return m.Peer
	}
	return metapb.Peer{}
}

// ChangePeerResponse change peer response
type ChangePeerResponse struct {
	Shard                bhmetapb.Shard `protobuf:"bytes,1,opt,name=shard,proto3" json:"shard"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ChangePeerResponse) Reset()         { *m = ChangePeerResponse{} }
func (m *ChangePeerResponse) String() string { return proto.CompactTextString(m) }
func (*ChangePeerResponse) ProtoMessage()    {}
func (*ChangePeerResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{9}
}
func (m *ChangePeerResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangePeerResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangePeerResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangePeerResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangePeerResponse.Merge(m, src)
}
func (m *ChangePeerResponse) XXX_Size() int {
	return m.Size()
}
func (m *ChangePeerResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangePeerResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ChangePeerResponse proto.InternalMessageInfo

func (m *ChangePeerResponse) GetShard() bhmetapb.Shard {
	if m != nil {
		return m.Shard
	}
	return bhmetapb.Shard{}
}

// CompactLogRequest compact raft log
type CompactLogRequest struct {
	CompactIndex         uint64   `protobuf:"varint,1,opt,name=compactIndex,proto3" json:"compactIndex,omitempty"`
	CompactTerm          uint64   `protobuf:"varint,2,opt,name=compactTerm,proto3" json:"compactTerm,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CompactLogRequest) Reset()         { *m = CompactLogRequest{} }
func (m *CompactLogRequest) String() string { return proto.CompactTextString(m) }
func (*CompactLogRequest) ProtoMessage()    {}
func (*CompactLogRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{10}
}
func (m *CompactLogRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactLogRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactLogRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompactLogRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactLogRequest.Merge(m, src)
}
func (m *CompactLogRequest) XXX_Size() int {
	return m.Size()
}
func (m *CompactLogRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactLogRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CompactLogRequest proto.InternalMessageInfo

func (m *CompactLogRequest) GetCompactIndex() uint64 {
	if m != nil {
		return m.CompactIndex
	}
	return 0
}

func (m *CompactLogRequest) GetCompactTerm() uint64 {
	if m != nil {
		return m.CompactTerm
	}
	return 0
}

// CompactLogResponse compact raft log
type CompactLogResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CompactLogResponse) Reset()         { *m = CompactLogResponse{} }
func (m *CompactLogResponse) String() string { return proto.CompactTextString(m) }
func (*CompactLogResponse) ProtoMessage()    {}
func (*CompactLogResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{11}
}
func (m *CompactLogResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactLogResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactLogResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompactLogResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactLogResponse.Merge(m, src)
}
func (m *CompactLogResponse) XXX_Size() int {
	return m.Size()
}
func (m *CompactLogResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactLogResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CompactLogResponse proto.InternalMessageInfo

// TransferLeaderRequest transfer leader
type TransferLeaderRequest struct {
	Peer                 metapb.Peer `protobuf:"bytes,1,opt,name=peer,proto3" json:"peer"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *TransferLeaderRequest) Reset()         { *m = TransferLeaderRequest{} }
func (m *TransferLeaderRequest) String() string { return proto.CompactTextString(m) }
func (*TransferLeaderRequest) ProtoMessage()    {}
func (*TransferLeaderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{12}
}
func (m *TransferLeaderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferLeaderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferLeaderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferLeaderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferLeaderRequest.Merge(m, src)
}
func (m *TransferLeaderRequest) XXX_Size() int {
	return m.Size()
}
func (m *TransferLeaderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferLeaderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TransferLeaderRequest proto.InternalMessageInfo

func (m *TransferLeaderRequest) GetPeer() metapb.Peer {
	if m != nil {
		return m.Peer
	}
	return metapb.Peer{}
}

type TransferLeaderResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TransferLeaderResponse) Reset()         { *m = TransferLeaderResponse{} }
func (m *TransferLeaderResponse) String() string { return proto.CompactTextString(m) }
func (*TransferLeaderResponse) ProtoMessage()    {}
func (*TransferLeaderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{13}
}
func (m *TransferLeaderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferLeaderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferLeaderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferLeaderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferLeaderResponse.Merge(m, src)
}
func (m *TransferLeaderResponse) XXX_Size() int {
	return m.Size()
}
func (m *TransferLeaderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferLeaderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TransferLeaderResponse proto.InternalMessageInfo

type VerifyHashRequest struct {
	Index                uint64   `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Hash                 []byte   `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	Context              []byte   `protobuf:"bytes,3,opt,name=context,proto3" json:"context,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VerifyHashRequest) Reset()         { *m = VerifyHashRequest{} }
func (m *VerifyHashRequest) String() string { return proto.CompactTextString(m) }
func (*VerifyHashRequest) ProtoMessage()    {}
func (*VerifyHashRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{14}
}
func (m *VerifyHashRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyHashRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyHashRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyHashRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyHashRequest.Merge(m, src)
}
func (m *VerifyHashRequest) XXX_Size() int {
	return m.Size()
}
func (m *VerifyHashRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyHashRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyHashRequest proto.InternalMessageInfo

func (m *VerifyHashRequest) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *VerifyHashRequest) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *VerifyHashRequest) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

type VerifyHashResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VerifyHashResponse) Reset()         { *m = VerifyHashResponse{} }
func (m *VerifyHashResponse) String() string { return proto.CompactTextString(m) }
func (*VerifyHashResponse) ProtoMessage()    {}
func (*VerifyHashResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{15}
}
func (m *VerifyHashResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyHashResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyHashResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyHashResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyHashResponse.Merge(m, src)
}
func (m *VerifyHashResponse) XXX_Size() int {
	return m.Size()
}
func (m *VerifyHashResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyHashResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyHashResponse proto.InternalMessageInfo

type SplitRequest struct {
	// This can be only called in internal RaftStore now.
	// The split_key must be in the been splitting region.
	SplitKey []byte `protobuf:"bytes,1,opt,name=splitKey,proto3" json:"splitKey,omitempty"`
	// We split the region into two, first uses the origin
	// parent region id, and the second uses the new_region_id.
	// We must guarantee that the new_region_id is global unique.
	NewShardID uint64 `protobuf:"varint,2,opt,name=newShardID,proto3" json:"newShardID,omitempty"`
	// The peer ids for the new split region.
	NewPeerIDs           []uint64 `protobuf:"varint,3,rep,packed,name=newPeerIDs,proto3" json:"newPeerIDs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SplitRequest) Reset()         { *m = SplitRequest{} }
func (m *SplitRequest) String() string { return proto.CompactTextString(m) }
func (*SplitRequest) ProtoMessage()    {}
func (*SplitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{16}
}
func (m *SplitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitRequest.Merge(m, src)
}
func (m *SplitRequest) XXX_Size() int {
	return m.Size()
}
func (m *SplitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SplitRequest proto.InternalMessageInfo

func (m *SplitRequest) GetSplitKey() []byte {
	if m != nil {
		return m.SplitKey
	}
	return nil
}

func (m *SplitRequest) GetNewShardID() uint64 {
	if m != nil {
		return m.NewShardID
	}
	return 0
}

func (m *SplitRequest) GetNewPeerIDs() []uint64 {
	if m != nil {
		return m.NewPeerIDs
	}
	return nil
}

type BatchSplitRequest struct {
	Requests []SplitRequest `protobuf:"bytes,1,rep,name=requests,proto3" json:"requests"`
	// If true, the last shard derive the origin shard_id,
	// other shards use new ids.
	RightDerive          bool     `protobuf:"varint,2,opt,name=rightDerive,proto3" json:"rightDerive,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BatchSplitRequest) Reset()         { *m = BatchSplitRequest{} }
func (m *BatchSplitRequest) String() string { return proto.CompactTextString(m) }
func (*BatchSplitRequest) ProtoMessage()    {}
func (*BatchSplitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{17}
}
func (m *BatchSplitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSplitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSplitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSplitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSplitRequest.Merge(m, src)
}
func (m *BatchSplitRequest) XXX_Size() int {
	return m.Size()
}
func (m *BatchSplitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSplitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSplitRequest proto.InternalMessageInfo

func (m *BatchSplitRequest) GetRequests() []SplitRequest {
	if m != nil {
		return m.Requests
	}
	return nil
}

func (m *BatchSplitRequest) GetRightDerive() bool {
	if m != nil {
		return m.RightDerive
	}
	return false
}

type BatchSplitResponse struct {
	Shards               []*bhmetapb.Shard `protobuf:"bytes,1,rep,name=shards,proto3" json:"shards,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *BatchSplitResponse) Reset()         { *m = BatchSplitResponse{} }
func (m *BatchSplitResponse) String() string { return proto.CompactTextString(m) }
func (*BatchSplitResponse) ProtoMessage()    {}
func (*BatchSplitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{18}
}
func (m *BatchSplitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSplitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSplitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSplitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSplitResponse.Merge(m, src)
}
func (m *BatchSplitResponse) XXX_Size() int {
	return m.Size()
}
func (m *BatchSplitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSplitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSplitResponse proto.InternalMessageInfo

func (m *BatchSplitResponse) GetShards() []*bhmetapb.Shard {
	if m != nil {
		return m.Shards
	}
	return nil
}

type ChangePeerV2Request struct {
	Changes              []ChangePeerRequest `protobuf:"bytes,1,rep,name=changes,proto3" json:"changes"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ChangePeerV2Request) Reset()         { *m = ChangePeerV2Request{} }
func (m *ChangePeerV2Request) String() string { return proto.CompactTextString(m) }
func (*ChangePeerV2Request) ProtoMessage()    {}
func (*ChangePeerV2Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{19}
}
func (m *ChangePeerV2Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangePeerV2Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangePeerV2Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangePeerV2Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangePeerV2Request.Merge(m, src)
}
func (m *ChangePeerV2Request) XXX_Size() int {
	return m.Size()
}
func (m *ChangePeerV2Request) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangePeerV2Request.DiscardUnknown(m)
}

var xxx_messageInfo_ChangePeerV2Request proto.InternalMessageInfo

func (m *ChangePeerV2Request) GetChanges() []ChangePeerRequest {
	if m != nil {
		return m.Changes
	}
	return nil
}

type ChangePeerV2Response struct {
	Shard                *bhmetapb.Shard `protobuf:"bytes,1,opt,name=shard,proto3" json:"shard,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ChangePeerV2Response) Reset()         { *m = ChangePeerV2Response{} }
func (m *ChangePeerV2Response) String() string { return proto.CompactTextString(m) }
func (*ChangePeerV2Response) ProtoMessage()    {}
func (*ChangePeerV2Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_c4d8ad5550754569, []int{20}
}
func (m *ChangePeerV2Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangePeerV2Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangePeerV2Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangePeerV2Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangePeerV2Response.Merge(m, src)
}
func (m *ChangePeerV2Response) XXX_Size() int {
	return m.Size()
}
func (m *ChangePeerV2Response) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangePeerV2Response.DiscardUnknown(m)
}

var xxx_messageInfo_ChangePeerV2Response proto.InternalMessageInfo

func (m *ChangePeerV2Response) GetShard() *bhmetapb.Shard {
	if m != nil {
		return m.Shard
	}
	return nil
}

func init() {
	proto.RegisterEnum("raftcmdpb.CMDType", CMDType_name, CMDType_value)
	proto.RegisterEnum("raftcmdpb.AdminCmdType", AdminCmdType_name, AdminCmdType_value)
	proto.RegisterType((*RaftRequestHeader)(nil), "raftcmdpb.RaftRequestHeader")
	proto.RegisterType((*RaftResponseHeader)(nil), "raftcmdpb.RaftResponseHeader")
	proto.RegisterType((*RaftCMDRequest)(nil), "raftcmdpb.RaftCMDRequest")
	proto.RegisterType((*RaftCMDResponse)(nil), "raftcmdpb.RaftCMDResponse")
	proto.RegisterType((*AdminRequest)(nil), "raftcmdpb.AdminRequest")
	proto.RegisterType((*AdminResponse)(nil), "raftcmdpb.AdminResponse")
	proto.RegisterType((*Request)(nil), "raftcmdpb.Request")
	proto.RegisterType((*Response)(nil), "raftcmdpb.Response")
	proto.RegisterType((*ChangePeerRequest)(nil), "raftcmdpb.ChangePeerRequest")
	proto.RegisterType((*ChangePeerResponse)(nil), "raftcmdpb.ChangePeerResponse")
	proto.RegisterType((*CompactLogRequest)(nil), "raftcmdpb.CompactLogRequest")
	proto.RegisterType((*CompactLogResponse)(nil), "raftcmdpb.CompactLogResponse")
	proto.RegisterType((*TransferLeaderRequest)(nil), "raftcmdpb.TransferLeaderRequest")
	proto.RegisterType((*TransferLeaderResponse)(nil), "raftcmdpb.TransferLeaderResponse")
	proto.RegisterType((*VerifyHashRequest)(nil), "raftcmdpb.VerifyHashRequest")
	proto.RegisterType((*VerifyHashResponse)(nil), "raftcmdpb.VerifyHashResponse")
	proto.RegisterType((*SplitRequest)(nil), "raftcmdpb.SplitRequest")
	proto.RegisterType((*BatchSplitRequest)(nil), "raftcmdpb.BatchSplitRequest")
	proto.RegisterType((*BatchSplitResponse)(nil), "raftcmdpb.BatchSplitResponse")
	proto.RegisterType((*ChangePeerV2Request)(nil), "raftcmdpb.ChangePeerV2Request")
	proto.RegisterType((*ChangePeerV2Response)(nil), "raftcmdpb.ChangePeerV2Response")
}

func init() { proto.RegisterFile("raftcmdpb.proto", fileDescriptor_c4d8ad5550754569) }

var fileDescriptor_c4d8ad5550754569 = []byte{
	// 1350 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x57, 0x5f, 0x6f, 0xdc, 0x44,
	0x10, 0xaf, 0xed, 0xfb, 0x97, 0x39, 0x27, 0x71, 0xb6, 0x69, 0x30, 0x15, 0x49, 0x0e, 0x8b, 0x3f,
	0x51, 0x81, 0x44, 0x0d, 0xa5, 0x80, 0x68, 0x40, 0xb9, 0x5c, 0x51, 0x4f, 0xb4, 0x52, 0xe5, 0x54,
	0xad, 0x78, 0xf4, 0xd9, 0x9b, 0x3b, 0xc3, 0xdd, 0xd9, 0xac, 0xf7, 0xd2, 0x86, 0x2f, 0xc2, 0x17,
	0xe1, 0xbd, 0x6f, 0x55, 0x5f, 0x90, 0xfa, 0xc6, 0x5b, 0x04, 0xf9, 0x24, 0x68, 0xc7, 0x6b, 0x7b,
	0x1d, 0xdf, 0x25, 0x12, 0x2f, 0x39, 0xef, 0xcc, 0xfc, 0x76, 0x77, 0xe6, 0x37, 0x3b, 0x33, 0x81,
	0x55, 0xe6, 0x9d, 0x70, 0x7f, 0x12, 0xc4, 0x83, 0xdd, 0x98, 0x45, 0x3c, 0x22, 0x4b, 0xb9, 0xe0,
	0xf6, 0x37, 0xc3, 0x90, 0x8f, 0x66, 0x83, 0x5d, 0x3f, 0x9a, 0xec, 0x05, 0x94, 0xc6, 0x27, 0xde,
	0x80, 0x85, 0xfe, 0xde, 0x80, 0xd2, 0x51, 0x78, 0x4a, 0xf7, 0xe2, 0xc1, 0xde, 0x60, 0x34, 0xa1,
	0xdc, 0x53, 0x3e, 0xd2, 0x4d, 0x6e, 0xdf, 0xbf, 0x16, 0x49, 0x19, 0x8b, 0x58, 0xf1, 0x2b, 0x71,
	0xf7, 0xe6, 0xe3, 0x62, 0x16, 0xc5, 0x23, 0xca, 0x05, 0x4e, 0x9e, 0x57, 0x3a, 0xed, 0x0b, 0x05,
	0x35, 0x8c, 0x86, 0xd1, 0x1e, 0x8a, 0x07, 0xb3, 0x13, 0x5c, 0xe1, 0x02, 0xbf, 0x52, 0x73, 0xe7,
	0x4f, 0x0d, 0xd6, 0x5c, 0xef, 0x84, 0xbb, 0xf4, 0xb7, 0x19, 0x4d, 0xf8, 0x23, 0xea, 0x05, 0x94,
	0x91, 0x0d, 0xd0, 0xc3, 0xc0, 0xd6, 0x3a, 0xda, 0x8e, 0xd9, 0x6d, 0x5c, 0x9c, 0x6f, 0xeb, 0xfd,
	0x9e, 0xab, 0x87, 0x01, 0xb1, 0xa1, 0x99, 0x8c, 0x3c, 0x16, 0xf4, 0x7b, 0xb6, 0xde, 0xd1, 0x76,
	0x6a, 0x6e, 0xb6, 0x24, 0x9f, 0x40, 0x2d, 0xa6, 0x94, 0xd9, 0x46, 0x47, 0xdb, 0x69, 0xef, 0x9b,
	0xbb, 0xf2, 0x4e, 0x4f, 0x29, 0x65, 0xdd, 0xda, 0xdb, 0xf3, 0xed, 0x1b, 0x2e, 0xea, 0xc9, 0x5d,
	0xa8, 0xd3, 0x38, 0xf2, 0x47, 0x76, 0x1d, 0x0d, 0x6f, 0x65, 0x86, 0x2e, 0x4d, 0xa2, 0x19, 0xf3,
	0xe9, 0x43, 0xa1, 0x94, 0x88, 0xd4, 0x92, 0x10, 0xa8, 0x71, 0xca, 0x26, 0x76, 0x03, 0x4f, 0xc4,
	0x6f, 0xe7, 0x77, 0x20, 0xe9, 0xad, 0x93, 0x38, 0x9a, 0x26, 0xf4, 0x9a, 0x6b, 0xdf, 0x81, 0x3a,
	0x86, 0x16, 0x2f, 0xdd, 0xde, 0x5f, 0xd9, 0xcd, 0x02, 0xfd, 0x50, 0xfc, 0xe6, 0xa7, 0x89, 0x05,
	0xe9, 0x40, 0xdb, 0x9f, 0x31, 0x46, 0xa7, 0xfc, 0x99, 0x38, 0xd4, 0xc0, 0x43, 0x55, 0x91, 0xf3,
	0x5a, 0x83, 0x15, 0x71, 0xf8, 0xd1, 0x93, 0x9e, 0x8c, 0x1a, 0xb9, 0x07, 0x8d, 0x11, 0x5e, 0x01,
	0x0f, 0x6f, 0xef, 0x7f, 0xb0, 0x5b, 0x64, 0x52, 0x25, 0xba, 0xae, 0xb4, 0x25, 0xf7, 0xa0, 0xc5,
	0x52, 0x45, 0x62, 0xeb, 0x1d, 0x63, 0xa7, 0xbd, 0x4f, 0x54, 0x5c, 0xaa, 0xc2, 0xdb, 0x69, 0x6e,
	0x6e, 0x49, 0x0e, 0xc1, 0xf4, 0x82, 0x49, 0x38, 0x95, 0x7a, 0x19, 0xf1, 0xf7, 0x14, 0xe4, 0xa1,
	0xa2, 0x96, 0xf0, 0x12, 0xc4, 0xf9, 0x4b, 0x83, 0xd5, 0xdc, 0x83, 0x34, 0x82, 0xe4, 0xbb, 0x4b,
	0x2e, 0x6c, 0x56, 0x5c, 0x50, 0x43, 0x2d, 0xb7, 0xcd, 0x3c, 0xf9, 0x1a, 0x96, 0x98, 0xd4, 0x67,
	0xae, 0xdc, 0x2c, 0xb9, 0x92, 0xea, 0x24, 0xaa, 0xb0, 0x25, 0x3d, 0x58, 0x96, 0x37, 0x4b, 0x25,
	0xd2, 0x1b, 0xbb, 0xea, 0x4d, 0x69, 0x87, 0x32, 0xc8, 0x79, 0x6d, 0x80, 0xa9, 0x3a, 0x4d, 0xee,
	0x42, 0xd3, 0x9f, 0x04, 0xcf, 0xce, 0x62, 0x8a, 0xde, 0xac, 0x54, 0xc3, 0x73, 0x94, 0xaa, 0xdd,
	0xcc, 0x8e, 0x3c, 0x00, 0xf0, 0x47, 0xde, 0x74, 0x48, 0x45, 0xca, 0xca, 0x44, 0x51, 0x69, 0x3c,
	0xca, 0x95, 0xf2, 0x10, 0x57, 0xb1, 0x47, 0x74, 0x34, 0x89, 0x3d, 0x9f, 0x3f, 0x8e, 0x86, 0xd2,
	0x89, 0x12, 0x3a, 0x57, 0x16, 0xe8, 0x5c, 0x44, 0x1e, 0xc1, 0x0a, 0x67, 0xde, 0x34, 0x39, 0xa1,
	0xec, 0x71, 0xca, 0x41, 0x0d, 0x77, 0xe8, 0x28, 0x3b, 0x3c, 0x2b, 0x19, 0x64, 0xbb, 0x5c, 0xc2,
	0x89, 0x7b, 0x9c, 0x52, 0x16, 0x9e, 0x9c, 0x3d, 0xf2, 0x92, 0xec, 0x8d, 0xa9, 0xf7, 0x78, 0x9e,
	0x2b, 0xf3, 0x7b, 0x14, 0xf6, 0x22, 0x8d, 0x93, 0x78, 0x1c, 0xf2, 0x04, 0xdf, 0x5a, 0x19, 0xd9,
	0xf5, 0xb8, 0x3f, 0x3a, 0x16, 0xda, 0x0c, 0x29, 0x6d, 0x49, 0x17, 0xcc, 0x22, 0x12, 0xcf, 0xf7,
	0xed, 0x26, 0x62, 0xb7, 0xe6, 0xc6, 0xee, 0xf9, 0x7e, 0x86, 0x2e, 0x61, 0x9c, 0x37, 0x06, 0x2c,
	0x97, 0x88, 0xfe, 0x3f, 0x14, 0x1e, 0xcc, 0xa1, 0x70, 0x73, 0x01, 0x85, 0xe9, 0x29, 0x25, 0x0e,
	0x0f, 0xe6, 0x70, 0xb8, 0xb9, 0x80, 0xc3, 0x1c, 0x5e, 0x90, 0xd8, 0x5f, 0x40, 0xe2, 0x87, 0x57,
	0x90, 0x28, 0xb7, 0xb9, 0xcc, 0xe2, 0xc1, 0x1c, 0x16, 0x37, 0x17, 0xb0, 0x98, 0xdd, 0x44, 0xa1,
	0xf1, 0xab, 0x9c, 0xc6, 0xa5, 0x0a, 0x54, 0xa5, 0x51, 0x42, 0x33, 0x1e, 0x8f, 0x2e, 0xf1, 0x08,
	0x08, 0xde, 0x5e, 0xc8, 0xa3, 0x84, 0x97, 0x89, 0xfc, 0x5b, 0x87, 0x66, 0xf6, 0x0a, 0x17, 0x95,
	0xe3, 0x75, 0xa8, 0x0f, 0x59, 0x34, 0x8b, 0x65, 0x0f, 0x49, 0x17, 0xa2, 0x83, 0x70, 0xc1, 0xb6,
	0x81, 0x6c, 0xab, 0x95, 0xf0, 0xe8, 0x49, 0x0f, 0x89, 0x46, 0x3d, 0xd9, 0x02, 0xf0, 0x67, 0x09,
	0xa7, 0x13, 0xcc, 0x8d, 0x1a, 0x6e, 0xa1, 0x48, 0x88, 0x05, 0xc6, 0xaf, 0xf4, 0x0c, 0xa3, 0x66,
	0xba, 0xe2, 0x53, 0x48, 0xfc, 0x49, 0x80, 0x39, 0x6d, 0xba, 0xe2, 0x93, 0xbc, 0x0f, 0x46, 0x12,
	0x06, 0x98, 0xa9, 0x46, 0xb7, 0x79, 0x71, 0xbe, 0x6d, 0x1c, 0xf7, 0x7b, 0xae, 0x90, 0x09, 0x55,
	0x1c, 0x06, 0x76, 0xab, 0x50, 0x3d, 0x15, 0xaa, 0x38, 0x0c, 0xc8, 0x06, 0x34, 0x12, 0x1e, 0xc5,
	0x87, 0x1c, 0xe3, 0x6a, 0xb8, 0x72, 0x25, 0xba, 0x22, 0x8f, 0x8e, 0x45, 0x23, 0xc4, 0x98, 0xd5,
	0xdc, 0x6c, 0x49, 0x3e, 0x82, 0x65, 0x6f, 0x3c, 0x8e, 0x5e, 0xfe, 0x18, 0x89, 0xbf, 0x94, 0xd9,
	0xed, 0x8e, 0xb6, 0xd3, 0x72, 0xcb, 0x42, 0x61, 0x35, 0xf6, 0x12, 0xde, 0x65, 0x91, 0x17, 0xf8,
	0x5e, 0xc2, 0x6d, 0x33, 0xb5, 0x2a, 0x09, 0x9d, 0x37, 0x3a, 0xb4, 0xf2, 0xd7, 0xb1, 0x28, 0xb4,
	0x59, 0x10, 0xf5, 0x6b, 0x82, 0xb8, 0x0e, 0xf5, 0x53, 0x6f, 0x3c, 0x4b, 0xa3, 0x6d, 0xba, 0xe9,
	0x82, 0x7c, 0x0f, 0xcb, 0x11, 0x0b, 0x87, 0x45, 0x6f, 0x49, 0x33, 0x78, 0x71, 0x57, 0x2a, 0x9b,
	0x67, 0x61, 0xad, 0x2f, 0x0e, 0x6b, 0x63, 0x4e, 0x58, 0xf3, 0xee, 0xdc, 0xbc, 0xbe, 0x3b, 0x7f,
	0x0e, 0x6b, 0x7e, 0x34, 0xe5, 0xe1, 0x74, 0x46, 0x8b, 0x70, 0xb5, 0x30, 0x5c, 0x55, 0x85, 0xf0,
	0x32, 0xe1, 0xde, 0x98, 0x22, 0x5f, 0x2d, 0x37, 0x5d, 0x38, 0x09, 0xac, 0x55, 0x8a, 0x39, 0xb9,
	0x9f, 0xd5, 0x0e, 0xa5, 0xe2, 0x6c, 0x64, 0xc3, 0x49, 0x61, 0x8e, 0x21, 0x54, 0x2c, 0xf3, 0xb9,
	0x47, 0xbf, 0x7a, 0xee, 0x71, 0x0e, 0x81, 0x54, 0xcb, 0x0f, 0xf9, 0x0c, 0xea, 0x38, 0x40, 0xc9,
	0x9e, 0xbb, 0xba, 0x9b, 0x8f, 0x8e, 0x98, 0x3f, 0x99, 0xef, 0x68, 0xe3, 0xfc, 0x0c, 0x6b, 0x95,
	0x36, 0x42, 0x1c, 0x30, 0x65, 0x0d, 0xea, 0x4f, 0x03, 0xfa, 0x0a, 0x37, 0xaa, 0xb9, 0x25, 0x19,
	0x8e, 0x34, 0xe9, 0x1a, 0x47, 0x1a, 0x5d, 0x8e, 0x34, 0x85, 0xc8, 0x59, 0x07, 0x52, 0xad, 0x6e,
	0xce, 0x0f, 0x70, 0x6b, 0x6e, 0xd7, 0xc9, 0x9d, 0xd6, 0xae, 0x71, 0xda, 0x86, 0x8d, 0xf9, 0x15,
	0xcf, 0x79, 0x01, 0x6b, 0x95, 0x56, 0x24, 0xe8, 0x0a, 0x15, 0x27, 0xd2, 0x85, 0x18, 0xff, 0x46,
	0xa2, 0x0c, 0xea, 0x98, 0xa9, 0xf8, 0x2d, 0x5e, 0x9c, 0x60, 0x9b, 0xbe, 0xe2, 0x32, 0x81, 0xb3,
	0xa5, 0xf0, 0xa4, 0x5a, 0x1d, 0x9d, 0x5f, 0xc0, 0x54, 0x5b, 0x17, 0xb9, 0x0d, 0x2d, 0x2c, 0x7a,
	0x3f, 0xd1, 0xb3, 0xf4, 0x11, 0xb9, 0xf9, 0x5a, 0xd4, 0x97, 0x29, 0x7d, 0x79, 0x5c, 0x1a, 0x73,
	0x15, 0x89, 0xd4, 0x0b, 0x5f, 0xfb, 0xbd, 0xc4, 0x36, 0x3a, 0x86, 0xd4, 0x4b, 0x89, 0x13, 0xc3,
	0x5a, 0xa5, 0x57, 0x92, 0x6f, 0x95, 0x51, 0x4f, 0xc3, 0xf9, 0x48, 0x6d, 0x67, 0xaa, 0xa9, 0x0c,
	0x60, 0x31, 0xef, 0x75, 0xa0, 0xcd, 0xc2, 0xe1, 0x88, 0xf7, 0x28, 0x0b, 0x4f, 0xd3, 0x97, 0xdd,
	0x72, 0x55, 0x91, 0x73, 0x00, 0xa4, 0x5a, 0xd6, 0xc9, 0xa7, 0xd0, 0xc0, 0xbc, 0xc9, 0x0e, 0xbc,
	0x9c, 0x5c, 0xae, 0x54, 0x3b, 0xc7, 0x70, 0x73, 0x4e, 0x83, 0x26, 0x0f, 0xa0, 0x99, 0xe6, 0x79,
	0xb6, 0xc1, 0x95, 0xd3, 0x90, 0xbc, 0x76, 0x06, 0x71, 0x0e, 0x60, 0x7d, 0x5e, 0xb7, 0x20, 0x1f,
	0x5f, 0x9d, 0xf1, 0x32, 0xd7, 0xef, 0xf4, 0xa0, 0x29, 0x0b, 0x16, 0x69, 0x43, 0xb3, 0x3f, 0x3d,
	0xf5, 0xc6, 0x61, 0x60, 0xdd, 0x20, 0xcb, 0xb0, 0x24, 0x86, 0x51, 0xac, 0x0c, 0x96, 0x46, 0x5a,
	0x50, 0x3b, 0x9e, 0x7a, 0xb1, 0xa5, 0x93, 0x25, 0xa8, 0xbf, 0x60, 0x21, 0xa7, 0x96, 0x21, 0x84,
	0x2e, 0xf5, 0x02, 0xab, 0x76, 0xe7, 0x0f, 0x4d, 0xce, 0x85, 0x72, 0x54, 0x20, 0x16, 0x98, 0x72,
	0x2f, 0x14, 0x5b, 0x37, 0xc8, 0x0a, 0x40, 0x71, 0x4f, 0x4b, 0xc3, 0x75, 0xfe, 0x12, 0x2c, 0x9d,
	0x10, 0x58, 0x29, 0xa7, 0xb0, 0x65, 0x90, 0x55, 0x68, 0x0b, 0x9b, 0x19, 0xa7, 0x22, 0xc9, 0xac,
	0x9a, 0x00, 0x15, 0x49, 0x67, 0xd5, 0xc5, 0xba, 0x20, 0xc4, 0x6a, 0x88, 0x63, 0xd5, 0x60, 0x58,
	0xcd, 0xae, 0xf5, 0xee, 0xdf, 0x2d, 0xed, 0xed, 0xc5, 0x96, 0xf6, 0xee, 0x62, 0x4b, 0xfb, 0xe7,
	0x62, 0x4b, 0x1b, 0x34, 0xf0, 0xff, 0xb1, 0x2f, 0xff, 0x0b, 0x00, 0x00, 0xff, 0xff, 0x47, 0xa9,
	0xf6, 0x43, 0x84, 0x0e, 0x00, 0x00,
}

func (m *RaftRequestHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftRequestHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftRequestHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Term != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x30
	}
	{
		size, err := m.Epoch.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.ShardID != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.ShardID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RaftResponseHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftResponseHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftResponseHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CurrentTerm != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.CurrentTerm))
		i--
		dAtA[i] = 0x18
	}
	{
		size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RaftCMDRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftCMDRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftCMDRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AdminRequest != nil {
		{
			size, err := m.AdminRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Requests) > 0 {
		for iNdEx := len(m.Requests) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Requests[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RaftCMDResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftCMDResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftCMDResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AdminResponse != nil {
		{
			size, err := m.AdminResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Responses) > 0 {
		for iNdEx := len(m.Responses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Responses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AdminRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ChangePeerV2 != nil {
		{
			size, err := m.ChangePeerV2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Splits != nil {
		{
			size, err := m.Splits.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.VerifyHash != nil {
		{
			size, err := m.VerifyHash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.TransferLeader != nil {
		{
			size, err := m.TransferLeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.CompactLog != nil {
		{
			size, err := m.CompactLog.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ChangePeer != nil {
		{
			size, err := m.ChangePeer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CmdType != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.CmdType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AdminResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AdminResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AdminResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ChangePeerV2 != nil {
		{
			size, err := m.ChangePeerV2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Splits != nil {
		{
			size, err := m.Splits.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.VerifyHash != nil {
		{
			size, err := m.VerifyHash.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.TransferLeader != nil {
		{
			size, err := m.TransferLeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.CompactLog != nil {
		{
			size, err := m.CompactLog.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.ChangePeer != nil {
		{
			size, err := m.ChangePeer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.CmdType != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.CmdType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LastBroadcast {
		i--
		if m.LastBroadcast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.AllowFollower {
		i--
		if m.AllowFollower {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.ToShard != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.ToShard))
		i--
		dAtA[i] = 0x50
	}
	if m.StopAt != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.StopAt))
		i--
		dAtA[i] = 0x48
	}
	if m.PID != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.PID))
		i--
		dAtA[i] = 0x40
	}
	if m.SID != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.SID))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Cmd) > 0 {
		i -= len(m.Cmd)
		copy(dAtA[i:], m.Cmd)
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(len(m.Cmd)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x2a
	}
	if m.CustemType != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.CustemType))
		i--
		dAtA[i] = 0x20
	}
	if m.Type != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.Group != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.Group))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stale {
		i--
		if m.Stale {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.ContinueBroadcast {
		i--
		if m.ContinueBroadcast {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	{
		size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if m.PID != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.PID))
		i--
		dAtA[i] = 0x30
	}
	if m.SID != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.SID))
		i--
		dAtA[i] = 0x28
	}
	if m.OriginRequest != nil {
		{
			size, err := m.OriginRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChangePeerRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangePeerRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangePeerRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.ChangeType != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.ChangeType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChangePeerResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangePeerResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangePeerResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Shard.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CompactLogRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactLogRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactLogRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CompactTerm != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.CompactTerm))
		i--
		dAtA[i] = 0x10
	}
	if m.CompactIndex != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.CompactIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CompactLogResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactLogResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactLogResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *TransferLeaderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferLeaderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferLeaderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Peer.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TransferLeaderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferLeaderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferLeaderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *VerifyHashRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyHashRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyHashRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Context) > 0 {
		i -= len(m.Context)
		copy(dAtA[i:], m.Context)
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(len(m.Context)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x12
	}
	if m.Index != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VerifyHashResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyHashResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyHashResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *SplitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SplitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NewPeerIDs) > 0 {
		dAtA26 := make([]byte, len(m.NewPeerIDs)*10)
		var j25 int
		for _, num := range m.NewPeerIDs {
			for num >= 1<<7 {
				dAtA26[j25] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j25++
			}
			dAtA26[j25] = uint8(num)
			j25++
		}
		i -= j25
		copy(dAtA[i:], dAtA26[:j25])
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(j25))
		i--
		dAtA[i] = 0x1a
	}
	if m.NewShardID != 0 {
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(m.NewShardID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.SplitKey) > 0 {
		i -= len(m.SplitKey)
		copy(dAtA[i:], m.SplitKey)
		i = encodeVarintRaftcmdpb(dAtA, i, uint64(len(m.SplitKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchSplitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSplitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSplitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RightDerive {
		i--
		if m.RightDerive {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Requests) > 0 {
		for iNdEx := len(m.Requests) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Requests[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BatchSplitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSplitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSplitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Shards) > 0 {
		for iNdEx := len(m.Shards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Shards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ChangePeerV2Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangePeerV2Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangePeerV2Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Changes) > 0 {
		for iNdEx := len(m.Changes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Changes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ChangePeerV2Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangePeerV2Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangePeerV2Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Shard != nil {
		{
			size, err := m.Shard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaftcmdpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintRaftcmdpb(dAtA []byte, offset int, v uint64) int {
	offset -= sovRaftcmdpb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RaftRequestHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.ShardID != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.ShardID))
	}
	l = m.Peer.Size()
	n += 1 + l + sovRaftcmdpb(uint64(l))
	l = m.Epoch.Size()
	n += 1 + l + sovRaftcmdpb(uint64(l))
	if m.Term != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.Term))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftResponseHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	l = m.Error.Size()
	n += 1 + l + sovRaftcmdpb(uint64(l))
	if m.CurrentTerm != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.CurrentTerm))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftCMDRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovRaftcmdpb(uint64(l))
		}
	}
	if m.AdminRequest != nil {
		l = m.AdminRequest.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftCMDResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if len(m.Responses) > 0 {
		for _, e := range m.Responses {
			l = e.Size()
			n += 1 + l + sovRaftcmdpb(uint64(l))
		}
	}
	if m.AdminResponse != nil {
		l = m.AdminResponse.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AdminRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdType != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.CmdType))
	}
	if m.ChangePeer != nil {
		l = m.ChangePeer.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.CompactLog != nil {
		l = m.CompactLog.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.TransferLeader != nil {
		l = m.TransferLeader.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.VerifyHash != nil {
		l = m.VerifyHash.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.Splits != nil {
		l = m.Splits.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.ChangePeerV2 != nil {
		l = m.ChangePeerV2.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AdminResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CmdType != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.CmdType))
	}
	if m.ChangePeer != nil {
		l = m.ChangePeer.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.CompactLog != nil {
		l = m.CompactLog.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.TransferLeader != nil {
		l = m.TransferLeader.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.VerifyHash != nil {
		l = m.VerifyHash.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.Splits != nil {
		l = m.Splits.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.ChangePeerV2 != nil {
		l = m.ChangePeerV2.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.Group != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.Group))
	}
	if m.Type != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.Type))
	}
	if m.CustemType != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.CustemType))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	l = len(m.Cmd)
	if l > 0 {
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.SID != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.SID))
	}
	if m.PID != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.PID))
	}
	if m.StopAt != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.StopAt))
	}
	if m.ToShard != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.ToShard))
	}
	if m.AllowFollower {
		n += 2
	}
	if m.LastBroadcast {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.Type))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.OriginRequest != nil {
		l = m.OriginRequest.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.SID != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.SID))
	}
	if m.PID != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.PID))
	}
	l = m.Error.Size()
	n += 1 + l + sovRaftcmdpb(uint64(l))
	if m.ContinueBroadcast {
		n += 2
	}
	if m.Stale {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChangePeerRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChangeType != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.ChangeType))
	}
	l = m.Peer.Size()
	n += 1 + l + sovRaftcmdpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChangePeerResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Shard.Size()
	n += 1 + l + sovRaftcmdpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CompactLogRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompactIndex != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.CompactIndex))
	}
	if m.CompactTerm != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.CompactTerm))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CompactLogResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransferLeaderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Peer.Size()
	n += 1 + l + sovRaftcmdpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransferLeaderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyHashRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.Index))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	l = len(m.Context)
	if l > 0 {
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyHashResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SplitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SplitKey)
	if l > 0 {
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.NewShardID != 0 {
		n += 1 + sovRaftcmdpb(uint64(m.NewShardID))
	}
	if len(m.NewPeerIDs) > 0 {
		l = 0
		for _, e := range m.NewPeerIDs {
			l += sovRaftcmdpb(uint64(e))
		}
		n += 1 + sovRaftcmdpb(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BatchSplitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovRaftcmdpb(uint64(l))
		}
	}
	if m.RightDerive {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BatchSplitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Shards) > 0 {
		for _, e := range m.Shards {
			l = e.Size()
			n += 1 + l + sovRaftcmdpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChangePeerV2Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for _, e := range m.Changes {
			l = e.Size()
			n += 1 + l + sovRaftcmdpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChangePeerV2Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Shard != nil {
		l = m.Shard.Size()
		n += 1 + l + sovRaftcmdpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovRaftcmdpb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRaftcmdpb(x uint64) (n int) {
	return sovRaftcmdpb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RaftRequestHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftRequestHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftRequestHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Epoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftResponseHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftResponseHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftResponseHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentTerm", wireType)
			}
			m.CurrentTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentTerm |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftCMDRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftCMDRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftCMDRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RaftRequestHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, &Request{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdminRequest == nil {
				m.AdminRequest = &AdminRequest{}
			}
			if err := m.AdminRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftCMDResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftCMDResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftCMDResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &RaftResponseHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Responses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Responses = append(m.Responses, &Response{})
			if err := m.Responses[len(m.Responses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AdminResponse == nil {
				m.AdminResponse = &AdminResponse{}
			}
			if err := m.AdminResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdType", wireType)
			}
			m.CmdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdType |= AdminCmdType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangePeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangePeer == nil {
				m.ChangePeer = &ChangePeerRequest{}
			}
			if err := m.ChangePeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompactLog == nil {
				m.CompactLog = &CompactLogRequest{}
			}
			if err := m.CompactLog.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferLeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransferLeader == nil {
				m.TransferLeader = &TransferLeaderRequest{}
			}
			if err := m.TransferLeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VerifyHash == nil {
				m.VerifyHash = &VerifyHashRequest{}
			}
			if err := m.VerifyHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Splits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Splits == nil {
				m.Splits = &BatchSplitRequest{}
			}
			if err := m.Splits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangePeerV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangePeerV2 == nil {
				m.ChangePeerV2 = &ChangePeerV2Request{}
			}
			if err := m.ChangePeerV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AdminResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AdminResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AdminResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CmdType", wireType)
			}
			m.CmdType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CmdType |= AdminCmdType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangePeer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangePeer == nil {
				m.ChangePeer = &ChangePeerResponse{}
			}
			if err := m.ChangePeer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactLog", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompactLog == nil {
				m.CompactLog = &CompactLogResponse{}
			}
			if err := m.CompactLog.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferLeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransferLeader == nil {
				m.TransferLeader = &TransferLeaderResponse{}
			}
			if err := m.TransferLeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VerifyHash == nil {
				m.VerifyHash = &VerifyHashResponse{}
			}
			if err := m.VerifyHash.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Splits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Splits == nil {
				m.Splits = &BatchSplitResponse{}
			}
			if err := m.Splits.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangePeerV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChangePeerV2 == nil {
				m.ChangePeerV2 = &ChangePeerV2Response{}
			}
			if err := m.ChangePeerV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= CMDType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustemType", wireType)
			}
			m.CustemType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CustemType |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cmd = append(m.Cmd[:0], dAtA[iNdEx:postIndex]...)
			if m.Cmd == nil {
				m.Cmd = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SID", wireType)
			}
			m.SID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PID", wireType)
			}
			m.PID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopAt", wireType)
			}
			m.StopAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StopAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToShard", wireType)
			}
			m.ToShard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToShard |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllowFollower", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AllowFollower = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBroadcast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LastBroadcast = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= CMDType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.OriginRequest == nil {
				m.OriginRequest = &Request{}
			}
			if err := m.OriginRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SID", wireType)
			}
			m.SID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PID", wireType)
			}
			m.PID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContinueBroadcast", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContinueBroadcast = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stale", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Stale = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangePeerRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangePeerRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangePeerRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeType", wireType)
			}
			m.ChangeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeType |= metapb.ChangePeerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangePeerResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangePeerResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangePeerResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactLogRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactLogRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactLogRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactIndex", wireType)
			}
			m.CompactIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactTerm", wireType)
			}
			m.CompactTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactTerm |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactLogResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactLogResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactLogResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferLeaderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferLeaderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferLeaderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Peer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferLeaderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferLeaderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferLeaderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyHashRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyHashRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyHashRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = append(m.Context[:0], dAtA[iNdEx:postIndex]...)
			if m.Context == nil {
				m.Context = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyHashResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyHashResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyHashResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SplitKey = append(m.SplitKey[:0], dAtA[iNdEx:postIndex]...)
			if m.SplitKey == nil {
				m.SplitKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewShardID", wireType)
			}
			m.NewShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewShardID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaftcmdpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NewPeerIDs = append(m.NewPeerIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaftcmdpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRaftcmdpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRaftcmdpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NewPeerIDs) == 0 {
					m.NewPeerIDs = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaftcmdpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NewPeerIDs = append(m.NewPeerIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NewPeerIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSplitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSplitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSplitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, SplitRequest{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightDerive", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RightDerive = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSplitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSplitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSplitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, &bhmetapb.Shard{})
			if err := m.Shards[len(m.Shards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangePeerV2Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangePeerV2Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangePeerV2Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changes = append(m.Changes, ChangePeerRequest{})
			if err := m.Changes[len(m.Changes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangePeerV2Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangePeerV2Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangePeerV2Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Shard == nil {
				m.Shard = &bhmetapb.Shard{}
			}
			if err := m.Shard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaftcmdpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaftcmdpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRaftcmdpb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRaftcmdpb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaftcmdpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRaftcmdpb
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRaftcmdpb
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRaftcmdpb
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRaftcmdpb        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRaftcmdpb          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRaftcmdpb = fmt.Errorf("proto: unexpected end of group")
)
