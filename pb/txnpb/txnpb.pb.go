// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: txnpb.proto

package txnpb

import (
	fmt "fmt"
	io "io"
	math "math"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Isolation is the transaction isolation Level
type Isolation int32

const (
	// RC read committed
	Isolation_RC Isolation = 0
	// RCReadOnly read committed, but only read-only transaction
	Isolation_RCReadOnly Isolation = 1
	// SI snapshot serializable
	Isolation_SI Isolation = 2
)

var Isolation_name = map[int32]string{
	0: "RC",
	1: "RCReadOnly",
	2: "SI",
}

var Isolation_value = map[string]int32{
	"RC":         0,
	"RCReadOnly": 1,
	"SI":         2,
}

func (x Isolation) String() string {
	return proto.EnumName(Isolation_name, int32(x))
}

func (Isolation) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{0}
}

// TxnStatus transaction status
type TxnStatus int32

const (
	// Pending indicates that the transaction is in progress.
	TxnStatus_Pending TxnStatus = 0
	// Staging the parallel-commit optimization sets the transaction
	// to this state, indicating that it is not sure if all writes
	// have succeeded, and that you need to verify that all writes have
	// succeeded when you encounter this state. May be converted to
	// `Committed` or `Aborted` state.
	TxnStatus_Staging TxnStatus = 1
	// Committed this is a final status indicating that the transaction
	// has been committed.
	TxnStatus_Committed TxnStatus = 2
	// Committed this is a final status indicating that the transaction
	// has been aborted.
	TxnStatus_Aborted TxnStatus = 3
)

var TxnStatus_name = map[int32]string{
	0: "Pending",
	1: "Staging",
	2: "Committed",
	3: "Aborted",
}

var TxnStatus_value = map[string]int32{
	"Pending":   0,
	"Staging":   1,
	"Committed": 2,
	"Aborted":   3,
}

func (x TxnStatus) String() string {
	return proto.EnumName(TxnStatus_name, int32(x))
}

func (TxnStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{1}
}

// TxnRequestType transaction request type
type TxnRequestType int32

const (
	// Read read request
	TxnRequestType_Read TxnRequestType = 0
	// Write write request
	TxnRequestType_Write TxnRequestType = 1
	// Commit commit request
	TxnRequestType_Commit TxnRequestType = 2
	// Rollback rollback request
	TxnRequestType_Rollback TxnRequestType = 3
)

var TxnRequestType_name = map[int32]string{
	0: "Read",
	1: "Write",
	2: "Commit",
	3: "Rollback",
}

var TxnRequestType_value = map[string]int32{
	"Read":     0,
	"Write":    1,
	"Commit":   2,
	"Rollback": 3,
}

func (x TxnRequestType) String() string {
	return proto.EnumName(TxnRequestType_name, int32(x))
}

func (TxnRequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{2}
}

// TxnMeta transaction metadata, which will be integrated into TxnRecord and
// TxnOpMeta for persistent storage.
type TxnMeta struct {
	// ID transction id
	ID []byte `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Name transaction name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Isolation transaction isolation level
	Isolation Isolation `protobuf:"varint,3,opt,name=isolation,proto3,enum=txnpb.Isolation" json:"isolation,omitempty"`
	// TxnRecordRouteKey used to locate which Shard the TxnRecord is in.
	TxnRecordRouteKey []byte `protobuf:"bytes,4,opt,name=txnRecordRouteKey,proto3" json:"txnRecordRouteKey,omitempty"`
	// Epoch used to indicate the number of restarts of a transaction.
	// Each time a transaction is restarted, the field +1.
	Epoch uint32 `protobuf:"varint,5,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// Priority transaction priority, used for transaction conflict, according
	// to the priority of the decision to abort which a transaction.
	Priority uint64 `protobuf:"varint,6,opt,name=priority,proto3" json:"priority,omitempty"`
	// WriteTimestamp the timestamp version number of the data written by the
	// transaction, this version number may be raised in several scenarios.
	WriteTimestamp uint64 `protobuf:"varint,7,opt,name=writeTimestamp,proto3" json:"writeTimestamp,omitempty"`
	// ReadTimestamp the timestamp of the start of the transaction, which is used
	// to read the data from MVCC, in some scenarios this timestamp will be raised
	// to avoid some conflicts and ambiguities.
	ReadTimestamp uint64 `protobuf:"varint,8,opt,name=readTimestamp,proto3" json:"readTimestamp,omitempty"`
	// MaxTimestamp if using HLC's clocking scheme, this field is equal to Readtimestamp
	// + maximum clock skew, which is used to indicate an upper limit of uncertainty
	// time.
	MaxTimestamp         uint64   `protobuf:"varint,9,opt,name=maxTimestamp,proto3" json:"maxTimestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnMeta) Reset()         { *m = TxnMeta{} }
func (m *TxnMeta) String() string { return proto.CompactTextString(m) }
func (*TxnMeta) ProtoMessage()    {}
func (*TxnMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{0}
}
func (m *TxnMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnMeta.Merge(m, src)
}
func (m *TxnMeta) XXX_Size() int {
	return m.Size()
}
func (m *TxnMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnMeta.DiscardUnknown(m)
}

var xxx_messageInfo_TxnMeta proto.InternalMessageInfo

func (m *TxnMeta) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *TxnMeta) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TxnMeta) GetIsolation() Isolation {
	if m != nil {
		return m.Isolation
	}
	return Isolation_RC
}

func (m *TxnMeta) GetTxnRecordRouteKey() []byte {
	if m != nil {
		return m.TxnRecordRouteKey
	}
	return nil
}

func (m *TxnMeta) GetEpoch() uint32 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *TxnMeta) GetPriority() uint64 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *TxnMeta) GetWriteTimestamp() uint64 {
	if m != nil {
		return m.WriteTimestamp
	}
	return 0
}

func (m *TxnMeta) GetReadTimestamp() uint64 {
	if m != nil {
		return m.ReadTimestamp
	}
	return 0
}

func (m *TxnMeta) GetMaxTimestamp() uint64 {
	if m != nil {
		return m.MaxTimestamp
	}
	return 0
}

// TxnRecord similar to Txn, but only the fields that need to be persisted to
// disk are kept. A TxnRecord is the central store of a transaction, with the
// global state of the transaction and the Key of all written data. Once the
// status of the TxnRecord changes to `Committed`, then all data written by the
// transaction is visible atomically.
type TxnRecord struct {
	// TxnMeta embed txn meta
	TxnMeta `protobuf:"bytes,1,opt,name=txnMeta,proto3,embedded=txnMeta" json:"txnMeta"`
	// TxnStatus transaction status
	Status TxnStatus `protobuf:"varint,2,opt,name=status,proto3,enum=txnpb.TxnStatus" json:"status,omitempty"`
	// LastHeartbeat the last time the transaction coordinator sent a heartbeat,
	// this field is used to check if the transaction can't continue due to the
	// transaction coordinator being down, thus rolling back the transaction.
	LastHeartbeat uint64 `protobuf:"varint,3,opt,name=lastHeartbeat,proto3" json:"lastHeartbeat,omitempty"`
	// CompletedWrites record the current transaction has completed the consensus write
	// operation.
	CompletedWrites KeySet `protobuf:"bytes,4,opt,name=completedWrites,proto3" json:"completedWrites"`
	// InfightWrites record the current transaction has not completed the consensus write
	// operation.
	InfightWrites        KeySet   `protobuf:"bytes,5,opt,name=infightWrites,proto3" json:"infightWrites"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnRecord) Reset()         { *m = TxnRecord{} }
func (m *TxnRecord) String() string { return proto.CompactTextString(m) }
func (*TxnRecord) ProtoMessage()    {}
func (*TxnRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{1}
}
func (m *TxnRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnRecord.Merge(m, src)
}
func (m *TxnRecord) XXX_Size() int {
	return m.Size()
}
func (m *TxnRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnRecord.DiscardUnknown(m)
}

var xxx_messageInfo_TxnRecord proto.InternalMessageInfo

func (m *TxnRecord) GetStatus() TxnStatus {
	if m != nil {
		return m.Status
	}
	return TxnStatus_Pending
}

func (m *TxnRecord) GetLastHeartbeat() uint64 {
	if m != nil {
		return m.LastHeartbeat
	}
	return 0
}

func (m *TxnRecord) GetCompletedWrites() KeySet {
	if m != nil {
		return m.CompletedWrites
	}
	return KeySet{}
}

func (m *TxnRecord) GetInfightWrites() KeySet {
	if m != nil {
		return m.InfightWrites
	}
	return KeySet{}
}

// TxnOpMeta metadata for transaction operations, with fields related to the
// current operation of the transaction added to TxnMeta.
type TxnOpMeta struct {
	// TxnMeta embed txn meta
	TxnMeta `protobuf:"bytes,1,opt,name=txnMeta,proto3,embedded=txnMeta" json:"txnMeta"`
	// OriginKey the origin data key without any transaction codec
	OriginKey []byte `protobuf:"bytes,2,opt,name=originKey,proto3" json:"originKey,omitempty"`
	// Sequence indicates the current number of write operations in the transaction.
	// Of all the operations in the transaction, only the write operation will increase
	// the value of the field, the read operation will not. Used to implement the `read
	// your write`.
	Sequence uint32 `protobuf:"varint,3,opt,name=sequence,proto3" json:"sequence,omitempty"`
	// CompletedWrites record the current transaction has completed the consensus write
	// operation. Only when it is a Commit or Rollback transaction, it will be attached.
	CompletedWrites *KeySet `protobuf:"bytes,4,opt,name=completedWrites,proto3" json:"completedWrites,omitempty"`
	// InfightWrites record the current transaction has not completed the consensus write
	// operation. Only when it is a Commit or Rollback transaction, it will be attached.
	InfightWrites        *KeySet  `protobuf:"bytes,5,opt,name=infightWrites,proto3" json:"infightWrites,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnOpMeta) Reset()         { *m = TxnOpMeta{} }
func (m *TxnOpMeta) String() string { return proto.CompactTextString(m) }
func (*TxnOpMeta) ProtoMessage()    {}
func (*TxnOpMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{2}
}
func (m *TxnOpMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnOpMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnOpMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnOpMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnOpMeta.Merge(m, src)
}
func (m *TxnOpMeta) XXX_Size() int {
	return m.Size()
}
func (m *TxnOpMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnOpMeta.DiscardUnknown(m)
}

var xxx_messageInfo_TxnOpMeta proto.InternalMessageInfo

func (m *TxnOpMeta) GetOriginKey() []byte {
	if m != nil {
		return m.OriginKey
	}
	return nil
}

func (m *TxnOpMeta) GetSequence() uint32 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *TxnOpMeta) GetCompletedWrites() *KeySet {
	if m != nil {
		return m.CompletedWrites
	}
	return nil
}

func (m *TxnOpMeta) GetInfightWrites() *KeySet {
	if m != nil {
		return m.InfightWrites
	}
	return nil
}

// KeyRange description of the set of Keys in the range [start, end)
type KeyRange struct {
	// Start start key, include
	Start []byte `protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"`
	// End end key, exclude
	End                  []byte   `protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyRange) Reset()         { *m = KeyRange{} }
func (m *KeyRange) String() string { return proto.CompactTextString(m) }
func (*KeyRange) ProtoMessage()    {}
func (*KeyRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{3}
}
func (m *KeyRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyRange.Merge(m, src)
}
func (m *KeyRange) XXX_Size() int {
	return m.Size()
}
func (m *KeyRange) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyRange.DiscardUnknown(m)
}

var xxx_messageInfo_KeyRange proto.InternalMessageInfo

func (m *KeyRange) GetStart() []byte {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *KeyRange) GetEnd() []byte {
	if m != nil {
		return m.End
	}
	return nil
}

// KeySet key collection, with a set of individual Keys and a set of KeyRanges.
// This structure can be compressed, for example by using a KeyRange to represent
// a set of Keys, or by using a KeyRange with a larger range instead of multiple
// KeyRanges with smaller ranges.
type KeySet struct {
	// PointKeys the `originKey` set of explicit point data.
	PointKeys [][]byte `protobuf:"bytes,1,rep,name=pointKeys,proto3" json:"pointKeys,omitempty"`
	// Ranges the set of range `originKey`
	Ranges               []KeyRange `protobuf:"bytes,2,rep,name=ranges,proto3" json:"ranges"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *KeySet) Reset()         { *m = KeySet{} }
func (m *KeySet) String() string { return proto.CompactTextString(m) }
func (*KeySet) ProtoMessage()    {}
func (*KeySet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{4}
}
func (m *KeySet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeySet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeySet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeySet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeySet.Merge(m, src)
}
func (m *KeySet) XXX_Size() int {
	return m.Size()
}
func (m *KeySet) XXX_DiscardUnknown() {
	xxx_messageInfo_KeySet.DiscardUnknown(m)
}

var xxx_messageInfo_KeySet proto.InternalMessageInfo

func (m *KeySet) GetPointKeys() [][]byte {
	if m != nil {
		return m.PointKeys
	}
	return nil
}

func (m *KeySet) GetRanges() []KeyRange {
	if m != nil {
		return m.Ranges
	}
	return nil
}

// TxnOperation a operation for transaction. Called at TxnOperator and executed on
// the Lease Holder of Shard.
type TxnOperation struct {
	// Op the specific type of request, e.g. Set/Get/Delete.
	Op uint32 `protobuf:"varint,1,opt,name=op,proto3" json:"op,omitempty"`
	// Payload the data of request.
	Payload []byte `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	// Impacted impact data KeySet for transaction framework to do conflict detection,
	// Lock, Latch and asynchronous consensus optimization.
	Impacted             KeySet   `protobuf:"bytes,3,opt,name=impacted,proto3" json:"impacted"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnOperation) Reset()         { *m = TxnOperation{} }
func (m *TxnOperation) String() string { return proto.CompactTextString(m) }
func (*TxnOperation) ProtoMessage()    {}
func (*TxnOperation) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{5}
}
func (m *TxnOperation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnOperation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnOperation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnOperation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnOperation.Merge(m, src)
}
func (m *TxnOperation) XXX_Size() int {
	return m.Size()
}
func (m *TxnOperation) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnOperation.DiscardUnknown(m)
}

var xxx_messageInfo_TxnOperation proto.InternalMessageInfo

func (m *TxnOperation) GetOp() uint32 {
	if m != nil {
		return m.Op
	}
	return 0
}

func (m *TxnOperation) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *TxnOperation) GetImpacted() KeySet {
	if m != nil {
		return m.Impacted
	}
	return KeySet{}
}

// TxnBatchRequest transaction operations are converted into multiple transaction
// requests, contained by a TxnBatchRequest.
type TxnBatchRequest struct {
	Header               TxnBatchRequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Requests             []*TxnRequest         `protobuf:"bytes,2,rep,name=requests,proto3" json:"requests,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *TxnBatchRequest) Reset()         { *m = TxnBatchRequest{} }
func (m *TxnBatchRequest) String() string { return proto.CompactTextString(m) }
func (*TxnBatchRequest) ProtoMessage()    {}
func (*TxnBatchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{6}
}
func (m *TxnBatchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnBatchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnBatchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnBatchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnBatchRequest.Merge(m, src)
}
func (m *TxnBatchRequest) XXX_Size() int {
	return m.Size()
}
func (m *TxnBatchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnBatchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TxnBatchRequest proto.InternalMessageInfo

func (m *TxnBatchRequest) GetHeader() TxnBatchRequestHeader {
	if m != nil {
		return m.Header
	}
	return TxnBatchRequestHeader{}
}

func (m *TxnBatchRequest) GetRequests() []*TxnRequest {
	if m != nil {
		return m.Requests
	}
	return nil
}

// TxnBatchRequestHeader the head of TxnBatchRequest.
type TxnBatchRequestHeader struct {
	// TxnOpMeta transaction operation metadata
	Txn TxnOpMeta `protobuf:"bytes,1,opt,name=txn,proto3" json:"txn"`
	// ToShard shardID that handles the request
	ToShard uint64 `protobuf:"varint,2,opt,name=toShard,proto3" json:"toShard,omitempty"`
	// TxnRequestType request type, decide to call `HandleRead` or `HandleWrite`
	Type                 TxnRequestType `protobuf:"varint,3,opt,name=type,proto3,enum=txnpb.TxnRequestType" json:"type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TxnBatchRequestHeader) Reset()         { *m = TxnBatchRequestHeader{} }
func (m *TxnBatchRequestHeader) String() string { return proto.CompactTextString(m) }
func (*TxnBatchRequestHeader) ProtoMessage()    {}
func (*TxnBatchRequestHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{7}
}
func (m *TxnBatchRequestHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnBatchRequestHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnBatchRequestHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnBatchRequestHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnBatchRequestHeader.Merge(m, src)
}
func (m *TxnBatchRequestHeader) XXX_Size() int {
	return m.Size()
}
func (m *TxnBatchRequestHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnBatchRequestHeader.DiscardUnknown(m)
}

var xxx_messageInfo_TxnBatchRequestHeader proto.InternalMessageInfo

func (m *TxnBatchRequestHeader) GetTxn() TxnOpMeta {
	if m != nil {
		return m.Txn
	}
	return TxnOpMeta{}
}

func (m *TxnBatchRequestHeader) GetToShard() uint64 {
	if m != nil {
		return m.ToShard
	}
	return 0
}

func (m *TxnBatchRequestHeader) GetType() TxnRequestType {
	if m != nil {
		return m.Type
	}
	return TxnRequestType_Read
}

// TxnRequest transaction request, corresponds to a TxnOperation
type TxnRequest struct {
	// Operation the TxnOperation
	Operation            TxnOperation `protobuf:"bytes,1,opt,name=operation,proto3" json:"operation"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *TxnRequest) Reset()         { *m = TxnRequest{} }
func (m *TxnRequest) String() string { return proto.CompactTextString(m) }
func (*TxnRequest) ProtoMessage()    {}
func (*TxnRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{8}
}
func (m *TxnRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnRequest.Merge(m, src)
}
func (m *TxnRequest) XXX_Size() int {
	return m.Size()
}
func (m *TxnRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TxnRequest proto.InternalMessageInfo

func (m *TxnRequest) GetOperation() TxnOperation {
	if m != nil {
		return m.Operation
	}
	return TxnOperation{}
}

// TxnResponse is TxnOperation response
type TxnResponse struct {
	// Data is returned by `HandleRead` or `HandleWrite`
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnResponse) Reset()         { *m = TxnResponse{} }
func (m *TxnResponse) String() string { return proto.CompactTextString(m) }
func (*TxnResponse) ProtoMessage()    {}
func (*TxnResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{9}
}
func (m *TxnResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnResponse.Merge(m, src)
}
func (m *TxnResponse) XXX_Size() int {
	return m.Size()
}
func (m *TxnResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TxnResponse proto.InternalMessageInfo

func (m *TxnResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterEnum("txnpb.Isolation", Isolation_name, Isolation_value)
	proto.RegisterEnum("txnpb.TxnStatus", TxnStatus_name, TxnStatus_value)
	proto.RegisterEnum("txnpb.TxnRequestType", TxnRequestType_name, TxnRequestType_value)
	proto.RegisterType((*TxnMeta)(nil), "txnpb.TxnMeta")
	proto.RegisterType((*TxnRecord)(nil), "txnpb.TxnRecord")
	proto.RegisterType((*TxnOpMeta)(nil), "txnpb.TxnOpMeta")
	proto.RegisterType((*KeyRange)(nil), "txnpb.KeyRange")
	proto.RegisterType((*KeySet)(nil), "txnpb.KeySet")
	proto.RegisterType((*TxnOperation)(nil), "txnpb.TxnOperation")
	proto.RegisterType((*TxnBatchRequest)(nil), "txnpb.TxnBatchRequest")
	proto.RegisterType((*TxnBatchRequestHeader)(nil), "txnpb.TxnBatchRequestHeader")
	proto.RegisterType((*TxnRequest)(nil), "txnpb.TxnRequest")
	proto.RegisterType((*TxnResponse)(nil), "txnpb.TxnResponse")
}

func init() { proto.RegisterFile("txnpb.proto", fileDescriptor_4cec01c879ff9f20) }

var fileDescriptor_4cec01c879ff9f20 = []byte{
	// 835 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x55, 0xdd, 0x6e, 0xe3, 0x44,
	0x18, 0xad, 0x9d, 0xc4, 0x89, 0xbf, 0xfc, 0xd4, 0xfb, 0xc1, 0x22, 0x6b, 0xb5, 0x6a, 0x83, 0x85,
	0x50, 0x28, 0xb4, 0x95, 0xb2, 0x17, 0x2b, 0x90, 0x10, 0xda, 0x14, 0xa4, 0xad, 0x2a, 0xb4, 0x68,
	0x12, 0xc4, 0xf5, 0x24, 0x9e, 0x4d, 0x46, 0xc4, 0x33, 0xc6, 0x9e, 0x88, 0x58, 0xe2, 0x1a, 0x89,
	0x27, 0xe2, 0x15, 0xf6, 0xb2, 0x4f, 0x50, 0x41, 0x6f, 0x78, 0x0d, 0x34, 0xe3, 0x71, 0xdc, 0xb4,
	0xac, 0x54, 0x71, 0xe7, 0xf3, 0xcd, 0x99, 0x99, 0x73, 0xce, 0x7c, 0x33, 0x86, 0xae, 0xda, 0x8a,
	0x74, 0x7e, 0x96, 0x66, 0x52, 0x49, 0x6c, 0x19, 0xf0, 0xec, 0x74, 0xc9, 0xd5, 0x6a, 0x33, 0x3f,
	0x5b, 0xc8, 0xe4, 0x7c, 0x29, 0x97, 0xf2, 0xdc, 0x8c, 0xce, 0x37, 0x6f, 0x0d, 0x32, 0xc0, 0x7c,
	0x95, 0xb3, 0xa2, 0x3f, 0x5d, 0x68, 0xcf, 0xb6, 0xe2, 0x7b, 0xa6, 0x28, 0x7e, 0x04, 0x2e, 0x8f,
	0x43, 0x67, 0xe8, 0x8c, 0x7a, 0x13, 0xef, 0xf6, 0xe6, 0xd8, 0xbd, 0xfc, 0x96, 0xb8, 0x3c, 0x46,
	0x84, 0xa6, 0xa0, 0x09, 0x0b, 0xdd, 0xa1, 0x33, 0xf2, 0x89, 0xf9, 0xc6, 0x33, 0xf0, 0x79, 0x2e,
	0xd7, 0x54, 0x71, 0x29, 0xc2, 0xc6, 0xd0, 0x19, 0x0d, 0xc6, 0xc1, 0x59, 0x29, 0xe7, 0xb2, 0xaa,
	0x93, 0x9a, 0x82, 0x5f, 0xc0, 0x13, 0xb5, 0x15, 0x84, 0x2d, 0x64, 0x16, 0x13, 0xb9, 0x51, 0xec,
	0x8a, 0x15, 0x61, 0x53, 0x6f, 0x45, 0x1e, 0x0e, 0xe0, 0x87, 0xd0, 0x62, 0xa9, 0x5c, 0xac, 0xc2,
	0xd6, 0xd0, 0x19, 0xf5, 0x49, 0x09, 0xf0, 0x19, 0x74, 0xd2, 0x8c, 0xcb, 0x8c, 0xab, 0x22, 0xf4,
	0x86, 0xce, 0xa8, 0x49, 0x76, 0x18, 0x3f, 0x85, 0xc1, 0xaf, 0x19, 0x57, 0x6c, 0xc6, 0x13, 0x96,
	0x2b, 0x9a, 0xa4, 0x61, 0xdb, 0x30, 0xee, 0x55, 0xf1, 0x13, 0xe8, 0x67, 0x8c, 0xc6, 0x35, 0xad,
	0x63, 0x68, 0xfb, 0x45, 0x8c, 0xa0, 0x97, 0xd0, 0x6d, 0x4d, 0xf2, 0x0d, 0x69, 0xaf, 0x16, 0xfd,
	0xe1, 0x82, 0x3f, 0xab, 0x94, 0xe3, 0x18, 0xda, 0xaa, 0x8c, 0xd1, 0x04, 0xd8, 0x1d, 0x0f, 0x6c,
	0x1a, 0x36, 0xdc, 0x49, 0xe7, 0xdd, 0xcd, 0xf1, 0xc1, 0xf5, 0xcd, 0xb1, 0x43, 0x2a, 0x22, 0x8e,
	0xc0, 0xcb, 0x15, 0x55, 0x9b, 0xdc, 0x24, 0x5b, 0x07, 0x38, 0xdb, 0x8a, 0xa9, 0xa9, 0x13, 0x3b,
	0xae, 0x55, 0xaf, 0x69, 0xae, 0x5e, 0x33, 0x9a, 0xa9, 0x39, 0xa3, 0xca, 0x24, 0xde, 0x24, 0xfb,
	0x45, 0xfc, 0x1a, 0x0e, 0x17, 0x32, 0x49, 0xd7, 0x4c, 0xb1, 0xf8, 0x27, 0x6d, 0x3b, 0x37, 0x09,
	0x77, 0xc7, 0x7d, 0xbb, 0xf0, 0x15, 0x2b, 0xa6, 0x4c, 0x4d, 0x9a, 0x5a, 0x0a, 0xb9, 0xcf, 0xc5,
	0x2f, 0xa1, 0xcf, 0xc5, 0x5b, 0xbe, 0x5c, 0x29, 0x3b, 0xb9, 0xf5, 0xfe, 0xc9, 0xfb, 0xcc, 0xe8,
	0x1f, 0xc7, 0x64, 0xf1, 0x26, 0x35, 0xbe, 0xfe, 0x4f, 0x16, 0xcf, 0xc1, 0x97, 0x19, 0x5f, 0x72,
	0xa1, 0xfb, 0xc2, 0x35, 0x7d, 0x51, 0x17, 0xf4, 0xc9, 0xe7, 0xec, 0x97, 0x0d, 0x13, 0x0b, 0x66,
	0xac, 0xf7, 0xc9, 0x0e, 0xe3, 0xcb, 0xc7, 0xb9, 0x7e, 0xe8, 0xf7, 0xc5, 0x63, 0xfc, 0xde, 0x77,
	0x3a, 0x86, 0xce, 0x15, 0x2b, 0x08, 0x15, 0x4b, 0xa6, 0xbb, 0x34, 0x57, 0x34, 0x53, 0xe5, 0x95,
	0x21, 0x25, 0xc0, 0x00, 0x1a, 0x4c, 0xc4, 0xd6, 0x83, 0xfe, 0x8c, 0x7e, 0x04, 0xaf, 0x5c, 0x4c,
	0xbb, 0x4c, 0x25, 0x17, 0xea, 0x8a, 0x15, 0x79, 0xe8, 0x0c, 0x1b, 0xda, 0xe5, 0xae, 0x80, 0xa7,
	0xe0, 0x65, 0x7a, 0x61, 0xdd, 0x0f, 0x8d, 0x51, 0x77, 0x7c, 0x58, 0x2b, 0x31, 0x1b, 0xda, 0xec,
	0x2d, 0x29, 0xe2, 0xd0, 0x33, 0x99, 0xb3, 0xac, 0xbc, 0x62, 0x03, 0x70, 0x65, 0x6a, 0xb4, 0xf4,
	0x89, 0x2b, 0x53, 0x0c, 0xa1, 0x9d, 0xd2, 0x62, 0x2d, 0x69, 0x25, 0xa6, 0x82, 0x78, 0x0e, 0x1d,
	0x9e, 0xa4, 0x74, 0xa1, 0x58, 0x6c, 0xe2, 0x7c, 0xcf, 0x21, 0xef, 0x48, 0xd1, 0x6f, 0x70, 0x38,
	0xdb, 0x8a, 0x09, 0x55, 0x8b, 0x15, 0xd1, 0xb9, 0xe7, 0x0a, 0xbf, 0x02, 0x6f, 0xc5, 0x68, 0xcc,
	0x32, 0x7b, 0xc6, 0xcf, 0xeb, 0x33, 0xbe, 0xcb, 0x7b, 0x6d, 0x38, 0x95, 0xf2, 0x72, 0x06, 0x9e,
	0x42, 0x27, 0x2b, 0x87, 0x2b, 0xab, 0x4f, 0xea, 0xd9, 0x76, 0x22, 0xd9, 0x51, 0xa2, 0xdf, 0x1d,
	0x78, 0xfa, 0x9f, 0xcb, 0xe2, 0x08, 0x1a, 0x6a, 0x2b, 0xac, 0x82, 0x3b, 0xd7, 0xa7, 0x6c, 0x44,
	0xbb, 0xab, 0xa6, 0xe8, 0x30, 0x94, 0x9c, 0xae, 0x68, 0x56, 0x86, 0xd1, 0x24, 0x15, 0xc4, 0xcf,
	0xa0, 0xa9, 0x8a, 0x94, 0xd9, 0x47, 0xec, 0xe9, 0x03, 0x21, 0xb3, 0x22, 0x65, 0xc4, 0x50, 0xa2,
	0xef, 0x00, 0xea, 0x3a, 0xbe, 0x04, 0x5f, 0x56, 0xe1, 0x5b, 0x09, 0x1f, 0xdc, 0x95, 0x60, 0x87,
	0xac, 0x8a, 0x9a, 0x1b, 0x7d, 0x0c, 0x5d, 0xb3, 0x4c, 0x9e, 0x4a, 0x91, 0x33, 0xfd, 0xbc, 0xc6,
	0xd4, 0xde, 0x95, 0x1e, 0x31, 0xdf, 0x27, 0x9f, 0x83, 0xbf, 0x7b, 0x46, 0xd1, 0x03, 0x97, 0x5c,
	0x04, 0x07, 0x38, 0x00, 0x20, 0x17, 0x84, 0xd1, 0xf8, 0x8d, 0x58, 0x17, 0x81, 0xa3, 0xeb, 0xd3,
	0xcb, 0xc0, 0x3d, 0x79, 0x65, 0x2e, 0x5f, 0xf9, 0x64, 0x60, 0x17, 0xda, 0x3f, 0x30, 0x11, 0x73,
	0xb1, 0x0c, 0x0e, 0x34, 0x98, 0x2a, 0xba, 0xd4, 0xc0, 0xc1, 0x3e, 0xf8, 0x17, 0x32, 0x49, 0xb8,
	0x52, 0x2c, 0x0e, 0x5c, 0x3d, 0xf6, 0x6a, 0x2e, 0x33, 0x0d, 0x1a, 0x27, 0xdf, 0xc0, 0x60, 0xdf,
	0x31, 0x76, 0xa0, 0xa9, 0xb7, 0x0a, 0x0e, 0xd0, 0x87, 0x96, 0x69, 0xfe, 0xc0, 0x41, 0x00, 0xaf,
	0x5c, 0x22, 0x70, 0xb1, 0x07, 0x1d, 0x22, 0xd7, 0xeb, 0x39, 0x5d, 0xfc, 0x1c, 0x34, 0x26, 0xc1,
	0xf5, 0xdf, 0x47, 0xce, 0xbb, 0xdb, 0x23, 0xe7, 0xfa, 0xf6, 0xc8, 0xf9, 0xeb, 0xf6, 0xc8, 0x99,
	0x7b, 0xe6, 0x07, 0xf3, 0xe2, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0x22, 0xc6, 0x7d, 0x51, 0xa5,
	0x06, 0x00, 0x00,
}

func (m *TxnMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Isolation != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.Isolation))
	}
	if len(m.TxnRecordRouteKey) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(len(m.TxnRecordRouteKey)))
		i += copy(dAtA[i:], m.TxnRecordRouteKey)
	}
	if m.Epoch != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.Epoch))
	}
	if m.Priority != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.Priority))
	}
	if m.WriteTimestamp != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.WriteTimestamp))
	}
	if m.ReadTimestamp != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.ReadTimestamp))
	}
	if m.MaxTimestamp != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.MaxTimestamp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnRecord) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintTxnpb(dAtA, i, uint64(m.TxnMeta.Size()))
	n1, err := m.TxnMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.Status))
	}
	if m.LastHeartbeat != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.LastHeartbeat))
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintTxnpb(dAtA, i, uint64(m.CompletedWrites.Size()))
	n2, err := m.CompletedWrites.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x2a
	i++
	i = encodeVarintTxnpb(dAtA, i, uint64(m.InfightWrites.Size()))
	n3, err := m.InfightWrites.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnOpMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnOpMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintTxnpb(dAtA, i, uint64(m.TxnMeta.Size()))
	n4, err := m.TxnMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if len(m.OriginKey) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(len(m.OriginKey)))
		i += copy(dAtA[i:], m.OriginKey)
	}
	if m.Sequence != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.Sequence))
	}
	if m.CompletedWrites != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.CompletedWrites.Size()))
		n5, err := m.CompletedWrites.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.InfightWrites != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.InfightWrites.Size()))
		n6, err := m.InfightWrites.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KeyRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyRange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Start) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(len(m.Start)))
		i += copy(dAtA[i:], m.Start)
	}
	if len(m.End) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(len(m.End)))
		i += copy(dAtA[i:], m.End)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KeySet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeySet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PointKeys) > 0 {
		for _, b := range m.PointKeys {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTxnpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Ranges) > 0 {
		for _, msg := range m.Ranges {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTxnpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnOperation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnOperation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.Op))
	}
	if len(m.Payload) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(len(m.Payload)))
		i += copy(dAtA[i:], m.Payload)
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTxnpb(dAtA, i, uint64(m.Impacted.Size()))
	n7, err := m.Impacted.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnBatchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnBatchRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintTxnpb(dAtA, i, uint64(m.Header.Size()))
	n8, err := m.Header.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if len(m.Requests) > 0 {
		for _, msg := range m.Requests {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTxnpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnBatchRequestHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnBatchRequestHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintTxnpb(dAtA, i, uint64(m.Txn.Size()))
	n9, err := m.Txn.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if m.ToShard != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.ToShard))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintTxnpb(dAtA, i, uint64(m.Operation.Size()))
	n10, err := m.Operation.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintTxnpb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TxnMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovTxnpb(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTxnpb(uint64(l))
	}
	if m.Isolation != 0 {
		n += 1 + sovTxnpb(uint64(m.Isolation))
	}
	l = len(m.TxnRecordRouteKey)
	if l > 0 {
		n += 1 + l + sovTxnpb(uint64(l))
	}
	if m.Epoch != 0 {
		n += 1 + sovTxnpb(uint64(m.Epoch))
	}
	if m.Priority != 0 {
		n += 1 + sovTxnpb(uint64(m.Priority))
	}
	if m.WriteTimestamp != 0 {
		n += 1 + sovTxnpb(uint64(m.WriteTimestamp))
	}
	if m.ReadTimestamp != 0 {
		n += 1 + sovTxnpb(uint64(m.ReadTimestamp))
	}
	if m.MaxTimestamp != 0 {
		n += 1 + sovTxnpb(uint64(m.MaxTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TxnMeta.Size()
	n += 1 + l + sovTxnpb(uint64(l))
	if m.Status != 0 {
		n += 1 + sovTxnpb(uint64(m.Status))
	}
	if m.LastHeartbeat != 0 {
		n += 1 + sovTxnpb(uint64(m.LastHeartbeat))
	}
	l = m.CompletedWrites.Size()
	n += 1 + l + sovTxnpb(uint64(l))
	l = m.InfightWrites.Size()
	n += 1 + l + sovTxnpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnOpMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TxnMeta.Size()
	n += 1 + l + sovTxnpb(uint64(l))
	l = len(m.OriginKey)
	if l > 0 {
		n += 1 + l + sovTxnpb(uint64(l))
	}
	if m.Sequence != 0 {
		n += 1 + sovTxnpb(uint64(m.Sequence))
	}
	if m.CompletedWrites != nil {
		l = m.CompletedWrites.Size()
		n += 1 + l + sovTxnpb(uint64(l))
	}
	if m.InfightWrites != nil {
		l = m.InfightWrites.Size()
		n += 1 + l + sovTxnpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeyRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Start)
	if l > 0 {
		n += 1 + l + sovTxnpb(uint64(l))
	}
	l = len(m.End)
	if l > 0 {
		n += 1 + l + sovTxnpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeySet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PointKeys) > 0 {
		for _, b := range m.PointKeys {
			l = len(b)
			n += 1 + l + sovTxnpb(uint64(l))
		}
	}
	if len(m.Ranges) > 0 {
		for _, e := range m.Ranges {
			l = e.Size()
			n += 1 + l + sovTxnpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnOperation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovTxnpb(uint64(m.Op))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovTxnpb(uint64(l))
	}
	l = m.Impacted.Size()
	n += 1 + l + sovTxnpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnBatchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovTxnpb(uint64(l))
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovTxnpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnBatchRequestHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Txn.Size()
	n += 1 + l + sovTxnpb(uint64(l))
	if m.ToShard != 0 {
		n += 1 + sovTxnpb(uint64(m.ToShard))
	}
	if m.Type != 0 {
		n += 1 + sovTxnpb(uint64(m.Type))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Operation.Size()
	n += 1 + l + sovTxnpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTxnpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTxnpb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTxnpb(x uint64) (n int) {
	return sovTxnpb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TxnMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Isolation", wireType)
			}
			m.Isolation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Isolation |= Isolation(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnRecordRouteKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxnRecordRouteKey = append(m.TxnRecordRouteKey[:0], dAtA[iNdEx:postIndex]...)
			if m.TxnRecordRouteKey == nil {
				m.TxnRecordRouteKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteTimestamp", wireType)
			}
			m.WriteTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteTimestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTimestamp", wireType)
			}
			m.ReadTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTimestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTimestamp", wireType)
			}
			m.MaxTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTimestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTxnpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxnMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TxnStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeartbeat", wireType)
			}
			m.LastHeartbeat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastHeartbeat |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedWrites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CompletedWrites.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfightWrites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.InfightWrites.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxnpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnOpMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnOpMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnOpMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxnMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginKey = append(m.OriginKey[:0], dAtA[iNdEx:postIndex]...)
			if m.OriginKey == nil {
				m.OriginKey = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedWrites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompletedWrites == nil {
				m.CompletedWrites = &KeySet{}
			}
			if err := m.CompletedWrites.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfightWrites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InfightWrites == nil {
				m.InfightWrites = &KeySet{}
			}
			if err := m.InfightWrites.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxnpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Start = append(m.Start[:0], dAtA[iNdEx:postIndex]...)
			if m.Start == nil {
				m.Start = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.End = append(m.End[:0], dAtA[iNdEx:postIndex]...)
			if m.End == nil {
				m.End = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxnpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeySet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeySet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeySet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PointKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PointKeys = append(m.PointKeys, make([]byte, postIndex-iNdEx))
			copy(m.PointKeys[len(m.PointKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranges = append(m.Ranges, KeyRange{})
			if err := m.Ranges[len(m.Ranges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxnpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnOperation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnOperation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnOperation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Impacted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Impacted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxnpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnBatchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnBatchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnBatchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, &TxnRequest{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxnpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnBatchRequestHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnBatchRequestHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnBatchRequestHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToShard", wireType)
			}
			m.ToShard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToShard |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= TxnRequestType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTxnpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Operation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxnpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxnpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTxnpb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTxnpb
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthTxnpb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTxnpb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTxnpb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthTxnpb
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTxnpb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTxnpb   = fmt.Errorf("proto: integer overflow")
)
