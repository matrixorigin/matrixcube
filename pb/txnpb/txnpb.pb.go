// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: txnpb.proto

package txnpb

import (
	fmt "fmt"
	io "io"
	math "math"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// IsolationLevel is the transaction isolation Level
type IsolationLevel int32

const (
	// SnapshotSerializable snapshot serializable
	IsolationLevel_SnapshotSerializable IsolationLevel = 0
	// ReadCommitted read committed
	IsolationLevel_ReadCommitted IsolationLevel = 1
	// ReadCommittedReadOnly read committed, but only read-only transaction
	IsolationLevel_ReadCommittedReadOnly IsolationLevel = 2
)

var IsolationLevel_name = map[int32]string{
	0: "SnapshotSerializable",
	1: "ReadCommitted",
	2: "ReadCommittedReadOnly",
}

var IsolationLevel_value = map[string]int32{
	"SnapshotSerializable":  0,
	"ReadCommitted":         1,
	"ReadCommittedReadOnly": 2,
}

func (x IsolationLevel) String() string {
	return proto.EnumName(IsolationLevel_name, int32(x))
}

func (IsolationLevel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{0}
}

// TxnStatus transaction status
type TxnStatus int32

const (
	// Pending indicates that the transaction is in progress.
	TxnStatus_Pending TxnStatus = 0
	// Staging the parallel-commit optimization sets the transaction
	// to this state, indicating that it is not sure if all writes
	// have succeeded, and that you need to verify that all writes have
	// succeeded when you encounter this state. May be converted to
	// `Committed` or `Aborted` state.
	TxnStatus_Staging TxnStatus = 1
	// Committed this is a final status indicating that the transaction
	// has been committed.
	TxnStatus_Committed TxnStatus = 2
	// Committed this is a final status indicating that the transaction
	// has been aborted.
	TxnStatus_Aborted TxnStatus = 3
)

var TxnStatus_name = map[int32]string{
	0: "Pending",
	1: "Staging",
	2: "Committed",
	3: "Aborted",
}

var TxnStatus_value = map[string]int32{
	"Pending":   0,
	"Staging":   1,
	"Committed": 2,
	"Aborted":   3,
}

func (x TxnStatus) String() string {
	return proto.EnumName(TxnStatus_name, int32(x))
}

func (TxnStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{1}
}

// InternalTxnOp transaction framework internal operation types.
type InternalTxnOp int32

const (
	// Heartbeat txn heartbeat operation
	InternalTxnOp_Heartbeat InternalTxnOp = 0
	// Commit txn commit operation
	InternalTxnOp_Commit InternalTxnOp = 1
	// Rollback txn rollback operation
	InternalTxnOp_Rollback InternalTxnOp = 2
	// WaitConsensus waiting for consensus to be completed
	InternalTxnOp_WaitConsensus InternalTxnOp = 3
	// Reserved txn reserved operation value, all custom transaction
	// read and write operation type can not use the value below the
	// reserved value.
	InternalTxnOp_Reserved InternalTxnOp = 1000
)

var InternalTxnOp_name = map[int32]string{
	0:    "Heartbeat",
	1:    "Commit",
	2:    "Rollback",
	3:    "WaitConsensus",
	1000: "Reserved",
}

var InternalTxnOp_value = map[string]int32{
	"Heartbeat":     0,
	"Commit":        1,
	"Rollback":      2,
	"WaitConsensus": 3,
	"Reserved":      1000,
}

func (x InternalTxnOp) String() string {
	return proto.EnumName(InternalTxnOp_name, int32(x))
}

func (InternalTxnOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{2}
}

// ImpactedType type of impact
type ImpactedType int32

const (
	// ReadImpacted read the keys in impacted
	ImpactedType_ReadImpacted ImpactedType = 0
	// WriteImpacted write the keys in impacted
	ImpactedType_WriteImpacted ImpactedType = 1
	// ReadWriteImpacted read and write the keys in impacted
	ImpactedType_ReadWriteImpacted ImpactedType = 2
)

var ImpactedType_name = map[int32]string{
	0: "ReadImpacted",
	1: "WriteImpacted",
	2: "ReadWriteImpacted",
}

var ImpactedType_value = map[string]int32{
	"ReadImpacted":      0,
	"WriteImpacted":     1,
	"ReadWriteImpacted": 2,
}

func (x ImpactedType) String() string {
	return proto.EnumName(ImpactedType_name, int32(x))
}

func (ImpactedType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{3}
}

// TxnRequestType transaction request type
type TxnRequestType int32

const (
	// Read read request
	TxnRequestType_Read TxnRequestType = 0
	// Write write request
	TxnRequestType_Write TxnRequestType = 1
)

var TxnRequestType_name = map[int32]string{
	0: "Read",
	1: "Write",
}

var TxnRequestType_value = map[string]int32{
	"Read":  0,
	"Write": 1,
}

func (x TxnRequestType) String() string {
	return proto.EnumName(TxnRequestType_name, int32(x))
}

func (TxnRequestType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{4}
}

// TxnMeta transaction metadata, which will be integrated into TxnRecord and
// TxnOpMeta for persistent storage.
type TxnMeta struct {
	// ID transction id
	ID []byte `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// Name transaction name
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// IsolationLevel transaction isolation level
	IsolationLevel IsolationLevel `protobuf:"varint,3,opt,name=isolationLevel,proto3,enum=txnpb.IsolationLevel" json:"isolationLevel,omitempty"`
	// TxnRecordRouteKey used to locate which Shard the TxnRecord is in.
	TxnRecordRouteKey []byte `protobuf:"bytes,4,opt,name=txnRecordRouteKey,proto3" json:"txnRecordRouteKey,omitempty"`
	// TxnRecordShardGroup used to locate which ShardGroup the TxnRecord is in.
	TxnRecordShardGroup uint64 `protobuf:"varint,5,opt,name=txnRecordShardGroup,proto3" json:"txnRecordShardGroup,omitempty"`
	// Epoch used to indicate the number of restarts of a transaction.
	// Each time a transaction is restarted, the field +1.
	Epoch uint32 `protobuf:"varint,6,opt,name=epoch,proto3" json:"epoch,omitempty"`
	// Priority transaction priority, used for transaction conflict, according
	// to the priority of the decision to abort which a transaction.
	Priority uint32 `protobuf:"varint,7,opt,name=priority,proto3" json:"priority,omitempty"`
	// WriteTimestamp the timestamp version number of the data written by the
	// transaction, this version number may be raised in several scenarios.
	WriteTimestamp uint64 `protobuf:"varint,8,opt,name=writeTimestamp,proto3" json:"writeTimestamp,omitempty"`
	// ReadTimestamp the timestamp of the start of the transaction, which is used
	// to read the data from MVCC, in some scenarios this timestamp will be raised
	// to avoid some conflicts and ambiguities.
	ReadTimestamp uint64 `protobuf:"varint,9,opt,name=readTimestamp,proto3" json:"readTimestamp,omitempty"`
	// MaxTimestamp if using HLC's clocking scheme, this field is equal to Readtimestamp
	// + maximum clock skew, which is used to indicate an upper limit of uncertainty
	// time.
	MaxTimestamp         uint64   `protobuf:"varint,10,opt,name=maxTimestamp,proto3" json:"maxTimestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnMeta) Reset()         { *m = TxnMeta{} }
func (m *TxnMeta) String() string { return proto.CompactTextString(m) }
func (*TxnMeta) ProtoMessage()    {}
func (*TxnMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{0}
}
func (m *TxnMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnMeta.Merge(m, src)
}
func (m *TxnMeta) XXX_Size() int {
	return m.Size()
}
func (m *TxnMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnMeta.DiscardUnknown(m)
}

var xxx_messageInfo_TxnMeta proto.InternalMessageInfo

func (m *TxnMeta) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *TxnMeta) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TxnMeta) GetIsolationLevel() IsolationLevel {
	if m != nil {
		return m.IsolationLevel
	}
	return IsolationLevel_SnapshotSerializable
}

func (m *TxnMeta) GetTxnRecordRouteKey() []byte {
	if m != nil {
		return m.TxnRecordRouteKey
	}
	return nil
}

func (m *TxnMeta) GetTxnRecordShardGroup() uint64 {
	if m != nil {
		return m.TxnRecordShardGroup
	}
	return 0
}

func (m *TxnMeta) GetEpoch() uint32 {
	if m != nil {
		return m.Epoch
	}
	return 0
}

func (m *TxnMeta) GetPriority() uint32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *TxnMeta) GetWriteTimestamp() uint64 {
	if m != nil {
		return m.WriteTimestamp
	}
	return 0
}

func (m *TxnMeta) GetReadTimestamp() uint64 {
	if m != nil {
		return m.ReadTimestamp
	}
	return 0
}

func (m *TxnMeta) GetMaxTimestamp() uint64 {
	if m != nil {
		return m.MaxTimestamp
	}
	return 0
}

// TxnRecord similar to Txn, but only the fields that need to be persisted to
// disk are kept. A TxnRecord is the central store of a transaction, with the
// global state of the transaction and the Key of all written data. Once the
// status of the TxnRecord changes to `Committed`, then all data written by the
// transaction is visible atomically.
type TxnRecord struct {
	// TxnMeta embed txn meta
	TxnMeta `protobuf:"bytes,1,opt,name=txnMeta,proto3,embedded=txnMeta" json:"txnMeta"`
	// TxnStatus transaction status
	Status TxnStatus `protobuf:"varint,2,opt,name=status,proto3,enum=txnpb.TxnStatus" json:"status,omitempty"`
	// LastHeartbeat the last time the transaction coordinator sent a heartbeat,
	// this field is used to check if the transaction can't continue due to the
	// transaction coordinator being down, thus rolling back the transaction.
	LastHeartbeat uint64 `protobuf:"varint,3,opt,name=lastHeartbeat,proto3" json:"lastHeartbeat,omitempty"`
	// CompletedWrites record the current transaction has completed the consensus write
	// operation.
	CompletedWrites map[uint64]KeySet `protobuf:"bytes,4,rep,name=completedWrites,proto3" json:"completedWrites" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// InfightWrites record the current transaction has not completed the consensus write
	// operation.
	InfightWrites        map[uint64]KeySet `protobuf:"bytes,5,rep,name=infightWrites,proto3" json:"infightWrites" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *TxnRecord) Reset()         { *m = TxnRecord{} }
func (m *TxnRecord) String() string { return proto.CompactTextString(m) }
func (*TxnRecord) ProtoMessage()    {}
func (*TxnRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{1}
}
func (m *TxnRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnRecord.Merge(m, src)
}
func (m *TxnRecord) XXX_Size() int {
	return m.Size()
}
func (m *TxnRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnRecord.DiscardUnknown(m)
}

var xxx_messageInfo_TxnRecord proto.InternalMessageInfo

func (m *TxnRecord) GetStatus() TxnStatus {
	if m != nil {
		return m.Status
	}
	return TxnStatus_Pending
}

func (m *TxnRecord) GetLastHeartbeat() uint64 {
	if m != nil {
		return m.LastHeartbeat
	}
	return 0
}

func (m *TxnRecord) GetCompletedWrites() map[uint64]KeySet {
	if m != nil {
		return m.CompletedWrites
	}
	return nil
}

func (m *TxnRecord) GetInfightWrites() map[uint64]KeySet {
	if m != nil {
		return m.InfightWrites
	}
	return nil
}

// TxnOpMeta metadata for transaction operations, with fields related to the
// current operation of the transaction added to TxnMeta.
type TxnOpMeta struct {
	// TxnMeta embed txn meta
	TxnMeta `protobuf:"bytes,1,opt,name=txnMeta,proto3,embedded=txnMeta" json:"txnMeta"`
	// Sequence indicates the current number of write operations in the transaction.
	// Of all the operations in the transaction, only the write operation will increase
	// the value of the field, the read operation will not. Used to implement the `read
	// your write`.
	Sequence uint32 `protobuf:"varint,3,opt,name=sequence,proto3" json:"sequence,omitempty"`
	// CompletedWrites record the current transaction has completed the consensus write
	// operation. Only when it is a Commit or Rollback transaction, it will be attached.
	CompletedWrites map[uint64]KeySet `protobuf:"bytes,4,rep,name=completedWrites,proto3" json:"completedWrites" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// InfightWrites record the current transaction has not completed the consensus write
	// operation. Only when it is a Commit or Rollback transaction, it will be attached.
	InfightWrites        map[uint64]KeySet `protobuf:"bytes,5,rep,name=infightWrites,proto3" json:"infightWrites" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *TxnOpMeta) Reset()         { *m = TxnOpMeta{} }
func (m *TxnOpMeta) String() string { return proto.CompactTextString(m) }
func (*TxnOpMeta) ProtoMessage()    {}
func (*TxnOpMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{2}
}
func (m *TxnOpMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnOpMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnOpMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnOpMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnOpMeta.Merge(m, src)
}
func (m *TxnOpMeta) XXX_Size() int {
	return m.Size()
}
func (m *TxnOpMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnOpMeta.DiscardUnknown(m)
}

var xxx_messageInfo_TxnOpMeta proto.InternalMessageInfo

func (m *TxnOpMeta) GetSequence() uint32 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *TxnOpMeta) GetCompletedWrites() map[uint64]KeySet {
	if m != nil {
		return m.CompletedWrites
	}
	return nil
}

func (m *TxnOpMeta) GetInfightWrites() map[uint64]KeySet {
	if m != nil {
		return m.InfightWrites
	}
	return nil
}

// KeyRange description of the set of Keys in the range [start, end)
type KeyRange struct {
	// Start start key, include
	Start []byte `protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"`
	// End end key, exclude
	End                  []byte   `protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeyRange) Reset()         { *m = KeyRange{} }
func (m *KeyRange) String() string { return proto.CompactTextString(m) }
func (*KeyRange) ProtoMessage()    {}
func (*KeyRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{3}
}
func (m *KeyRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyRange.Merge(m, src)
}
func (m *KeyRange) XXX_Size() int {
	return m.Size()
}
func (m *KeyRange) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyRange.DiscardUnknown(m)
}

var xxx_messageInfo_KeyRange proto.InternalMessageInfo

func (m *KeyRange) GetStart() []byte {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *KeyRange) GetEnd() []byte {
	if m != nil {
		return m.End
	}
	return nil
}

// KeySet key collection, with a set of individual Keys and a set of KeyRanges.
// This structure can be compressed, for example by using a KeyRange to represent
// a set of Keys, or by using a KeyRange with a larger range instead of multiple
// KeyRanges with smaller ranges.
type KeySet struct {
	// PointKeys the `originKey` set of explicit point data.
	PointKeys [][]byte `protobuf:"bytes,1,rep,name=pointKeys,proto3" json:"pointKeys,omitempty"`
	// Ranges the set of range `originKey`
	Ranges []KeyRange `protobuf:"bytes,2,rep,name=ranges,proto3" json:"ranges"`
	// Sorted all keys and ranges are sorted
	Sorted               bool     `protobuf:"varint,3,opt,name=sorted,proto3" json:"sorted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KeySet) Reset()         { *m = KeySet{} }
func (m *KeySet) String() string { return proto.CompactTextString(m) }
func (*KeySet) ProtoMessage()    {}
func (*KeySet) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{4}
}
func (m *KeySet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeySet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeySet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeySet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeySet.Merge(m, src)
}
func (m *KeySet) XXX_Size() int {
	return m.Size()
}
func (m *KeySet) XXX_DiscardUnknown() {
	xxx_messageInfo_KeySet.DiscardUnknown(m)
}

var xxx_messageInfo_KeySet proto.InternalMessageInfo

func (m *KeySet) GetPointKeys() [][]byte {
	if m != nil {
		return m.PointKeys
	}
	return nil
}

func (m *KeySet) GetRanges() []KeyRange {
	if m != nil {
		return m.Ranges
	}
	return nil
}

func (m *KeySet) GetSorted() bool {
	if m != nil {
		return m.Sorted
	}
	return false
}

// TxnOperation a operation for transaction. Called at TxnOperator and executed on
// the Lease Holder of Shard.
type TxnOperation struct {
	// Op the specific type of request, e.g. Set/Get/Delete.
	Op uint32 `protobuf:"varint,1,opt,name=op,proto3" json:"op,omitempty"`
	// Payload the data of request.
	Payload []byte `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	// Impacted impact data KeySet for transaction framework to do conflict detection,
	// Lock, Latch and asynchronous consensus optimization.
	Impacted KeySet `protobuf:"bytes,3,opt,name=impacted,proto3" json:"impacted"`
	// ImpactedType how the keys are impacted
	ImpactedType ImpactedType `protobuf:"varint,4,opt,name=impactedType,proto3,enum=txnpb.ImpactedType" json:"impactedType,omitempty"`
	// ShardGroup which shard group the data is in
	ShardGroup uint64 `protobuf:"varint,5,opt,name=shardGroup,proto3" json:"shardGroup,omitempty"`
	// Timestamp the timestamp of the transaction operation initiation, the request in
	// heartbeat will be accompanied by.
	Timestamp            uint64   `protobuf:"varint,6,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnOperation) Reset()         { *m = TxnOperation{} }
func (m *TxnOperation) String() string { return proto.CompactTextString(m) }
func (*TxnOperation) ProtoMessage()    {}
func (*TxnOperation) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{5}
}
func (m *TxnOperation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnOperation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnOperation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnOperation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnOperation.Merge(m, src)
}
func (m *TxnOperation) XXX_Size() int {
	return m.Size()
}
func (m *TxnOperation) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnOperation.DiscardUnknown(m)
}

var xxx_messageInfo_TxnOperation proto.InternalMessageInfo

func (m *TxnOperation) GetOp() uint32 {
	if m != nil {
		return m.Op
	}
	return 0
}

func (m *TxnOperation) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *TxnOperation) GetImpacted() KeySet {
	if m != nil {
		return m.Impacted
	}
	return KeySet{}
}

func (m *TxnOperation) GetImpactedType() ImpactedType {
	if m != nil {
		return m.ImpactedType
	}
	return ImpactedType_ReadImpacted
}

func (m *TxnOperation) GetShardGroup() uint64 {
	if m != nil {
		return m.ShardGroup
	}
	return 0
}

func (m *TxnOperation) GetTimestamp() uint64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

// TxnBatchRequest transaction operations are converted into multiple transaction
// requests, contained by a TxnBatchRequest.
type TxnBatchRequest struct {
	Header               TxnBatchRequestHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Requests             []TxnRequest          `protobuf:"bytes,2,rep,name=requests,proto3" json:"requests"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *TxnBatchRequest) Reset()         { *m = TxnBatchRequest{} }
func (m *TxnBatchRequest) String() string { return proto.CompactTextString(m) }
func (*TxnBatchRequest) ProtoMessage()    {}
func (*TxnBatchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{6}
}
func (m *TxnBatchRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnBatchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnBatchRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnBatchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnBatchRequest.Merge(m, src)
}
func (m *TxnBatchRequest) XXX_Size() int {
	return m.Size()
}
func (m *TxnBatchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnBatchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TxnBatchRequest proto.InternalMessageInfo

func (m *TxnBatchRequest) GetHeader() TxnBatchRequestHeader {
	if m != nil {
		return m.Header
	}
	return TxnBatchRequestHeader{}
}

func (m *TxnBatchRequest) GetRequests() []TxnRequest {
	if m != nil {
		return m.Requests
	}
	return nil
}

// TxnBatchRequestHeader the head of TxnBatchRequest.
type TxnBatchRequestHeader struct {
	// TxnOpMeta transaction operation metadata
	Txn TxnOpMeta `protobuf:"bytes,1,opt,name=txn,proto3" json:"txn"`
	// TxnRequestType request type, decide to call `HandleRead` or `HandleWrite`
	Type TxnRequestType `protobuf:"varint,2,opt,name=type,proto3,enum=txnpb.TxnRequestType" json:"type,omitempty"`
	// RequestOptions request options
	Options              RequestOptions `protobuf:"bytes,3,opt,name=options,proto3" json:"options"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TxnBatchRequestHeader) Reset()         { *m = TxnBatchRequestHeader{} }
func (m *TxnBatchRequestHeader) String() string { return proto.CompactTextString(m) }
func (*TxnBatchRequestHeader) ProtoMessage()    {}
func (*TxnBatchRequestHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{7}
}
func (m *TxnBatchRequestHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnBatchRequestHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnBatchRequestHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnBatchRequestHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnBatchRequestHeader.Merge(m, src)
}
func (m *TxnBatchRequestHeader) XXX_Size() int {
	return m.Size()
}
func (m *TxnBatchRequestHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnBatchRequestHeader.DiscardUnknown(m)
}

var xxx_messageInfo_TxnBatchRequestHeader proto.InternalMessageInfo

func (m *TxnBatchRequestHeader) GetTxn() TxnOpMeta {
	if m != nil {
		return m.Txn
	}
	return TxnOpMeta{}
}

func (m *TxnBatchRequestHeader) GetType() TxnRequestType {
	if m != nil {
		return m.Type
	}
	return TxnRequestType_Read
}

func (m *TxnBatchRequestHeader) GetOptions() RequestOptions {
	if m != nil {
		return m.Options
	}
	return RequestOptions{}
}

// TxnBatchResponseHeader the head of TxnBatchResponse.
type TxnBatchResponseHeader struct {
	// TxnMeta the modified transaction metadata by server
	Txn TxnMeta `protobuf:"bytes,1,opt,name=txn,proto3" json:"txn"`
	// TxnStatus txn status found in server side, only relevant requests requesting
	// access to TxnRecord will return.
	Status TxnStatus `protobuf:"varint,2,opt,name=status,proto3,enum=txnpb.TxnStatus" json:"status,omitempty"`
	// TxnError txn error
	Error                *TxnError `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *TxnBatchResponseHeader) Reset()         { *m = TxnBatchResponseHeader{} }
func (m *TxnBatchResponseHeader) String() string { return proto.CompactTextString(m) }
func (*TxnBatchResponseHeader) ProtoMessage()    {}
func (*TxnBatchResponseHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{8}
}
func (m *TxnBatchResponseHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnBatchResponseHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnBatchResponseHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnBatchResponseHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnBatchResponseHeader.Merge(m, src)
}
func (m *TxnBatchResponseHeader) XXX_Size() int {
	return m.Size()
}
func (m *TxnBatchResponseHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnBatchResponseHeader.DiscardUnknown(m)
}

var xxx_messageInfo_TxnBatchResponseHeader proto.InternalMessageInfo

func (m *TxnBatchResponseHeader) GetTxn() TxnMeta {
	if m != nil {
		return m.Txn
	}
	return TxnMeta{}
}

func (m *TxnBatchResponseHeader) GetStatus() TxnStatus {
	if m != nil {
		return m.Status
	}
	return TxnStatus_Pending
}

func (m *TxnBatchResponseHeader) GetError() *TxnError {
	if m != nil {
		return m.Error
	}
	return nil
}

// TxnBatchResponse the response of TxnBatchRequest returns the modified transaction
// metadata in the header of the response, and the transaction coordinator needs to
// update the transaction metadata in memory, such as the read and write timestamps
// of the transaction being raised.
type TxnBatchResponse struct {
	Header               TxnBatchResponseHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Responses            []TxnResponse          `protobuf:"bytes,2,rep,name=responses,proto3" json:"responses"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *TxnBatchResponse) Reset()         { *m = TxnBatchResponse{} }
func (m *TxnBatchResponse) String() string { return proto.CompactTextString(m) }
func (*TxnBatchResponse) ProtoMessage()    {}
func (*TxnBatchResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{9}
}
func (m *TxnBatchResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnBatchResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnBatchResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnBatchResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnBatchResponse.Merge(m, src)
}
func (m *TxnBatchResponse) XXX_Size() int {
	return m.Size()
}
func (m *TxnBatchResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnBatchResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TxnBatchResponse proto.InternalMessageInfo

func (m *TxnBatchResponse) GetHeader() TxnBatchResponseHeader {
	if m != nil {
		return m.Header
	}
	return TxnBatchResponseHeader{}
}

func (m *TxnBatchResponse) GetResponses() []TxnResponse {
	if m != nil {
		return m.Responses
	}
	return nil
}

// TxnRequest transaction request, corresponds to a TxnOperation
type TxnRequest struct {
	// Operation the TxnOperation
	Operation            TxnOperation `protobuf:"bytes,1,opt,name=operation,proto3" json:"operation"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *TxnRequest) Reset()         { *m = TxnRequest{} }
func (m *TxnRequest) String() string { return proto.CompactTextString(m) }
func (*TxnRequest) ProtoMessage()    {}
func (*TxnRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{10}
}
func (m *TxnRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnRequest.Merge(m, src)
}
func (m *TxnRequest) XXX_Size() int {
	return m.Size()
}
func (m *TxnRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TxnRequest proto.InternalMessageInfo

func (m *TxnRequest) GetOperation() TxnOperation {
	if m != nil {
		return m.Operation
	}
	return TxnOperation{}
}

// TxnResponse is TxnOperation response
type TxnResponse struct {
	// Data is returned by `HandleRead` or `HandleWrite`
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TxnResponse) Reset()         { *m = TxnResponse{} }
func (m *TxnResponse) String() string { return proto.CompactTextString(m) }
func (*TxnResponse) ProtoMessage()    {}
func (*TxnResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{11}
}
func (m *TxnResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnResponse.Merge(m, src)
}
func (m *TxnResponse) XXX_Size() int {
	return m.Size()
}
func (m *TxnResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TxnResponse proto.InternalMessageInfo

func (m *TxnResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// RequestOptions request options
type RequestOptions struct {
	// CreateTxnRecord the current request requires the creation of a TxnRecord
	CreateTxnRecord bool `protobuf:"varint,1,opt,name=createTxnRecord,proto3" json:"createTxnRecord,omitempty"`
	// AasynchronousConsensus current request with asynchronous consensus on
	AsynchronousConsensus bool     `protobuf:"varint,2,opt,name=asynchronousConsensus,proto3" json:"asynchronousConsensus,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *RequestOptions) Reset()         { *m = RequestOptions{} }
func (m *RequestOptions) String() string { return proto.CompactTextString(m) }
func (*RequestOptions) ProtoMessage()    {}
func (*RequestOptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{12}
}
func (m *RequestOptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestOptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestOptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestOptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestOptions.Merge(m, src)
}
func (m *RequestOptions) XXX_Size() int {
	return m.Size()
}
func (m *RequestOptions) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestOptions.DiscardUnknown(m)
}

var xxx_messageInfo_RequestOptions proto.InternalMessageInfo

func (m *RequestOptions) GetCreateTxnRecord() bool {
	if m != nil {
		return m.CreateTxnRecord
	}
	return false
}

func (m *RequestOptions) GetAsynchronousConsensus() bool {
	if m != nil {
		return m.AsynchronousConsensus
	}
	return false
}

// TxnError txn error, Special errors encountered in transaction operations,
// which require special handling on the client or server side.
type TxnError struct {
	ConflictWithCommittedError *ConflictWithCommittedError `protobuf:"bytes,1,opt,name=conflictWithCommittedError,proto3" json:"conflictWithCommittedError,omitempty"`
	UncertaintyError           *UncertaintyError           `protobuf:"bytes,2,opt,name=uncertaintyError,proto3" json:"uncertaintyError,omitempty"`
	AbortedError               *AbortedError               `protobuf:"bytes,3,opt,name=abortedError,proto3" json:"abortedError,omitempty"`
	XXX_NoUnkeyedLiteral       struct{}                    `json:"-"`
	XXX_unrecognized           []byte                      `json:"-"`
	XXX_sizecache              int32                       `json:"-"`
}

func (m *TxnError) Reset()         { *m = TxnError{} }
func (m *TxnError) String() string { return proto.CompactTextString(m) }
func (*TxnError) ProtoMessage()    {}
func (*TxnError) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{13}
}
func (m *TxnError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxnError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxnError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxnError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxnError.Merge(m, src)
}
func (m *TxnError) XXX_Size() int {
	return m.Size()
}
func (m *TxnError) XXX_DiscardUnknown() {
	xxx_messageInfo_TxnError.DiscardUnknown(m)
}

var xxx_messageInfo_TxnError proto.InternalMessageInfo

func (m *TxnError) GetConflictWithCommittedError() *ConflictWithCommittedError {
	if m != nil {
		return m.ConflictWithCommittedError
	}
	return nil
}

func (m *TxnError) GetUncertaintyError() *UncertaintyError {
	if m != nil {
		return m.UncertaintyError
	}
	return nil
}

func (m *TxnError) GetAbortedError() *AbortedError {
	if m != nil {
		return m.AbortedError
	}
	return nil
}

// ConflictWithCommittedError T.ReadTS < C.CommitTS < T.CommitTS, W/W conflict,
// txn.ReadTS and txn.WriteTS => committedTimestamp+1, and check if the read data
// has been written in the range [lastForwardTimestamp, committedTimestamp+1].
type ConflictWithCommittedError struct {
	// MinTimestamp minimum timestamp for a transaction to be forward
	MinTimestamp         uint64   `protobuf:"varint,1,opt,name=minTimestamp,proto3" json:"minTimestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ConflictWithCommittedError) Reset()         { *m = ConflictWithCommittedError{} }
func (m *ConflictWithCommittedError) String() string { return proto.CompactTextString(m) }
func (*ConflictWithCommittedError) ProtoMessage()    {}
func (*ConflictWithCommittedError) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{14}
}
func (m *ConflictWithCommittedError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConflictWithCommittedError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConflictWithCommittedError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConflictWithCommittedError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConflictWithCommittedError.Merge(m, src)
}
func (m *ConflictWithCommittedError) XXX_Size() int {
	return m.Size()
}
func (m *ConflictWithCommittedError) XXX_DiscardUnknown() {
	xxx_messageInfo_ConflictWithCommittedError.DiscardUnknown(m)
}

var xxx_messageInfo_ConflictWithCommittedError proto.InternalMessageInfo

func (m *ConflictWithCommittedError) GetMinTimestamp() uint64 {
	if m != nil {
		return m.MinTimestamp
	}
	return 0
}

// UncertaintyError T.ReadTS < C.CommitTS <= T.MaxTS, HLC clock drift
// txn.ReadTS and txn.WriteTS => C.CommitTS+1, and check if the read data
// has been written in the range [lastForwardTimestamp, T1.MaxTS+1].
type UncertaintyError struct {
	// MinTimestamp minimum timestamp for a transaction to be forward
	MinTimestamp         uint64   `protobuf:"varint,1,opt,name=minTimestamp,proto3" json:"minTimestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UncertaintyError) Reset()         { *m = UncertaintyError{} }
func (m *UncertaintyError) String() string { return proto.CompactTextString(m) }
func (*UncertaintyError) ProtoMessage()    {}
func (*UncertaintyError) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{15}
}
func (m *UncertaintyError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UncertaintyError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UncertaintyError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UncertaintyError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UncertaintyError.Merge(m, src)
}
func (m *UncertaintyError) XXX_Size() int {
	return m.Size()
}
func (m *UncertaintyError) XXX_DiscardUnknown() {
	xxx_messageInfo_UncertaintyError.DiscardUnknown(m)
}

var xxx_messageInfo_UncertaintyError proto.InternalMessageInfo

func (m *UncertaintyError) GetMinTimestamp() uint64 {
	if m != nil {
		return m.MinTimestamp
	}
	return 0
}

// AbortedError transaction is aborted in server side
type AbortedError struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AbortedError) Reset()         { *m = AbortedError{} }
func (m *AbortedError) String() string { return proto.CompactTextString(m) }
func (*AbortedError) ProtoMessage()    {}
func (*AbortedError) Descriptor() ([]byte, []int) {
	return fileDescriptor_4cec01c879ff9f20, []int{16}
}
func (m *AbortedError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AbortedError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AbortedError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AbortedError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AbortedError.Merge(m, src)
}
func (m *AbortedError) XXX_Size() int {
	return m.Size()
}
func (m *AbortedError) XXX_DiscardUnknown() {
	xxx_messageInfo_AbortedError.DiscardUnknown(m)
}

var xxx_messageInfo_AbortedError proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("txnpb.IsolationLevel", IsolationLevel_name, IsolationLevel_value)
	proto.RegisterEnum("txnpb.TxnStatus", TxnStatus_name, TxnStatus_value)
	proto.RegisterEnum("txnpb.InternalTxnOp", InternalTxnOp_name, InternalTxnOp_value)
	proto.RegisterEnum("txnpb.ImpactedType", ImpactedType_name, ImpactedType_value)
	proto.RegisterEnum("txnpb.TxnRequestType", TxnRequestType_name, TxnRequestType_value)
	proto.RegisterType((*TxnMeta)(nil), "txnpb.TxnMeta")
	proto.RegisterType((*TxnRecord)(nil), "txnpb.TxnRecord")
	proto.RegisterMapType((map[uint64]KeySet)(nil), "txnpb.TxnRecord.CompletedWritesEntry")
	proto.RegisterMapType((map[uint64]KeySet)(nil), "txnpb.TxnRecord.InfightWritesEntry")
	proto.RegisterType((*TxnOpMeta)(nil), "txnpb.TxnOpMeta")
	proto.RegisterMapType((map[uint64]KeySet)(nil), "txnpb.TxnOpMeta.CompletedWritesEntry")
	proto.RegisterMapType((map[uint64]KeySet)(nil), "txnpb.TxnOpMeta.InfightWritesEntry")
	proto.RegisterType((*KeyRange)(nil), "txnpb.KeyRange")
	proto.RegisterType((*KeySet)(nil), "txnpb.KeySet")
	proto.RegisterType((*TxnOperation)(nil), "txnpb.TxnOperation")
	proto.RegisterType((*TxnBatchRequest)(nil), "txnpb.TxnBatchRequest")
	proto.RegisterType((*TxnBatchRequestHeader)(nil), "txnpb.TxnBatchRequestHeader")
	proto.RegisterType((*TxnBatchResponseHeader)(nil), "txnpb.TxnBatchResponseHeader")
	proto.RegisterType((*TxnBatchResponse)(nil), "txnpb.TxnBatchResponse")
	proto.RegisterType((*TxnRequest)(nil), "txnpb.TxnRequest")
	proto.RegisterType((*TxnResponse)(nil), "txnpb.TxnResponse")
	proto.RegisterType((*RequestOptions)(nil), "txnpb.RequestOptions")
	proto.RegisterType((*TxnError)(nil), "txnpb.TxnError")
	proto.RegisterType((*ConflictWithCommittedError)(nil), "txnpb.ConflictWithCommittedError")
	proto.RegisterType((*UncertaintyError)(nil), "txnpb.UncertaintyError")
	proto.RegisterType((*AbortedError)(nil), "txnpb.AbortedError")
}

func init() { proto.RegisterFile("txnpb.proto", fileDescriptor_4cec01c879ff9f20) }

var fileDescriptor_4cec01c879ff9f20 = []byte{
	// 1275 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x57, 0x4f, 0x6f, 0x1b, 0xc5,
	0x1b, 0xce, 0xfa, 0xef, 0xfa, 0x8d, 0xed, 0x6c, 0xa6, 0x4d, 0x7f, 0xfe, 0x59, 0x25, 0x75, 0xb7,
	0xb4, 0x32, 0x11, 0x4d, 0x91, 0x0b, 0x2d, 0x2a, 0x42, 0xa2, 0x09, 0x11, 0x0d, 0x01, 0x05, 0x26,
	0xa9, 0x8a, 0xb8, 0x8d, 0x77, 0xa7, 0xf6, 0xaa, 0xeb, 0x99, 0x65, 0x76, 0x5c, 0x62, 0x8e, 0x5c,
	0x38, 0xf3, 0x19, 0x38, 0xf0, 0x55, 0x7a, 0xec, 0x1d, 0xa9, 0x2a, 0x39, 0x21, 0xf1, 0x05, 0x38,
	0xa2, 0x99, 0x9d, 0xf5, 0xfe, 0x49, 0x8a, 0x2a, 0xe0, 0xc4, 0x6d, 0xdf, 0xf7, 0x7d, 0xe6, 0x99,
	0x67, 0xdf, 0x67, 0xf6, 0xf5, 0x18, 0x56, 0xe5, 0x09, 0x8b, 0xc6, 0xdb, 0x91, 0xe0, 0x92, 0xa3,
	0xba, 0x0e, 0xfa, 0x37, 0x27, 0x81, 0x9c, 0xce, 0xc7, 0xdb, 0x1e, 0x9f, 0xdd, 0x9a, 0xf0, 0x09,
	0xbf, 0xa5, 0xab, 0xe3, 0xf9, 0x63, 0x1d, 0xe9, 0x40, 0x3f, 0x25, 0xab, 0xdc, 0x3f, 0x2a, 0xd0,
	0x3c, 0x3e, 0x61, 0x9f, 0x53, 0x49, 0xd0, 0x25, 0xa8, 0x04, 0x7e, 0xcf, 0x1a, 0x58, 0xc3, 0xf6,
	0x4e, 0xe3, 0xf4, 0xc5, 0x95, 0xca, 0xfe, 0xc7, 0xb8, 0x12, 0xf8, 0x08, 0x41, 0x8d, 0x91, 0x19,
	0xed, 0x55, 0x06, 0xd6, 0xb0, 0x85, 0xf5, 0x33, 0xfa, 0x10, 0xba, 0x41, 0xcc, 0x43, 0x22, 0x03,
	0xce, 0x3e, 0xa3, 0x4f, 0x69, 0xd8, 0xab, 0x0e, 0xac, 0x61, 0x77, 0xb4, 0xb1, 0x9d, 0x68, 0xda,
	0x2f, 0x14, 0x71, 0x09, 0x8c, 0xde, 0x86, 0x75, 0x79, 0xc2, 0x30, 0xf5, 0xb8, 0xf0, 0x31, 0x9f,
	0x4b, 0x7a, 0x40, 0x17, 0xbd, 0x9a, 0xda, 0x19, 0x9f, 0x2d, 0xa0, 0x77, 0xe0, 0xc2, 0x32, 0x79,
	0x34, 0x25, 0xc2, 0xff, 0x44, 0xf0, 0x79, 0xd4, 0xab, 0x0f, 0xac, 0x61, 0x0d, 0x9f, 0x57, 0x42,
	0x17, 0xa1, 0x4e, 0x23, 0xee, 0x4d, 0x7b, 0x8d, 0x81, 0x35, 0xec, 0xe0, 0x24, 0x40, 0x7d, 0xb0,
	0x23, 0x11, 0x70, 0x11, 0xc8, 0x45, 0xaf, 0xa9, 0x0b, 0xcb, 0x18, 0xdd, 0x80, 0xee, 0xb7, 0x22,
	0x90, 0xf4, 0x38, 0x98, 0xd1, 0x58, 0x92, 0x59, 0xd4, 0xb3, 0x35, 0x7d, 0x29, 0x8b, 0xde, 0x84,
	0x8e, 0xa0, 0xc4, 0xcf, 0x60, 0x2d, 0x0d, 0x2b, 0x26, 0x91, 0x0b, 0xed, 0x19, 0x39, 0xc9, 0x40,
	0xa0, 0x41, 0x85, 0x9c, 0xfb, 0x4b, 0x15, 0x5a, 0xc7, 0xa9, 0x76, 0x34, 0x82, 0xa6, 0x4c, 0x7c,
	0xd0, 0x0e, 0xac, 0x8e, 0xba, 0xa6, 0x93, 0xc6, 0x9d, 0x1d, 0xfb, 0xd9, 0x8b, 0x2b, 0x2b, 0xcf,
	0x5f, 0x5c, 0xb1, 0x70, 0x0a, 0x44, 0x43, 0x68, 0xc4, 0x92, 0xc8, 0x79, 0xac, 0xad, 0xe9, 0x8e,
	0x9c, 0x6c, 0xc9, 0x91, 0xce, 0x63, 0x53, 0x57, 0xaa, 0x43, 0x12, 0xcb, 0x07, 0x94, 0x08, 0x39,
	0xa6, 0x44, 0x6a, 0xb7, 0x6a, 0xb8, 0x98, 0x44, 0x0f, 0x61, 0xcd, 0xe3, 0xb3, 0x28, 0xa4, 0x92,
	0xfa, 0x8f, 0xd4, 0x6b, 0xc7, 0xbd, 0xda, 0xa0, 0x3a, 0x5c, 0x1d, 0x5d, 0xcf, 0x88, 0x13, 0xb9,
	0xdb, 0xbb, 0x45, 0xdc, 0x1e, 0x93, 0x62, 0xb1, 0x53, 0x53, 0x12, 0x71, 0x99, 0x03, 0x1d, 0x42,
	0x27, 0x60, 0x8f, 0x83, 0xc9, 0x54, 0x1a, 0xd2, 0xba, 0x26, 0xbd, 0x76, 0x86, 0x74, 0x3f, 0x8f,
	0xca, 0x53, 0x16, 0xd7, 0xf7, 0xbf, 0x84, 0x8b, 0xe7, 0xed, 0x8f, 0x1c, 0xa8, 0x3e, 0xa1, 0x0b,
	0xdd, 0xbf, 0x1a, 0x56, 0x8f, 0xe8, 0x1a, 0xd4, 0x9f, 0x92, 0x70, 0x9e, 0x9c, 0xdd, 0xd5, 0x51,
	0xc7, 0x6c, 0x79, 0x40, 0x17, 0x47, 0x54, 0xe2, 0xa4, 0x76, 0xaf, 0xf2, 0xbe, 0xd5, 0x3f, 0x04,
	0x74, 0x76, 0xf7, 0x7f, 0x40, 0xe8, 0xfe, 0x9c, 0xb8, 0x7b, 0x18, 0x69, 0xa7, 0xfe, 0x8e, 0xbb,
	0x7d, 0xb0, 0x63, 0xfa, 0xcd, 0x9c, 0x32, 0x8f, 0x6a, 0xbb, 0x3a, 0x78, 0x19, 0xbf, 0x96, 0x53,
	0xc9, 0xd6, 0xff, 0xb2, 0x53, 0x86, 0xf4, 0xbf, 0xe4, 0xd4, 0x08, 0xec, 0x03, 0xba, 0xc0, 0x84,
	0x4d, 0xa8, 0x9a, 0x1b, 0xb1, 0x24, 0x42, 0x26, 0x53, 0x10, 0x27, 0x81, 0x22, 0xa7, 0xcc, 0xd7,
	0x44, 0x6d, 0xac, 0x1e, 0xdd, 0x19, 0x34, 0x12, 0x22, 0x74, 0x19, 0x5a, 0x11, 0x0f, 0x98, 0x3c,
	0xa0, 0x8b, 0xb8, 0x67, 0x0d, 0xaa, 0xc3, 0x36, 0xce, 0x12, 0xe8, 0x26, 0x34, 0x84, 0x22, 0x56,
	0x5f, 0xa8, 0xea, 0xe4, 0x5a, 0xa6, 0x42, 0x6f, 0x68, 0xba, 0x66, 0x40, 0xe8, 0x12, 0x34, 0x62,
	0x2e, 0x24, 0xf5, 0xb5, 0xe1, 0x36, 0x36, 0x91, 0xfb, 0xd2, 0x82, 0xb6, 0x6e, 0x3e, 0x15, 0x7a,
	0x88, 0xa2, 0x2e, 0x54, 0x78, 0xa4, 0x45, 0x76, 0x70, 0x85, 0x47, 0xa8, 0x07, 0xcd, 0x88, 0x2c,
	0x42, 0x4e, 0x52, 0x95, 0x69, 0x88, 0x6e, 0x81, 0x1d, 0xcc, 0x22, 0xe2, 0xa5, 0xa4, 0xe5, 0x4e,
	0x18, 0x05, 0x4b, 0x10, 0xba, 0x0b, 0xed, 0xf4, 0xf9, 0x78, 0x11, 0x51, 0x3d, 0x95, 0xbb, 0xa3,
	0x0b, 0xe9, 0x5c, 0xcf, 0x95, 0x70, 0x01, 0x88, 0x36, 0x01, 0xe2, 0xf2, 0x70, 0xce, 0x65, 0x54,
	0xa7, 0xe4, 0x72, 0x20, 0x36, 0x74, 0x39, 0x4b, 0xb8, 0xdf, 0x5b, 0xb0, 0x76, 0x7c, 0xc2, 0x76,
	0x88, 0xf4, 0xa6, 0x58, 0x1d, 0xf3, 0x58, 0xa2, 0x7b, 0xd0, 0x98, 0x52, 0xe2, 0x53, 0x61, 0x3e,
	0x9a, 0xcb, 0xd9, 0x39, 0xcc, 0xe3, 0x1e, 0x68, 0x4c, 0xda, 0xca, 0x64, 0x05, 0xba, 0x0d, 0xb6,
	0x48, 0xca, 0x69, 0xef, 0xd7, 0xf3, 0xf3, 0x46, 0x57, 0xd2, 0x77, 0x4f, 0x81, 0xee, 0x4f, 0x16,
	0x6c, 0x9c, 0x4b, 0x8e, 0x86, 0x50, 0x95, 0x27, 0xcc, 0xe8, 0x70, 0xca, 0xdf, 0x83, 0x21, 0x52,
	0x10, 0xf4, 0x16, 0xd4, 0xa4, 0xea, 0x5b, 0xa5, 0xf0, 0x7b, 0x98, 0x6d, 0xaa, 0x3b, 0xa7, 0x21,
	0xe8, 0x3d, 0x68, 0xf2, 0x48, 0xf9, 0x19, 0x1b, 0x6b, 0x52, 0xb4, 0x81, 0x1e, 0x26, 0x45, 0xc3,
	0x9e, 0x62, 0xdd, 0x1f, 0x2d, 0xb8, 0x94, 0xa9, 0x8c, 0x23, 0xce, 0x62, 0x6a, 0x64, 0xde, 0xc8,
	0xcb, 0x2c, 0xcf, 0x98, 0x9c, 0xc8, 0xd7, 0xff, 0xe5, 0xb8, 0x0e, 0x75, 0x2a, 0x04, 0x17, 0x46,
	0xe1, 0x5a, 0x06, 0xdc, 0x53, 0x69, 0x9c, 0x54, 0xdd, 0x1f, 0x2c, 0x70, 0xca, 0x9a, 0xd0, 0x07,
	0x25, 0xff, 0xde, 0x38, 0xe3, 0x5f, 0x5e, 0x7c, 0xc9, 0xc0, 0x3b, 0xd0, 0x12, 0xa6, 0x9e, 0x3a,
	0x88, 0xf2, 0xcd, 0x4c, 0x4a, 0x66, 0x51, 0x06, 0x75, 0xf7, 0x00, 0xb2, 0x66, 0xa3, 0xbb, 0xd0,
	0xe2, 0xe9, 0x57, 0x63, 0x54, 0x5c, 0xc8, 0xbb, 0x67, 0x4a, 0x29, 0xcd, 0x12, 0xeb, 0x5e, 0x85,
	0xd5, 0xdc, 0x36, 0xea, 0x0e, 0xe4, 0x13, 0x33, 0xbd, 0xdb, 0x58, 0x3f, 0xbb, 0x11, 0x74, 0x8b,
	0x46, 0xa1, 0x21, 0xac, 0x79, 0x82, 0x12, 0x49, 0x97, 0xbf, 0x69, 0x7a, 0x81, 0x8d, 0xcb, 0x69,
	0xf4, 0x2e, 0x6c, 0x90, 0x78, 0xc1, 0xbc, 0xa9, 0xe0, 0x8c, 0xcf, 0xe3, 0x5d, 0xb5, 0x09, 0x8b,
	0x8d, 0x1f, 0x36, 0x3e, 0xbf, 0xe8, 0xfe, 0x6e, 0x81, 0x9d, 0x76, 0x1e, 0x11, 0xe8, 0x7b, 0x9c,
	0x3d, 0x0e, 0x03, 0x4f, 0x3e, 0x0a, 0xe4, 0x74, 0x97, 0xcf, 0x66, 0x81, 0x94, 0xd4, 0xd7, 0x55,
	0xf3, 0xae, 0x57, 0xcd, 0xbb, 0xee, 0xbe, 0x12, 0x88, 0xff, 0x82, 0x04, 0xed, 0x82, 0x33, 0x67,
	0x1e, 0x15, 0x92, 0x04, 0x4c, 0x2e, 0x12, 0xe2, 0x64, 0x9c, 0xfe, 0xcf, 0x10, 0x3f, 0x2c, 0x95,
	0xf1, 0x99, 0x05, 0x6a, 0xa0, 0x90, 0xb1, 0x9e, 0x63, 0x7b, 0xb9, 0x83, 0x94, 0xba, 0x70, 0x3f,
	0x57, 0xc2, 0x05, 0xa0, 0xfb, 0x11, 0xf4, 0x5f, 0xad, 0x5b, 0x5f, 0xb1, 0x02, 0x96, 0x5d, 0xb1,
	0x2c, 0x73, 0xc5, 0xca, 0xe5, 0xdc, 0x3b, 0xe0, 0x94, 0x05, 0xbe, 0xd6, 0xba, 0x2e, 0xb4, 0xf3,
	0xba, 0xb6, 0xbe, 0x82, 0x6e, 0xf1, 0x42, 0x8b, 0x7a, 0x70, 0xf1, 0x88, 0x91, 0x28, 0x9e, 0x72,
	0x79, 0x44, 0x45, 0x40, 0xc2, 0xe0, 0x3b, 0x32, 0x0e, 0xa9, 0xb3, 0x82, 0xd6, 0xa1, 0x83, 0x29,
	0xf1, 0x97, 0x6a, 0x1d, 0x0b, 0xfd, 0x1f, 0x36, 0x0a, 0x29, 0x15, 0x1c, 0xb2, 0x70, 0xe1, 0x54,
	0xb6, 0xee, 0xeb, 0x5b, 0x42, 0xf2, 0xcd, 0xa1, 0x55, 0x68, 0x7e, 0x41, 0x99, 0x1f, 0xb0, 0x89,
	0xb3, 0xa2, 0x82, 0x23, 0x49, 0x26, 0x2a, 0xb0, 0x50, 0x07, 0x5a, 0x19, 0x61, 0x45, 0xd5, 0x8c,
	0x3e, 0xa7, 0xba, 0xf5, 0x35, 0x74, 0xf6, 0x99, 0xa4, 0x82, 0x91, 0x50, 0x1f, 0x69, 0x05, 0x5e,
	0xde, 0xe9, 0x9c, 0x15, 0x04, 0xd0, 0x48, 0xd6, 0x3a, 0x16, 0x6a, 0x83, 0x8d, 0x79, 0x18, 0x8e,
	0x89, 0xf7, 0xc4, 0xa9, 0x28, 0xa9, 0x8f, 0x48, 0x20, 0x97, 0xe7, 0xcb, 0xa9, 0xa2, 0x0e, 0xd8,
	0x98, 0xc6, 0x54, 0x3c, 0xa5, 0xbe, 0xf3, 0x5b, 0x73, 0xeb, 0x53, 0x68, 0xe7, 0x27, 0x3e, 0x72,
	0xa0, 0xad, 0xc4, 0xa7, 0xb9, 0xe4, 0x75, 0xf5, 0xef, 0xf0, 0x32, 0x65, 0xa1, 0x0d, 0x58, 0x57,
	0xa0, 0x62, 0xba, 0xb2, 0x75, 0x1d, 0xba, 0xc5, 0x29, 0x88, 0x6c, 0xa8, 0x29, 0xa0, 0xb3, 0x82,
	0x5a, 0x50, 0xd7, 0x70, 0xc7, 0xda, 0x71, 0x9e, 0xff, 0xba, 0x69, 0x3d, 0x3b, 0xdd, 0xb4, 0x9e,
	0x9f, 0x6e, 0x5a, 0x2f, 0x4f, 0x37, 0xad, 0x71, 0x43, 0xff, 0x55, 0xb9, 0xfd, 0x67, 0x00, 0x00,
	0x00, 0xff, 0xff, 0x2b, 0x68, 0xac, 0x50, 0xef, 0x0c, 0x00, 0x00,
}

func (m *TxnMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.IsolationLevel != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.IsolationLevel))
	}
	if len(m.TxnRecordRouteKey) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(len(m.TxnRecordRouteKey)))
		i += copy(dAtA[i:], m.TxnRecordRouteKey)
	}
	if m.TxnRecordShardGroup != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.TxnRecordShardGroup))
	}
	if m.Epoch != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.Epoch))
	}
	if m.Priority != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.Priority))
	}
	if m.WriteTimestamp != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.WriteTimestamp))
	}
	if m.ReadTimestamp != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.ReadTimestamp))
	}
	if m.MaxTimestamp != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.MaxTimestamp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnRecord) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintTxnpb(dAtA, i, uint64(m.TxnMeta.Size()))
	n1, err := m.TxnMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.Status))
	}
	if m.LastHeartbeat != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.LastHeartbeat))
	}
	if len(m.CompletedWrites) > 0 {
		for k, _ := range m.CompletedWrites {
			dAtA[i] = 0x22
			i++
			v := m.CompletedWrites[k]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovTxnpb(uint64(msgSize))
			}
			mapSize := 1 + sovTxnpb(uint64(k)) + msgSize
			i = encodeVarintTxnpb(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTxnpb(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintTxnpb(dAtA, i, uint64((&v).Size()))
			n2, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n2
		}
	}
	if len(m.InfightWrites) > 0 {
		for k, _ := range m.InfightWrites {
			dAtA[i] = 0x2a
			i++
			v := m.InfightWrites[k]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovTxnpb(uint64(msgSize))
			}
			mapSize := 1 + sovTxnpb(uint64(k)) + msgSize
			i = encodeVarintTxnpb(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTxnpb(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintTxnpb(dAtA, i, uint64((&v).Size()))
			n3, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n3
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnOpMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnOpMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintTxnpb(dAtA, i, uint64(m.TxnMeta.Size()))
	n4, err := m.TxnMeta.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	if m.Sequence != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.Sequence))
	}
	if len(m.CompletedWrites) > 0 {
		for k, _ := range m.CompletedWrites {
			dAtA[i] = 0x22
			i++
			v := m.CompletedWrites[k]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovTxnpb(uint64(msgSize))
			}
			mapSize := 1 + sovTxnpb(uint64(k)) + msgSize
			i = encodeVarintTxnpb(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTxnpb(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintTxnpb(dAtA, i, uint64((&v).Size()))
			n5, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n5
		}
	}
	if len(m.InfightWrites) > 0 {
		for k, _ := range m.InfightWrites {
			dAtA[i] = 0x2a
			i++
			v := m.InfightWrites[k]
			msgSize := 0
			if (&v) != nil {
				msgSize = (&v).Size()
				msgSize += 1 + sovTxnpb(uint64(msgSize))
			}
			mapSize := 1 + sovTxnpb(uint64(k)) + msgSize
			i = encodeVarintTxnpb(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTxnpb(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintTxnpb(dAtA, i, uint64((&v).Size()))
			n6, err := (&v).MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n6
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KeyRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyRange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Start) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(len(m.Start)))
		i += copy(dAtA[i:], m.Start)
	}
	if len(m.End) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(len(m.End)))
		i += copy(dAtA[i:], m.End)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KeySet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeySet) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PointKeys) > 0 {
		for _, b := range m.PointKeys {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTxnpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Ranges) > 0 {
		for _, msg := range m.Ranges {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTxnpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Sorted {
		dAtA[i] = 0x18
		i++
		if m.Sorted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnOperation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnOperation) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Op != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.Op))
	}
	if len(m.Payload) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(len(m.Payload)))
		i += copy(dAtA[i:], m.Payload)
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTxnpb(dAtA, i, uint64(m.Impacted.Size()))
	n7, err := m.Impacted.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	if m.ImpactedType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.ImpactedType))
	}
	if m.ShardGroup != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.ShardGroup))
	}
	if m.Timestamp != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.Timestamp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnBatchRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnBatchRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintTxnpb(dAtA, i, uint64(m.Header.Size()))
	n8, err := m.Header.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if len(m.Requests) > 0 {
		for _, msg := range m.Requests {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTxnpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnBatchRequestHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnBatchRequestHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintTxnpb(dAtA, i, uint64(m.Txn.Size()))
	n9, err := m.Txn.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.Type))
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintTxnpb(dAtA, i, uint64(m.Options.Size()))
	n10, err := m.Options.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnBatchResponseHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnBatchResponseHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintTxnpb(dAtA, i, uint64(m.Txn.Size()))
	n11, err := m.Txn.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	if m.Status != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.Status))
	}
	if m.Error != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.Error.Size()))
		n12, err := m.Error.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnBatchResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnBatchResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintTxnpb(dAtA, i, uint64(m.Header.Size()))
	n13, err := m.Header.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	if len(m.Responses) > 0 {
		for _, msg := range m.Responses {
			dAtA[i] = 0x12
			i++
			i = encodeVarintTxnpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintTxnpb(dAtA, i, uint64(m.Operation.Size()))
	n14, err := m.Operation.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RequestOptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestOptions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CreateTxnRecord {
		dAtA[i] = 0x8
		i++
		if m.CreateTxnRecord {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.AsynchronousConsensus {
		dAtA[i] = 0x10
		i++
		if m.AsynchronousConsensus {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TxnError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxnError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConflictWithCommittedError != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.ConflictWithCommittedError.Size()))
		n15, err := m.ConflictWithCommittedError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.UncertaintyError != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.UncertaintyError.Size()))
		n16, err := m.UncertaintyError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	if m.AbortedError != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.AbortedError.Size()))
		n17, err := m.AbortedError.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConflictWithCommittedError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConflictWithCommittedError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MinTimestamp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.MinTimestamp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UncertaintyError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UncertaintyError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.MinTimestamp != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTxnpb(dAtA, i, uint64(m.MinTimestamp))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AbortedError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AbortedError) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintTxnpb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *TxnMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovTxnpb(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTxnpb(uint64(l))
	}
	if m.IsolationLevel != 0 {
		n += 1 + sovTxnpb(uint64(m.IsolationLevel))
	}
	l = len(m.TxnRecordRouteKey)
	if l > 0 {
		n += 1 + l + sovTxnpb(uint64(l))
	}
	if m.TxnRecordShardGroup != 0 {
		n += 1 + sovTxnpb(uint64(m.TxnRecordShardGroup))
	}
	if m.Epoch != 0 {
		n += 1 + sovTxnpb(uint64(m.Epoch))
	}
	if m.Priority != 0 {
		n += 1 + sovTxnpb(uint64(m.Priority))
	}
	if m.WriteTimestamp != 0 {
		n += 1 + sovTxnpb(uint64(m.WriteTimestamp))
	}
	if m.ReadTimestamp != 0 {
		n += 1 + sovTxnpb(uint64(m.ReadTimestamp))
	}
	if m.MaxTimestamp != 0 {
		n += 1 + sovTxnpb(uint64(m.MaxTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TxnMeta.Size()
	n += 1 + l + sovTxnpb(uint64(l))
	if m.Status != 0 {
		n += 1 + sovTxnpb(uint64(m.Status))
	}
	if m.LastHeartbeat != 0 {
		n += 1 + sovTxnpb(uint64(m.LastHeartbeat))
	}
	if len(m.CompletedWrites) > 0 {
		for k, v := range m.CompletedWrites {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovTxnpb(uint64(k)) + 1 + l + sovTxnpb(uint64(l))
			n += mapEntrySize + 1 + sovTxnpb(uint64(mapEntrySize))
		}
	}
	if len(m.InfightWrites) > 0 {
		for k, v := range m.InfightWrites {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovTxnpb(uint64(k)) + 1 + l + sovTxnpb(uint64(l))
			n += mapEntrySize + 1 + sovTxnpb(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnOpMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TxnMeta.Size()
	n += 1 + l + sovTxnpb(uint64(l))
	if m.Sequence != 0 {
		n += 1 + sovTxnpb(uint64(m.Sequence))
	}
	if len(m.CompletedWrites) > 0 {
		for k, v := range m.CompletedWrites {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovTxnpb(uint64(k)) + 1 + l + sovTxnpb(uint64(l))
			n += mapEntrySize + 1 + sovTxnpb(uint64(mapEntrySize))
		}
	}
	if len(m.InfightWrites) > 0 {
		for k, v := range m.InfightWrites {
			_ = k
			_ = v
			l = v.Size()
			mapEntrySize := 1 + sovTxnpb(uint64(k)) + 1 + l + sovTxnpb(uint64(l))
			n += mapEntrySize + 1 + sovTxnpb(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeyRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Start)
	if l > 0 {
		n += 1 + l + sovTxnpb(uint64(l))
	}
	l = len(m.End)
	if l > 0 {
		n += 1 + l + sovTxnpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KeySet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.PointKeys) > 0 {
		for _, b := range m.PointKeys {
			l = len(b)
			n += 1 + l + sovTxnpb(uint64(l))
		}
	}
	if len(m.Ranges) > 0 {
		for _, e := range m.Ranges {
			l = e.Size()
			n += 1 + l + sovTxnpb(uint64(l))
		}
	}
	if m.Sorted {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnOperation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovTxnpb(uint64(m.Op))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovTxnpb(uint64(l))
	}
	l = m.Impacted.Size()
	n += 1 + l + sovTxnpb(uint64(l))
	if m.ImpactedType != 0 {
		n += 1 + sovTxnpb(uint64(m.ImpactedType))
	}
	if m.ShardGroup != 0 {
		n += 1 + sovTxnpb(uint64(m.ShardGroup))
	}
	if m.Timestamp != 0 {
		n += 1 + sovTxnpb(uint64(m.Timestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnBatchRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovTxnpb(uint64(l))
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovTxnpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnBatchRequestHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Txn.Size()
	n += 1 + l + sovTxnpb(uint64(l))
	if m.Type != 0 {
		n += 1 + sovTxnpb(uint64(m.Type))
	}
	l = m.Options.Size()
	n += 1 + l + sovTxnpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnBatchResponseHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Txn.Size()
	n += 1 + l + sovTxnpb(uint64(l))
	if m.Status != 0 {
		n += 1 + sovTxnpb(uint64(m.Status))
	}
	if m.Error != nil {
		l = m.Error.Size()
		n += 1 + l + sovTxnpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnBatchResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovTxnpb(uint64(l))
	if len(m.Responses) > 0 {
		for _, e := range m.Responses {
			l = e.Size()
			n += 1 + l + sovTxnpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Operation.Size()
	n += 1 + l + sovTxnpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTxnpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RequestOptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreateTxnRecord {
		n += 2
	}
	if m.AsynchronousConsensus {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TxnError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConflictWithCommittedError != nil {
		l = m.ConflictWithCommittedError.Size()
		n += 1 + l + sovTxnpb(uint64(l))
	}
	if m.UncertaintyError != nil {
		l = m.UncertaintyError.Size()
		n += 1 + l + sovTxnpb(uint64(l))
	}
	if m.AbortedError != nil {
		l = m.AbortedError.Size()
		n += 1 + l + sovTxnpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConflictWithCommittedError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinTimestamp != 0 {
		n += 1 + sovTxnpb(uint64(m.MinTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UncertaintyError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MinTimestamp != 0 {
		n += 1 + sovTxnpb(uint64(m.MinTimestamp))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AbortedError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovTxnpb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTxnpb(x uint64) (n int) {
	return sovTxnpb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TxnMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsolationLevel", wireType)
			}
			m.IsolationLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IsolationLevel |= IsolationLevel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnRecordRouteKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxnRecordRouteKey = append(m.TxnRecordRouteKey[:0], dAtA[iNdEx:postIndex]...)
			if m.TxnRecordRouteKey == nil {
				m.TxnRecordRouteKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnRecordShardGroup", wireType)
			}
			m.TxnRecordShardGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxnRecordShardGroup |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Priority", wireType)
			}
			m.Priority = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Priority |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteTimestamp", wireType)
			}
			m.WriteTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WriteTimestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadTimestamp", wireType)
			}
			m.ReadTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadTimestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTimestamp", wireType)
			}
			m.MaxTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTimestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTxnpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxnMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TxnStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeartbeat", wireType)
			}
			m.LastHeartbeat = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastHeartbeat |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedWrites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompletedWrites == nil {
				m.CompletedWrites = make(map[uint64]KeySet)
			}
			var mapkey uint64
			mapvalue := &KeySet{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTxnpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTxnpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTxnpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTxnpb
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTxnpb
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &KeySet{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTxnpb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTxnpb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CompletedWrites[mapkey] = *mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfightWrites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InfightWrites == nil {
				m.InfightWrites = make(map[uint64]KeySet)
			}
			var mapkey uint64
			mapvalue := &KeySet{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTxnpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTxnpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTxnpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTxnpb
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTxnpb
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &KeySet{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTxnpb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTxnpb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.InfightWrites[mapkey] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxnpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnOpMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnOpMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnOpMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxnMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sequence", wireType)
			}
			m.Sequence = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sequence |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletedWrites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CompletedWrites == nil {
				m.CompletedWrites = make(map[uint64]KeySet)
			}
			var mapkey uint64
			mapvalue := &KeySet{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTxnpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTxnpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTxnpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTxnpb
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTxnpb
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &KeySet{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTxnpb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTxnpb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.CompletedWrites[mapkey] = *mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InfightWrites", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InfightWrites == nil {
				m.InfightWrites = make(map[uint64]KeySet)
			}
			var mapkey uint64
			mapvalue := &KeySet{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTxnpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTxnpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTxnpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTxnpb
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthTxnpb
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &KeySet{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTxnpb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTxnpb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.InfightWrites[mapkey] = *mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxnpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Start = append(m.Start[:0], dAtA[iNdEx:postIndex]...)
			if m.Start == nil {
				m.Start = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.End = append(m.End[:0], dAtA[iNdEx:postIndex]...)
			if m.End == nil {
				m.End = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxnpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeySet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeySet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeySet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PointKeys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PointKeys = append(m.PointKeys, make([]byte, postIndex-iNdEx))
			copy(m.PointKeys[len(m.PointKeys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ranges", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ranges = append(m.Ranges, KeyRange{})
			if err := m.Ranges[len(m.Ranges)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sorted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sorted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTxnpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnOperation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnOperation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnOperation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Impacted", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Impacted.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImpactedType", wireType)
			}
			m.ImpactedType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ImpactedType |= ImpactedType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardGroup", wireType)
			}
			m.ShardGroup = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardGroup |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTxnpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnBatchRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnBatchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnBatchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, TxnRequest{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxnpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnBatchRequestHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnBatchRequestHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnBatchRequestHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= TxnRequestType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxnpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnBatchResponseHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnBatchResponseHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnBatchResponseHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Txn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TxnStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Error == nil {
				m.Error = &TxnError{}
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxnpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnBatchResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnBatchResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnBatchResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Responses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Responses = append(m.Responses, TxnResponse{})
			if err := m.Responses[len(m.Responses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxnpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Operation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxnpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxnpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestOptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestOptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestOptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTxnRecord", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CreateTxnRecord = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AsynchronousConsensus", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AsynchronousConsensus = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTxnpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxnError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxnError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxnError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConflictWithCommittedError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConflictWithCommittedError == nil {
				m.ConflictWithCommittedError = &ConflictWithCommittedError{}
			}
			if err := m.ConflictWithCommittedError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UncertaintyError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UncertaintyError == nil {
				m.UncertaintyError = &UncertaintyError{}
			}
			if err := m.UncertaintyError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AbortedError", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTxnpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTxnpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AbortedError == nil {
				m.AbortedError = &AbortedError{}
			}
			if err := m.AbortedError.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTxnpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConflictWithCommittedError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConflictWithCommittedError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConflictWithCommittedError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinTimestamp", wireType)
			}
			m.MinTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinTimestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTxnpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UncertaintyError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UncertaintyError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UncertaintyError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinTimestamp", wireType)
			}
			m.MinTimestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinTimestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTxnpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AbortedError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AbortedError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AbortedError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTxnpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthTxnpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTxnpb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTxnpb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTxnpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTxnpb
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthTxnpb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTxnpb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTxnpb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthTxnpb
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTxnpb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTxnpb   = fmt.Errorf("proto: integer overflow")
)
