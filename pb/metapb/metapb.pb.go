// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: metapb.proto

package metapb

import (
	fmt "fmt"
	io "io"
	math "math"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	raftpb "go.etcd.io/etcd/raft/v3/raftpb"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// ShardKind the shard kind
type ShardType int32

const (
	ShardType_LeaderOnly ShardType = 0
	ShardType_AllShards  ShardType = 1
)

var ShardType_name = map[int32]string{
	0: "LeaderOnly",
	1: "AllShards",
}

var ShardType_value = map[string]int32{
	"LeaderOnly": 0,
	"AllShards":  1,
}

func (x ShardType) String() string {
	return proto.EnumName(ShardType_name, int32(x))
}

func (ShardType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{0}
}

// StoreState the store state
type StoreState int32

const (
	// Up is normal state
	StoreState_Up StoreState = 0
	// Down is the unavailable state
	StoreState_Down StoreState = 1
	// Tombstone is the destroy state
	StoreState_StoreTombstone StoreState = 2
)

var StoreState_name = map[int32]string{
	0: "Up",
	1: "Down",
	2: "StoreTombstone",
}

var StoreState_value = map[string]int32{
	"Up":             0,
	"Down":           1,
	"StoreTombstone": 2,
}

func (x StoreState) String() string {
	return proto.EnumName(StoreState_name, int32(x))
}

func (StoreState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{1}
}

// ShardState the shard state
type ShardState int32

const (
	// Running is serve state,
	// this state provides read and write services to the public normally.
	ShardState_Running ShardState = 0
	// Creating is waiting to create state,
	// this state does not provide read and write services to the public.
	ShardState_Creating ShardState = 1
	// Destroying is waiting to destroy state,
	// this state normally cannot provide read and write services to the public,
	// and the destruction process of shards has not yet been completed.
	ShardState_Destroying ShardState = 2
	// Destroyed is the destroyed state,
	// this state is normally not available for external read and write services,
	// the shards have been destroyed in the whole cluster and cannot be used again.
	ShardState_Destroyed ShardState = 3
)

var ShardState_name = map[int32]string{
	0: "Running",
	1: "Creating",
	2: "Destroying",
	3: "Destroyed",
}

var ShardState_value = map[string]int32{
	"Running":    0,
	"Creating":   1,
	"Destroying": 2,
	"Destroyed":  3,
}

func (x ShardState) String() string {
	return proto.EnumName(ShardState_name, int32(x))
}

func (ShardState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{2}
}

// ConfigChangeType change replica type
type ConfigChangeType int32

const (
	ConfigChangeType_AddNode        ConfigChangeType = 0
	ConfigChangeType_RemoveNode     ConfigChangeType = 1
	ConfigChangeType_UpdateNode     ConfigChangeType = 2
	ConfigChangeType_AddLearnerNode ConfigChangeType = 3
)

var ConfigChangeType_name = map[int32]string{
	0: "AddNode",
	1: "RemoveNode",
	2: "UpdateNode",
	3: "AddLearnerNode",
}

var ConfigChangeType_value = map[string]int32{
	"AddNode":        0,
	"RemoveNode":     1,
	"UpdateNode":     2,
	"AddLearnerNode": 3,
}

func (x ConfigChangeType) String() string {
	return proto.EnumName(ConfigChangeType_name, int32(x))
}

func (ConfigChangeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{3}
}

// ReplicaRole role of current replica
type ReplicaRole int32

const (
	ReplicaRole_Voter         ReplicaRole = 0
	ReplicaRole_Learner       ReplicaRole = 1
	ReplicaRole_IncomingVoter ReplicaRole = 2
	ReplicaRole_DemotingVoter ReplicaRole = 3
)

var ReplicaRole_name = map[int32]string{
	0: "Voter",
	1: "Learner",
	2: "IncomingVoter",
	3: "DemotingVoter",
}

var ReplicaRole_value = map[string]int32{
	"Voter":         0,
	"Learner":       1,
	"IncomingVoter": 2,
	"DemotingVoter": 3,
}

func (x ReplicaRole) String() string {
	return proto.EnumName(ReplicaRole_name, int32(x))
}

func (ReplicaRole) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{4}
}

// CheckPolicy check policy
type CheckPolicy int32

const (
	CheckPolicy_SCAN        CheckPolicy = 0
	CheckPolicy_APPROXIMATE CheckPolicy = 1
	CheckPolicy_USEKEY      CheckPolicy = 2
)

var CheckPolicy_name = map[int32]string{
	0: "SCAN",
	1: "APPROXIMATE",
	2: "USEKEY",
}

var CheckPolicy_value = map[string]int32{
	"SCAN":        0,
	"APPROXIMATE": 1,
	"USEKEY":      2,
}

func (x CheckPolicy) String() string {
	return proto.EnumName(CheckPolicy_name, int32(x))
}

func (CheckPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{5}
}

// OperatorStatus Operator Status
type OperatorStatus int32

const (
	OperatorStatus_SUCCESS OperatorStatus = 0
	OperatorStatus_TIMEOUT OperatorStatus = 1
	OperatorStatus_CANCEL  OperatorStatus = 2
	OperatorStatus_REPLACE OperatorStatus = 3
	OperatorStatus_RUNNING OperatorStatus = 4
)

var OperatorStatus_name = map[int32]string{
	0: "SUCCESS",
	1: "TIMEOUT",
	2: "CANCEL",
	3: "REPLACE",
	4: "RUNNING",
}

var OperatorStatus_value = map[string]int32{
	"SUCCESS": 0,
	"TIMEOUT": 1,
	"CANCEL":  2,
	"REPLACE": 3,
	"RUNNING": 4,
}

func (x OperatorStatus) String() string {
	return proto.EnumName(OperatorStatus_name, int32(x))
}

func (OperatorStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{6}
}

// JobType job type
type JobType int32

const (
	// RemoveShard remove shard job
	JobType_RemoveShard JobType = 0
	// CreateShardPool create shard pool
	JobType_CreateShardPool JobType = 1
	// CustomStartAt custom job
	JobType_CustomStartAt JobType = 100
)

var JobType_name = map[int32]string{
	0:   "RemoveShard",
	1:   "CreateShardPool",
	100: "CustomStartAt",
}

var JobType_value = map[string]int32{
	"RemoveShard":     0,
	"CreateShardPool": 1,
	"CustomStartAt":   100,
}

func (x JobType) String() string {
	return proto.EnumName(JobType_name, int32(x))
}

func (JobType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{7}
}

// JobState job state
type JobState int32

const (
	// Created wait to running
	JobState_Created JobState = 0
	// Working job is working
	JobState_Working JobState = 1
	// Completed job completed, need to gc
	JobState_Completed JobState = 2
)

var JobState_name = map[int32]string{
	0: "Created",
	1: "Working",
	2: "Completed",
}

var JobState_value = map[string]int32{
	"Created":   0,
	"Working":   1,
	"Completed": 2,
}

func (x JobState) String() string {
	return proto.EnumName(JobState_name, int32(x))
}

func (JobState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{8}
}

// ReplicaState the state of the shard peer
type ReplicaState int32

const (
	ReplicaState_Normal           ReplicaState = 0
	ReplicaState_Applying         ReplicaState = 1
	ReplicaState_ReplicaTombstone ReplicaState = 2
)

var ReplicaState_name = map[int32]string{
	0: "Normal",
	1: "Applying",
	2: "ReplicaTombstone",
}

var ReplicaState_value = map[string]int32{
	"Normal":           0,
	"Applying":         1,
	"ReplicaTombstone": 2,
}

func (x ReplicaState) String() string {
	return proto.EnumName(ReplicaState_name, int32(x))
}

func (ReplicaState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{9}
}

// ShardsPoolCmdType shards pool cmd
type ShardsPoolCmdType int32

const (
	ShardsPoolCmdType_CreateShard ShardsPoolCmdType = 0
	ShardsPoolCmdType_AllocShard  ShardsPoolCmdType = 1
)

var ShardsPoolCmdType_name = map[int32]string{
	0: "CreateShard",
	1: "AllocShard",
}

var ShardsPoolCmdType_value = map[string]int32{
	"CreateShard": 0,
	"AllocShard":  1,
}

func (x ShardsPoolCmdType) String() string {
	return proto.EnumName(ShardsPoolCmdType_name, int32(x))
}

func (ShardsPoolCmdType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{10}
}

// ShardEpoch shard epoch
type ShardEpoch struct {
	// Conf change version, auto increment when add or remove replica
	ConfigVer uint64 `protobuf:"varint,1,opt,name=configVer,proto3" json:"configVer,omitempty"`
	// Shard generation, auto increment when split or merge
	Generation           uint64   `protobuf:"varint,2,opt,name=generation,proto3" json:"generation,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShardEpoch) Reset()         { *m = ShardEpoch{} }
func (m *ShardEpoch) String() string { return proto.CompactTextString(m) }
func (*ShardEpoch) ProtoMessage()    {}
func (*ShardEpoch) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{0}
}
func (m *ShardEpoch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardEpoch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardEpoch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardEpoch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardEpoch.Merge(m, src)
}
func (m *ShardEpoch) XXX_Size() int {
	return m.Size()
}
func (m *ShardEpoch) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardEpoch.DiscardUnknown(m)
}

var xxx_messageInfo_ShardEpoch proto.InternalMessageInfo

func (m *ShardEpoch) GetConfigVer() uint64 {
	if m != nil {
		return m.ConfigVer
	}
	return 0
}

func (m *ShardEpoch) GetGeneration() uint64 {
	if m != nil {
		return m.Generation
	}
	return 0
}

// Replica of the shard
type Replica struct {
	ID                   uint64      `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	StoreID              uint64      `protobuf:"varint,2,opt,name=storeID,proto3" json:"storeID,omitempty"`
	Role                 ReplicaRole `protobuf:"varint,3,opt,name=role,proto3,enum=metapb.ReplicaRole" json:"role,omitempty"`
	InitialMember        bool        `protobuf:"varint,4,opt,name=initialMember,proto3" json:"initialMember,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Replica) Reset()         { *m = Replica{} }
func (m *Replica) String() string { return proto.CompactTextString(m) }
func (*Replica) ProtoMessage()    {}
func (*Replica) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{1}
}
func (m *Replica) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Replica) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Replica.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Replica) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Replica.Merge(m, src)
}
func (m *Replica) XXX_Size() int {
	return m.Size()
}
func (m *Replica) XXX_DiscardUnknown() {
	xxx_messageInfo_Replica.DiscardUnknown(m)
}

var xxx_messageInfo_Replica proto.InternalMessageInfo

func (m *Replica) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Replica) GetStoreID() uint64 {
	if m != nil {
		return m.StoreID
	}
	return 0
}

func (m *Replica) GetRole() ReplicaRole {
	if m != nil {
		return m.Role
	}
	return ReplicaRole_Voter
}

func (m *Replica) GetInitialMember() bool {
	if m != nil {
		return m.InitialMember
	}
	return false
}

// ReplicaStats replica stats
type ReplicaStats struct {
	Replica              Replica  `protobuf:"bytes,1,opt,name=replica,proto3" json:"replica"`
	DownSeconds          uint64   `protobuf:"varint,2,opt,name=downSeconds,proto3" json:"downSeconds,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReplicaStats) Reset()         { *m = ReplicaStats{} }
func (m *ReplicaStats) String() string { return proto.CompactTextString(m) }
func (*ReplicaStats) ProtoMessage()    {}
func (*ReplicaStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{2}
}
func (m *ReplicaStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReplicaStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReplicaStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReplicaStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReplicaStats.Merge(m, src)
}
func (m *ReplicaStats) XXX_Size() int {
	return m.Size()
}
func (m *ReplicaStats) XXX_DiscardUnknown() {
	xxx_messageInfo_ReplicaStats.DiscardUnknown(m)
}

var xxx_messageInfo_ReplicaStats proto.InternalMessageInfo

func (m *ReplicaStats) GetReplica() Replica {
	if m != nil {
		return m.Replica
	}
	return Replica{}
}

func (m *ReplicaStats) GetDownSeconds() uint64 {
	if m != nil {
		return m.DownSeconds
	}
	return 0
}

// Label key value label
type Label struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Label) Reset()         { *m = Label{} }
func (m *Label) String() string { return proto.CompactTextString(m) }
func (*Label) ProtoMessage()    {}
func (*Label) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{3}
}
func (m *Label) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Label) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Label.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Label) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Label.Merge(m, src)
}
func (m *Label) XXX_Size() int {
	return m.Size()
}
func (m *Label) XXX_DiscardUnknown() {
	xxx_messageInfo_Label.DiscardUnknown(m)
}

var xxx_messageInfo_Label proto.InternalMessageInfo

func (m *Label) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *Label) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// ShardStats shard stats
type ShardStats struct {
	// shard ID
	ShardID uint64 `protobuf:"varint,1,opt,name=shardID,proto3" json:"shardID,omitempty"`
	// bytes written during this period
	WrittenBytes uint64 `protobuf:"varint,2,opt,name=writtenBytes,proto3" json:"writtenBytes,omitempty"`
	// keys written during this period
	WrittenKeys uint64 `protobuf:"varint,3,opt,name=writtenKeys,proto3" json:"writtenKeys,omitempty"`
	// bytes read during this period
	ReadBytes uint64 `protobuf:"varint,4,opt,name=readBytes,proto3" json:"readBytes,omitempty"`
	// keys read during this period
	ReadKeys uint64 `protobuf:"varint,5,opt,name=readKeys,proto3" json:"readKeys,omitempty"`
	// approximate data size in bytes of the shard
	ApproximateSize uint64 `protobuf:"varint,6,opt,name=approximateSize,proto3" json:"approximateSize,omitempty"`
	// approximate count of keys in the shard
	ApproximateKeys uint64 `protobuf:"varint,7,opt,name=approximateKeys,proto3" json:"approximateKeys,omitempty"`
	// Actually reported time interval
	Interval             *TimeInterval `protobuf:"bytes,8,opt,name=interval,proto3" json:"interval,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ShardStats) Reset()         { *m = ShardStats{} }
func (m *ShardStats) String() string { return proto.CompactTextString(m) }
func (*ShardStats) ProtoMessage()    {}
func (*ShardStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{4}
}
func (m *ShardStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardStats.Merge(m, src)
}
func (m *ShardStats) XXX_Size() int {
	return m.Size()
}
func (m *ShardStats) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardStats.DiscardUnknown(m)
}

var xxx_messageInfo_ShardStats proto.InternalMessageInfo

func (m *ShardStats) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *ShardStats) GetWrittenBytes() uint64 {
	if m != nil {
		return m.WrittenBytes
	}
	return 0
}

func (m *ShardStats) GetWrittenKeys() uint64 {
	if m != nil {
		return m.WrittenKeys
	}
	return 0
}

func (m *ShardStats) GetReadBytes() uint64 {
	if m != nil {
		return m.ReadBytes
	}
	return 0
}

func (m *ShardStats) GetReadKeys() uint64 {
	if m != nil {
		return m.ReadKeys
	}
	return 0
}

func (m *ShardStats) GetApproximateSize() uint64 {
	if m != nil {
		return m.ApproximateSize
	}
	return 0
}

func (m *ShardStats) GetApproximateKeys() uint64 {
	if m != nil {
		return m.ApproximateKeys
	}
	return 0
}

func (m *ShardStats) GetInterval() *TimeInterval {
	if m != nil {
		return m.Interval
	}
	return nil
}

// StoreStats store stats
type StoreStats struct {
	// Store id
	StoreID uint64 `protobuf:"varint,1,opt,name=storeID,proto3" json:"storeID,omitempty"`
	// When the store is started (unix timestamp in seconds).
	StartTime uint64 `protobuf:"varint,2,opt,name=startTime,proto3" json:"startTime,omitempty"`
	// Actually reported time interval
	Interval *TimeInterval `protobuf:"bytes,3,opt,name=interval,proto3" json:"interval,omitempty"`
	// Capacity for the store.
	Capacity uint64 `protobuf:"varint,4,opt,name=capacity,proto3" json:"capacity,omitempty"`
	// Available size for the store.
	Available uint64 `protobuf:"varint,5,opt,name=available,proto3" json:"available,omitempty"`
	// Actually used space by db
	UsedSize uint64 `protobuf:"varint,6,opt,name=usedSize,proto3" json:"usedSize,omitempty"`
	// If the store is busy
	IsBusy bool `protobuf:"varint,7,opt,name=isBusy,proto3" json:"isBusy,omitempty"`
	// Total shard count in this store.
	ShardCount uint64 `protobuf:"varint,8,opt,name=shardCount,proto3" json:"shardCount,omitempty"`
	// Current sending snapshot count.
	SendingSnapCount uint64 `protobuf:"varint,9,opt,name=sendingSnapCount,proto3" json:"sendingSnapCount,omitempty"`
	// Current receiving snapshot count.
	ReceivingSnapCount uint64 `protobuf:"varint,10,opt,name=receivingSnapCount,proto3" json:"receivingSnapCount,omitempty"`
	// How many shard is applying snapshot.
	ApplyingSnapCount uint64 `protobuf:"varint,11,opt,name=applyingSnapCount,proto3" json:"applyingSnapCount,omitempty"`
	// Bytes written for the store during this period.
	WrittenBytes uint64 `protobuf:"varint,12,opt,name=writtenBytes,proto3" json:"writtenBytes,omitempty"`
	// Bytes read for the store during this period.
	ReadBytes uint64 `protobuf:"varint,13,opt,name=readBytes,proto3" json:"readBytes,omitempty"`
	// Bytes written for the store during this period.
	WrittenKeys uint64 `protobuf:"varint,14,opt,name=writtenKeys,proto3" json:"writtenKeys,omitempty"`
	// Bytes read for the store during this period.
	ReadKeys uint64 `protobuf:"varint,15,opt,name=readKeys,proto3" json:"readKeys,omitempty"`
	// Threads' CPU usages in the store
	CpuUsages []RecordPair `protobuf:"bytes,16,rep,name=cpuUsages,proto3" json:"cpuUsages"`
	// Threads' read disk I/O rates in the store
	ReadIORates []RecordPair `protobuf:"bytes,17,rep,name=readIORates,proto3" json:"readIORates"`
	// Threads' write disk I/O rates in the store
	WriteIORates []RecordPair `protobuf:"bytes,18,rep,name=writeIORates,proto3" json:"writeIORates"`
	// Operations' latencies in the store
	OpLatencies          []RecordPair `protobuf:"bytes,19,rep,name=opLatencies,proto3" json:"opLatencies"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *StoreStats) Reset()         { *m = StoreStats{} }
func (m *StoreStats) String() string { return proto.CompactTextString(m) }
func (*StoreStats) ProtoMessage()    {}
func (*StoreStats) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{5}
}
func (m *StoreStats) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreStats) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreStats.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreStats) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreStats.Merge(m, src)
}
func (m *StoreStats) XXX_Size() int {
	return m.Size()
}
func (m *StoreStats) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreStats.DiscardUnknown(m)
}

var xxx_messageInfo_StoreStats proto.InternalMessageInfo

func (m *StoreStats) GetStoreID() uint64 {
	if m != nil {
		return m.StoreID
	}
	return 0
}

func (m *StoreStats) GetStartTime() uint64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *StoreStats) GetInterval() *TimeInterval {
	if m != nil {
		return m.Interval
	}
	return nil
}

func (m *StoreStats) GetCapacity() uint64 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

func (m *StoreStats) GetAvailable() uint64 {
	if m != nil {
		return m.Available
	}
	return 0
}

func (m *StoreStats) GetUsedSize() uint64 {
	if m != nil {
		return m.UsedSize
	}
	return 0
}

func (m *StoreStats) GetIsBusy() bool {
	if m != nil {
		return m.IsBusy
	}
	return false
}

func (m *StoreStats) GetShardCount() uint64 {
	if m != nil {
		return m.ShardCount
	}
	return 0
}

func (m *StoreStats) GetSendingSnapCount() uint64 {
	if m != nil {
		return m.SendingSnapCount
	}
	return 0
}

func (m *StoreStats) GetReceivingSnapCount() uint64 {
	if m != nil {
		return m.ReceivingSnapCount
	}
	return 0
}

func (m *StoreStats) GetApplyingSnapCount() uint64 {
	if m != nil {
		return m.ApplyingSnapCount
	}
	return 0
}

func (m *StoreStats) GetWrittenBytes() uint64 {
	if m != nil {
		return m.WrittenBytes
	}
	return 0
}

func (m *StoreStats) GetReadBytes() uint64 {
	if m != nil {
		return m.ReadBytes
	}
	return 0
}

func (m *StoreStats) GetWrittenKeys() uint64 {
	if m != nil {
		return m.WrittenKeys
	}
	return 0
}

func (m *StoreStats) GetReadKeys() uint64 {
	if m != nil {
		return m.ReadKeys
	}
	return 0
}

func (m *StoreStats) GetCpuUsages() []RecordPair {
	if m != nil {
		return m.CpuUsages
	}
	return nil
}

func (m *StoreStats) GetReadIORates() []RecordPair {
	if m != nil {
		return m.ReadIORates
	}
	return nil
}

func (m *StoreStats) GetWriteIORates() []RecordPair {
	if m != nil {
		return m.WriteIORates
	}
	return nil
}

func (m *StoreStats) GetOpLatencies() []RecordPair {
	if m != nil {
		return m.OpLatencies
	}
	return nil
}

// RecordPair record pair
type RecordPair struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                uint64   `protobuf:"varint,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RecordPair) Reset()         { *m = RecordPair{} }
func (m *RecordPair) String() string { return proto.CompactTextString(m) }
func (*RecordPair) ProtoMessage()    {}
func (*RecordPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{6}
}
func (m *RecordPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecordPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecordPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecordPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecordPair.Merge(m, src)
}
func (m *RecordPair) XXX_Size() int {
	return m.Size()
}
func (m *RecordPair) XXX_DiscardUnknown() {
	xxx_messageInfo_RecordPair.DiscardUnknown(m)
}

var xxx_messageInfo_RecordPair proto.InternalMessageInfo

func (m *RecordPair) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *RecordPair) GetValue() uint64 {
	if m != nil {
		return m.Value
	}
	return 0
}

// Member prophet member
type Member struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Name                 string   `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Addr                 string   `protobuf:"bytes,3,opt,name=addr,proto3" json:"addr,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Member) Reset()         { *m = Member{} }
func (m *Member) String() string { return proto.CompactTextString(m) }
func (*Member) ProtoMessage()    {}
func (*Member) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{7}
}
func (m *Member) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Member) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Member.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Member) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Member.Merge(m, src)
}
func (m *Member) XXX_Size() int {
	return m.Size()
}
func (m *Member) XXX_DiscardUnknown() {
	xxx_messageInfo_Member.DiscardUnknown(m)
}

var xxx_messageInfo_Member proto.InternalMessageInfo

func (m *Member) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Member) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Member) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

// ProphetCluster prophet cluster
type ProphetCluster struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	MaxReplicaCount      uint32   `protobuf:"varint,2,opt,name=maxReplicaCount,proto3" json:"maxReplicaCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ProphetCluster) Reset()         { *m = ProphetCluster{} }
func (m *ProphetCluster) String() string { return proto.CompactTextString(m) }
func (*ProphetCluster) ProtoMessage()    {}
func (*ProphetCluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{8}
}
func (m *ProphetCluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProphetCluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProphetCluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProphetCluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProphetCluster.Merge(m, src)
}
func (m *ProphetCluster) XXX_Size() int {
	return m.Size()
}
func (m *ProphetCluster) XXX_DiscardUnknown() {
	xxx_messageInfo_ProphetCluster.DiscardUnknown(m)
}

var xxx_messageInfo_ProphetCluster proto.InternalMessageInfo

func (m *ProphetCluster) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ProphetCluster) GetMaxReplicaCount() uint32 {
	if m != nil {
		return m.MaxReplicaCount
	}
	return 0
}

// TimeInterval time interval
type TimeInterval struct {
	// The unix timestamp in seconds of the start of this period.
	Start uint64 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	// The unix timestamp in seconds of the end of this period.
	End                  uint64   `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TimeInterval) Reset()         { *m = TimeInterval{} }
func (m *TimeInterval) String() string { return proto.CompactTextString(m) }
func (*TimeInterval) ProtoMessage()    {}
func (*TimeInterval) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{9}
}
func (m *TimeInterval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimeInterval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimeInterval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimeInterval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimeInterval.Merge(m, src)
}
func (m *TimeInterval) XXX_Size() int {
	return m.Size()
}
func (m *TimeInterval) XXX_DiscardUnknown() {
	xxx_messageInfo_TimeInterval.DiscardUnknown(m)
}

var xxx_messageInfo_TimeInterval proto.InternalMessageInfo

func (m *TimeInterval) GetStart() uint64 {
	if m != nil {
		return m.Start
	}
	return 0
}

func (m *TimeInterval) GetEnd() uint64 {
	if m != nil {
		return m.End
	}
	return 0
}

// Job job
type Job struct {
	Type                 JobType  `protobuf:"varint,1,opt,name=type,proto3,enum=metapb.JobType" json:"type,omitempty"`
	Content              []byte   `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
	State                JobState `protobuf:"varint,3,opt,name=state,proto3,enum=metapb.JobState" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Job) Reset()         { *m = Job{} }
func (m *Job) String() string { return proto.CompactTextString(m) }
func (*Job) ProtoMessage()    {}
func (*Job) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{10}
}
func (m *Job) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Job) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Job.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Job) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Job.Merge(m, src)
}
func (m *Job) XXX_Size() int {
	return m.Size()
}
func (m *Job) XXX_DiscardUnknown() {
	xxx_messageInfo_Job.DiscardUnknown(m)
}

var xxx_messageInfo_Job proto.InternalMessageInfo

func (m *Job) GetType() JobType {
	if m != nil {
		return m.Type
	}
	return JobType_RemoveShard
}

func (m *Job) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *Job) GetState() JobState {
	if m != nil {
		return m.State
	}
	return JobState_Created
}

// RemoveShardJob remove shards job
type RemoveShardJob struct {
	ID                   uint64    `protobuf:"varint,1,opt,name=shardID,proto3" json:"shardID,omitempty"`
	Replicas             []Replica `protobuf:"bytes,2,rep,name=replicas,proto3" json:"replicas"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *RemoveShardJob) Reset()         { *m = RemoveShardJob{} }
func (m *RemoveShardJob) String() string { return proto.CompactTextString(m) }
func (*RemoveShardJob) ProtoMessage()    {}
func (*RemoveShardJob) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{11}
}
func (m *RemoveShardJob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveShardJob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveShardJob.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveShardJob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveShardJob.Merge(m, src)
}
func (m *RemoveShardJob) XXX_Size() int {
	return m.Size()
}
func (m *RemoveShardJob) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveShardJob.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveShardJob proto.InternalMessageInfo

func (m *RemoveShardJob) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *RemoveShardJob) GetReplicas() []Replica {
	if m != nil {
		return m.Replicas
	}
	return nil
}

// ShardPoolJob shard pool job
type ShardPoolJob struct {
	Pools                []ShardPoolJobMeta `protobuf:"bytes,1,rep,name=pools,proto3" json:"pools"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ShardPoolJob) Reset()         { *m = ShardPoolJob{} }
func (m *ShardPoolJob) String() string { return proto.CompactTextString(m) }
func (*ShardPoolJob) ProtoMessage()    {}
func (*ShardPoolJob) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{12}
}
func (m *ShardPoolJob) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardPoolJob) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardPoolJob.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardPoolJob) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardPoolJob.Merge(m, src)
}
func (m *ShardPoolJob) XXX_Size() int {
	return m.Size()
}
func (m *ShardPoolJob) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardPoolJob.DiscardUnknown(m)
}

var xxx_messageInfo_ShardPoolJob proto.InternalMessageInfo

func (m *ShardPoolJob) GetPools() []ShardPoolJobMeta {
	if m != nil {
		return m.Pools
	}
	return nil
}

// ShardPoolJobMeta shard pool
type ShardPoolJobMeta struct {
	Group                uint64   `protobuf:"varint,1,opt,name=group,proto3" json:"group,omitempty"`
	Capacity             uint64   `protobuf:"varint,2,opt,name=capacity,proto3" json:"capacity,omitempty"`
	RangePrefix          []byte   `protobuf:"bytes,3,opt,name=rangePrefix,proto3" json:"rangePrefix,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShardPoolJobMeta) Reset()         { *m = ShardPoolJobMeta{} }
func (m *ShardPoolJobMeta) String() string { return proto.CompactTextString(m) }
func (*ShardPoolJobMeta) ProtoMessage()    {}
func (*ShardPoolJobMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{13}
}
func (m *ShardPoolJobMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardPoolJobMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardPoolJobMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardPoolJobMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardPoolJobMeta.Merge(m, src)
}
func (m *ShardPoolJobMeta) XXX_Size() int {
	return m.Size()
}
func (m *ShardPoolJobMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardPoolJobMeta.DiscardUnknown(m)
}

var xxx_messageInfo_ShardPoolJobMeta proto.InternalMessageInfo

func (m *ShardPoolJobMeta) GetGroup() uint64 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *ShardPoolJobMeta) GetCapacity() uint64 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

func (m *ShardPoolJobMeta) GetRangePrefix() []byte {
	if m != nil {
		return m.RangePrefix
	}
	return nil
}

// DestroyingStatus destroying status
type DestroyingStatus struct {
	Index                uint64          `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Replicas             map[uint64]bool `protobuf:"bytes,2,rep,name=replicas,proto3" json:"replicas,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"varint,2,opt,name=value,proto3"`
	State                ShardState      `protobuf:"varint,3,opt,name=state,proto3,enum=metapb.ShardState" json:"state,omitempty"`
	RemoveData           bool            `protobuf:"varint,4,opt,name=removeData,proto3" json:"removeData,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *DestroyingStatus) Reset()         { *m = DestroyingStatus{} }
func (m *DestroyingStatus) String() string { return proto.CompactTextString(m) }
func (*DestroyingStatus) ProtoMessage()    {}
func (*DestroyingStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{14}
}
func (m *DestroyingStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DestroyingStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DestroyingStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DestroyingStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DestroyingStatus.Merge(m, src)
}
func (m *DestroyingStatus) XXX_Size() int {
	return m.Size()
}
func (m *DestroyingStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_DestroyingStatus.DiscardUnknown(m)
}

var xxx_messageInfo_DestroyingStatus proto.InternalMessageInfo

func (m *DestroyingStatus) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *DestroyingStatus) GetReplicas() map[uint64]bool {
	if m != nil {
		return m.Replicas
	}
	return nil
}

func (m *DestroyingStatus) GetState() ShardState {
	if m != nil {
		return m.State
	}
	return ShardState_Running
}

func (m *DestroyingStatus) GetRemoveData() bool {
	if m != nil {
		return m.RemoveData
	}
	return false
}

// ShardExtra shard extra
type ShardExtra struct {
	Labels               map[string]string `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	DestroyingStatus     *DestroyingStatus `protobuf:"bytes,2,opt,name=destroyingStatus,proto3" json:"destroyingStatus,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ShardExtra) Reset()         { *m = ShardExtra{} }
func (m *ShardExtra) String() string { return proto.CompactTextString(m) }
func (*ShardExtra) ProtoMessage()    {}
func (*ShardExtra) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{15}
}
func (m *ShardExtra) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardExtra) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardExtra.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardExtra) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardExtra.Merge(m, src)
}
func (m *ShardExtra) XXX_Size() int {
	return m.Size()
}
func (m *ShardExtra) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardExtra.DiscardUnknown(m)
}

var xxx_messageInfo_ShardExtra proto.InternalMessageInfo

func (m *ShardExtra) GetLabels() map[string]string {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *ShardExtra) GetDestroyingStatus() *DestroyingStatus {
	if m != nil {
		return m.DestroyingStatus
	}
	return nil
}

// ScheduleGroupRule resoruce group rule
type ScheduleGroupRule struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	GroupID              uint64   `protobuf:"varint,2,opt,name=groupID,proto3" json:"groupID,omitempty"`
	Name                 string   `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	GroupByLabel         string   `protobuf:"bytes,4,opt,name=groupByLabel,proto3" json:"groupByLabel,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ScheduleGroupRule) Reset()         { *m = ScheduleGroupRule{} }
func (m *ScheduleGroupRule) String() string { return proto.CompactTextString(m) }
func (*ScheduleGroupRule) ProtoMessage()    {}
func (*ScheduleGroupRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{16}
}
func (m *ScheduleGroupRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ScheduleGroupRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ScheduleGroupRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ScheduleGroupRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ScheduleGroupRule.Merge(m, src)
}
func (m *ScheduleGroupRule) XXX_Size() int {
	return m.Size()
}
func (m *ScheduleGroupRule) XXX_DiscardUnknown() {
	xxx_messageInfo_ScheduleGroupRule.DiscardUnknown(m)
}

var xxx_messageInfo_ScheduleGroupRule proto.InternalMessageInfo

func (m *ScheduleGroupRule) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ScheduleGroupRule) GetGroupID() uint64 {
	if m != nil {
		return m.GroupID
	}
	return 0
}

func (m *ScheduleGroupRule) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ScheduleGroupRule) GetGroupByLabel() string {
	if m != nil {
		return m.GroupByLabel
	}
	return ""
}

// RaftMessageBatch is a group of messages sent to the same store.
type RaftMessageBatch struct {
	Messages             []RaftMessage `protobuf:"bytes,1,rep,name=messages,proto3" json:"messages"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *RaftMessageBatch) Reset()         { *m = RaftMessageBatch{} }
func (m *RaftMessageBatch) String() string { return proto.CompactTextString(m) }
func (*RaftMessageBatch) ProtoMessage()    {}
func (*RaftMessageBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{17}
}
func (m *RaftMessageBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftMessageBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftMessageBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftMessageBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftMessageBatch.Merge(m, src)
}
func (m *RaftMessageBatch) XXX_Size() int {
	return m.Size()
}
func (m *RaftMessageBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftMessageBatch.DiscardUnknown(m)
}

var xxx_messageInfo_RaftMessageBatch proto.InternalMessageInfo

func (m *RaftMessageBatch) GetMessages() []RaftMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

// RaftMessage the message wrapped raft msg with shard info
type RaftMessage struct {
	ShardID              uint64         `protobuf:"varint,1,opt,name=shardID,proto3" json:"shardID,omitempty"`
	Group                uint64         `protobuf:"varint,2,opt,name=group,proto3" json:"group,omitempty"`
	From                 Replica        `protobuf:"bytes,3,opt,name=from,proto3" json:"from"`
	To                   Replica        `protobuf:"bytes,4,opt,name=to,proto3" json:"to"`
	Message              raftpb.Message `protobuf:"bytes,5,opt,name=message,proto3" json:"message"`
	ShardEpoch           ShardEpoch     `protobuf:"bytes,6,opt,name=shardEpoch,proto3" json:"shardEpoch"`
	IsTombstone          bool           `protobuf:"varint,7,opt,name=isTombstone,proto3" json:"isTombstone,omitempty"`
	Start                []byte         `protobuf:"bytes,8,opt,name=start,proto3" json:"start,omitempty"`
	End                  []byte         `protobuf:"bytes,9,opt,name=end,proto3" json:"end,omitempty"`
	Unique               string         `protobuf:"bytes,10,opt,name=unique,proto3" json:"unique,omitempty"`
	RuleGroups           []string       `protobuf:"bytes,11,rep,name=ruleGroups,proto3" json:"ruleGroups,omitempty"`
	CommitIndex          uint64         `protobuf:"varint,12,opt,name=commitIndex,proto3" json:"commitIndex,omitempty"`
	SendTime             uint64         `protobuf:"varint,13,opt,name=sendTime,proto3" json:"sendTime,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *RaftMessage) Reset()         { *m = RaftMessage{} }
func (m *RaftMessage) String() string { return proto.CompactTextString(m) }
func (*RaftMessage) ProtoMessage()    {}
func (*RaftMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{18}
}
func (m *RaftMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftMessage.Merge(m, src)
}
func (m *RaftMessage) XXX_Size() int {
	return m.Size()
}
func (m *RaftMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftMessage.DiscardUnknown(m)
}

var xxx_messageInfo_RaftMessage proto.InternalMessageInfo

func (m *RaftMessage) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *RaftMessage) GetGroup() uint64 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *RaftMessage) GetFrom() Replica {
	if m != nil {
		return m.From
	}
	return Replica{}
}

func (m *RaftMessage) GetTo() Replica {
	if m != nil {
		return m.To
	}
	return Replica{}
}

func (m *RaftMessage) GetMessage() raftpb.Message {
	if m != nil {
		return m.Message
	}
	return raftpb.Message{}
}

func (m *RaftMessage) GetShardEpoch() ShardEpoch {
	if m != nil {
		return m.ShardEpoch
	}
	return ShardEpoch{}
}

func (m *RaftMessage) GetIsTombstone() bool {
	if m != nil {
		return m.IsTombstone
	}
	return false
}

func (m *RaftMessage) GetStart() []byte {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *RaftMessage) GetEnd() []byte {
	if m != nil {
		return m.End
	}
	return nil
}

func (m *RaftMessage) GetUnique() string {
	if m != nil {
		return m.Unique
	}
	return ""
}

func (m *RaftMessage) GetRuleGroups() []string {
	if m != nil {
		return m.RuleGroups
	}
	return nil
}

func (m *RaftMessage) GetCommitIndex() uint64 {
	if m != nil {
		return m.CommitIndex
	}
	return 0
}

func (m *RaftMessage) GetSendTime() uint64 {
	if m != nil {
		return m.SendTime
	}
	return 0
}

type SnapshotChunk struct {
	StoreID              uint64           `protobuf:"varint,1,opt,name=storeID,proto3" json:"storeID,omitempty"`
	ShardID              uint64           `protobuf:"varint,2,opt,name=shardID,proto3" json:"shardID,omitempty"`
	ReplicaID            uint64           `protobuf:"varint,3,opt,name=replicaID,proto3" json:"replicaID,omitempty"`
	From                 uint64           `protobuf:"varint,4,opt,name=from,proto3" json:"from,omitempty"`
	ChunkID              uint64           `protobuf:"varint,5,opt,name=chunkID,proto3" json:"chunkID,omitempty"`
	ChunkSize            uint64           `protobuf:"varint,6,opt,name=chunkSize,proto3" json:"chunkSize,omitempty"`
	ChunkCount           uint64           `protobuf:"varint,7,opt,name=chunkCount,proto3" json:"chunkCount,omitempty"`
	Index                uint64           `protobuf:"varint,8,opt,name=index,proto3" json:"index,omitempty"`
	Term                 uint64           `protobuf:"varint,9,opt,name=term,proto3" json:"term,omitempty"`
	FilePath             string           `protobuf:"bytes,10,opt,name=filePath,proto3" json:"filePath,omitempty"`
	FileSize             uint64           `protobuf:"varint,11,opt,name=fileSize,proto3" json:"fileSize,omitempty"`
	FileChunkID          uint64           `protobuf:"varint,12,opt,name=fileChunkID,proto3" json:"fileChunkID,omitempty"`
	FileChunkCount       uint64           `protobuf:"varint,13,opt,name=fileChunkCount,proto3" json:"fileChunkCount,omitempty"`
	Data                 []byte           `protobuf:"bytes,14,opt,name=data,proto3" json:"data,omitempty"`
	Extra                []byte           `protobuf:"bytes,15,opt,name=extra,proto3" json:"extra,omitempty"`
	ConfState            raftpb.ConfState `protobuf:"bytes,16,opt,name=confState,proto3" json:"confState"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SnapshotChunk) Reset()         { *m = SnapshotChunk{} }
func (m *SnapshotChunk) String() string { return proto.CompactTextString(m) }
func (*SnapshotChunk) ProtoMessage()    {}
func (*SnapshotChunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{19}
}
func (m *SnapshotChunk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotChunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotChunk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotChunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotChunk.Merge(m, src)
}
func (m *SnapshotChunk) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotChunk) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotChunk.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotChunk proto.InternalMessageInfo

func (m *SnapshotChunk) GetStoreID() uint64 {
	if m != nil {
		return m.StoreID
	}
	return 0
}

func (m *SnapshotChunk) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *SnapshotChunk) GetReplicaID() uint64 {
	if m != nil {
		return m.ReplicaID
	}
	return 0
}

func (m *SnapshotChunk) GetFrom() uint64 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *SnapshotChunk) GetChunkID() uint64 {
	if m != nil {
		return m.ChunkID
	}
	return 0
}

func (m *SnapshotChunk) GetChunkSize() uint64 {
	if m != nil {
		return m.ChunkSize
	}
	return 0
}

func (m *SnapshotChunk) GetChunkCount() uint64 {
	if m != nil {
		return m.ChunkCount
	}
	return 0
}

func (m *SnapshotChunk) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *SnapshotChunk) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *SnapshotChunk) GetFilePath() string {
	if m != nil {
		return m.FilePath
	}
	return ""
}

func (m *SnapshotChunk) GetFileSize() uint64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *SnapshotChunk) GetFileChunkID() uint64 {
	if m != nil {
		return m.FileChunkID
	}
	return 0
}

func (m *SnapshotChunk) GetFileChunkCount() uint64 {
	if m != nil {
		return m.FileChunkCount
	}
	return 0
}

func (m *SnapshotChunk) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *SnapshotChunk) GetExtra() []byte {
	if m != nil {
		return m.Extra
	}
	return nil
}

func (m *SnapshotChunk) GetConfState() raftpb.ConfState {
	if m != nil {
		return m.ConfState
	}
	return raftpb.ConfState{}
}

// StoreIdent store ident
type StoreIdent struct {
	ClusterID            uint64   `protobuf:"varint,1,opt,name=clusterID,proto3" json:"clusterID,omitempty"`
	StoreID              uint64   `protobuf:"varint,2,opt,name=storeID,proto3" json:"storeID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StoreIdent) Reset()         { *m = StoreIdent{} }
func (m *StoreIdent) String() string { return proto.CompactTextString(m) }
func (*StoreIdent) ProtoMessage()    {}
func (*StoreIdent) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{20}
}
func (m *StoreIdent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreIdent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreIdent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreIdent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreIdent.Merge(m, src)
}
func (m *StoreIdent) XXX_Size() int {
	return m.Size()
}
func (m *StoreIdent) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreIdent.DiscardUnknown(m)
}

var xxx_messageInfo_StoreIdent proto.InternalMessageInfo

func (m *StoreIdent) GetClusterID() uint64 {
	if m != nil {
		return m.ClusterID
	}
	return 0
}

func (m *StoreIdent) GetStoreID() uint64 {
	if m != nil {
		return m.StoreID
	}
	return 0
}

// Shard a shard [start,end) of the data
type Shard struct {
	ID                   uint64     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Start                []byte     `protobuf:"bytes,2,opt,name=start,proto3" json:"start,omitempty"`
	End                  []byte     `protobuf:"bytes,3,opt,name=end,proto3" json:"end,omitempty"`
	Epoch                ShardEpoch `protobuf:"bytes,4,opt,name=epoch,proto3" json:"epoch"`
	State                ShardState `protobuf:"varint,5,opt,name=state,proto3,enum=metapb.ShardState" json:"state,omitempty"`
	Replicas             []Replica  `protobuf:"bytes,6,rep,name=replicas,proto3" json:"replicas"`
	Group                uint64     `protobuf:"varint,7,opt,name=group,proto3" json:"group,omitempty"`
	Unique               string     `protobuf:"bytes,8,opt,name=unique,proto3" json:"unique,omitempty"`
	RuleGroups           []string   `protobuf:"bytes,9,rep,name=ruleGroups,proto3" json:"ruleGroups,omitempty"`
	Labels               []Label    `protobuf:"bytes,10,rep,name=labels,proto3" json:"labels"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Shard) Reset()         { *m = Shard{} }
func (m *Shard) String() string { return proto.CompactTextString(m) }
func (*Shard) ProtoMessage()    {}
func (*Shard) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{21}
}
func (m *Shard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Shard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Shard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Shard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Shard.Merge(m, src)
}
func (m *Shard) XXX_Size() int {
	return m.Size()
}
func (m *Shard) XXX_DiscardUnknown() {
	xxx_messageInfo_Shard.DiscardUnknown(m)
}

var xxx_messageInfo_Shard proto.InternalMessageInfo

func (m *Shard) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Shard) GetStart() []byte {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *Shard) GetEnd() []byte {
	if m != nil {
		return m.End
	}
	return nil
}

func (m *Shard) GetEpoch() ShardEpoch {
	if m != nil {
		return m.Epoch
	}
	return ShardEpoch{}
}

func (m *Shard) GetState() ShardState {
	if m != nil {
		return m.State
	}
	return ShardState_Running
}

func (m *Shard) GetReplicas() []Replica {
	if m != nil {
		return m.Replicas
	}
	return nil
}

func (m *Shard) GetGroup() uint64 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *Shard) GetUnique() string {
	if m != nil {
		return m.Unique
	}
	return ""
}

func (m *Shard) GetRuleGroups() []string {
	if m != nil {
		return m.RuleGroups
	}
	return nil
}

func (m *Shard) GetLabels() []Label {
	if m != nil {
		return m.Labels
	}
	return nil
}

// LogIndex is used to indicate a position in the log.
type LogIndex struct {
	Index                uint64   `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Term                 uint64   `protobuf:"varint,2,opt,name=term,proto3" json:"term,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LogIndex) Reset()         { *m = LogIndex{} }
func (m *LogIndex) String() string { return proto.CompactTextString(m) }
func (*LogIndex) ProtoMessage()    {}
func (*LogIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{22}
}
func (m *LogIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogIndex.Merge(m, src)
}
func (m *LogIndex) XXX_Size() int {
	return m.Size()
}
func (m *LogIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_LogIndex.DiscardUnknown(m)
}

var xxx_messageInfo_LogIndex proto.InternalMessageInfo

func (m *LogIndex) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *LogIndex) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

// ShardMetadata is the metadata of the shard consistent with the current table
// shard data
type ShardMetadata struct {
	ShardID              uint64          `protobuf:"varint,1,opt,name=shardID,proto3" json:"shardID,omitempty"`
	LogIndex             uint64          `protobuf:"varint,2,opt,name=logIndex,proto3" json:"logIndex,omitempty"`
	Metadata             ShardLocalState `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *ShardMetadata) Reset()         { *m = ShardMetadata{} }
func (m *ShardMetadata) String() string { return proto.CompactTextString(m) }
func (*ShardMetadata) ProtoMessage()    {}
func (*ShardMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{23}
}
func (m *ShardMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardMetadata.Merge(m, src)
}
func (m *ShardMetadata) XXX_Size() int {
	return m.Size()
}
func (m *ShardMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_ShardMetadata proto.InternalMessageInfo

func (m *ShardMetadata) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *ShardMetadata) GetLogIndex() uint64 {
	if m != nil {
		return m.LogIndex
	}
	return 0
}

func (m *ShardMetadata) GetMetadata() ShardLocalState {
	if m != nil {
		return m.Metadata
	}
	return ShardLocalState{}
}

// ShardLocalState shard local state
type ShardLocalState struct {
	Shard Shard        `protobuf:"bytes,1,opt,name=shard,proto3" json:"shard"`
	State ReplicaState `protobuf:"varint,2,opt,name=state,proto3,enum=metapb.ReplicaState" json:"state,omitempty"`
	// RemoveData Whether or not the local Shard data needs to be deleted,
	// which needs to be specified when the Shard status is set to Destroying
	RemoveData           bool     `protobuf:"varint,3,opt,name=removeData,proto3" json:"removeData,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShardLocalState) Reset()         { *m = ShardLocalState{} }
func (m *ShardLocalState) String() string { return proto.CompactTextString(m) }
func (*ShardLocalState) ProtoMessage()    {}
func (*ShardLocalState) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{24}
}
func (m *ShardLocalState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardLocalState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardLocalState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardLocalState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardLocalState.Merge(m, src)
}
func (m *ShardLocalState) XXX_Size() int {
	return m.Size()
}
func (m *ShardLocalState) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardLocalState.DiscardUnknown(m)
}

var xxx_messageInfo_ShardLocalState proto.InternalMessageInfo

func (m *ShardLocalState) GetShard() Shard {
	if m != nil {
		return m.Shard
	}
	return Shard{}
}

func (m *ShardLocalState) GetState() ReplicaState {
	if m != nil {
		return m.State
	}
	return ReplicaState_Normal
}

func (m *ShardLocalState) GetRemoveData() bool {
	if m != nil {
		return m.RemoveData
	}
	return false
}

// Store the host store metadata
type Store struct {
	ID                   uint64     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	RaftAddress          string     `protobuf:"bytes,2,opt,name=raftAddress,proto3" json:"raftAddress,omitempty"`
	ClientAddress        string     `protobuf:"bytes,3,opt,name=clientAddress,proto3" json:"clientAddress,omitempty"`
	Labels               []Label    `protobuf:"bytes,4,rep,name=labels,proto3" json:"labels"`
	State                StoreState `protobuf:"varint,5,opt,name=state,proto3,enum=metapb.StoreState" json:"state,omitempty"`
	StartTime            int64      `protobuf:"varint,6,opt,name=startTime,proto3" json:"startTime,omitempty"`
	LastHeartbeatTime    int64      `protobuf:"varint,7,opt,name=lastHeartbeatTime,proto3" json:"lastHeartbeatTime,omitempty"`
	Version              string     `protobuf:"bytes,8,opt,name=version,proto3" json:"version,omitempty"`
	CommitID             string     `protobuf:"bytes,9,opt,name=commitID,proto3" json:"commitID,omitempty"`
	DeployPath           string     `protobuf:"bytes,10,opt,name=deployPath,proto3" json:"deployPath,omitempty"`
	Destroyed            bool       `protobuf:"varint,11,opt,name=destroyed,proto3" json:"destroyed,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Store) Reset()         { *m = Store{} }
func (m *Store) String() string { return proto.CompactTextString(m) }
func (*Store) ProtoMessage()    {}
func (*Store) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{25}
}
func (m *Store) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Store) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Store.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Store) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Store.Merge(m, src)
}
func (m *Store) XXX_Size() int {
	return m.Size()
}
func (m *Store) XXX_DiscardUnknown() {
	xxx_messageInfo_Store.DiscardUnknown(m)
}

var xxx_messageInfo_Store proto.InternalMessageInfo

func (m *Store) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Store) GetRaftAddress() string {
	if m != nil {
		return m.RaftAddress
	}
	return ""
}

func (m *Store) GetClientAddress() string {
	if m != nil {
		return m.ClientAddress
	}
	return ""
}

func (m *Store) GetLabels() []Label {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *Store) GetState() StoreState {
	if m != nil {
		return m.State
	}
	return StoreState_Up
}

func (m *Store) GetStartTime() int64 {
	if m != nil {
		return m.StartTime
	}
	return 0
}

func (m *Store) GetLastHeartbeatTime() int64 {
	if m != nil {
		return m.LastHeartbeatTime
	}
	return 0
}

func (m *Store) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Store) GetCommitID() string {
	if m != nil {
		return m.CommitID
	}
	return ""
}

func (m *Store) GetDeployPath() string {
	if m != nil {
		return m.DeployPath
	}
	return ""
}

func (m *Store) GetDestroyed() bool {
	if m != nil {
		return m.Destroyed
	}
	return false
}

// ShardsPool shards pool
type ShardsPool struct {
	Pools                map[uint64]*ShardPool `protobuf:"bytes,1,rep,name=pools,proto3" json:"pools,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ShardsPool) Reset()         { *m = ShardsPool{} }
func (m *ShardsPool) String() string { return proto.CompactTextString(m) }
func (*ShardsPool) ProtoMessage()    {}
func (*ShardsPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{26}
}
func (m *ShardsPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardsPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardsPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardsPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardsPool.Merge(m, src)
}
func (m *ShardsPool) XXX_Size() int {
	return m.Size()
}
func (m *ShardsPool) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardsPool.DiscardUnknown(m)
}

var xxx_messageInfo_ShardsPool proto.InternalMessageInfo

func (m *ShardsPool) GetPools() map[uint64]*ShardPool {
	if m != nil {
		return m.Pools
	}
	return nil
}

// ShardPool shard pool
type ShardPool struct {
	Capacity             uint64            `protobuf:"varint,1,opt,name=capacity,proto3" json:"capacity,omitempty"`
	RangePrefix          []byte            `protobuf:"bytes,2,opt,name=rangePrefix,proto3" json:"rangePrefix,omitempty"`
	AllocatedShards      []*AllocatedShard `protobuf:"bytes,3,rep,name=allocatedShards,proto3" json:"allocatedShards,omitempty"`
	Seq                  uint64            `protobuf:"varint,4,opt,name=seq,proto3" json:"seq,omitempty"`
	AllocatedOffset      uint64            `protobuf:"varint,5,opt,name=allocatedOffset,proto3" json:"allocatedOffset,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ShardPool) Reset()         { *m = ShardPool{} }
func (m *ShardPool) String() string { return proto.CompactTextString(m) }
func (*ShardPool) ProtoMessage()    {}
func (*ShardPool) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{27}
}
func (m *ShardPool) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardPool) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardPool.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardPool) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardPool.Merge(m, src)
}
func (m *ShardPool) XXX_Size() int {
	return m.Size()
}
func (m *ShardPool) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardPool.DiscardUnknown(m)
}

var xxx_messageInfo_ShardPool proto.InternalMessageInfo

func (m *ShardPool) GetCapacity() uint64 {
	if m != nil {
		return m.Capacity
	}
	return 0
}

func (m *ShardPool) GetRangePrefix() []byte {
	if m != nil {
		return m.RangePrefix
	}
	return nil
}

func (m *ShardPool) GetAllocatedShards() []*AllocatedShard {
	if m != nil {
		return m.AllocatedShards
	}
	return nil
}

func (m *ShardPool) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *ShardPool) GetAllocatedOffset() uint64 {
	if m != nil {
		return m.AllocatedOffset
	}
	return 0
}

// AllocatedShard allocated shard info
type AllocatedShard struct {
	ShardID              uint64   `protobuf:"varint,1,opt,name=shardID,proto3" json:"shardID,omitempty"`
	AllocatedAt          uint64   `protobuf:"varint,2,opt,name=allocatedAt,proto3" json:"allocatedAt,omitempty"`
	Purpose              []byte   `protobuf:"bytes,3,opt,name=purpose,proto3" json:"purpose,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AllocatedShard) Reset()         { *m = AllocatedShard{} }
func (m *AllocatedShard) String() string { return proto.CompactTextString(m) }
func (*AllocatedShard) ProtoMessage()    {}
func (*AllocatedShard) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{28}
}
func (m *AllocatedShard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocatedShard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllocatedShard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllocatedShard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocatedShard.Merge(m, src)
}
func (m *AllocatedShard) XXX_Size() int {
	return m.Size()
}
func (m *AllocatedShard) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocatedShard.DiscardUnknown(m)
}

var xxx_messageInfo_AllocatedShard proto.InternalMessageInfo

func (m *AllocatedShard) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *AllocatedShard) GetAllocatedAt() uint64 {
	if m != nil {
		return m.AllocatedAt
	}
	return 0
}

func (m *AllocatedShard) GetPurpose() []byte {
	if m != nil {
		return m.Purpose
	}
	return nil
}

// ShardsPoolCmd shards pool cmd
type ShardsPoolCmd struct {
	Type                 ShardsPoolCmdType    `protobuf:"varint,1,opt,name=type,proto3,enum=metapb.ShardsPoolCmdType" json:"type,omitempty"`
	Create               *ShardsPoolCreateCmd `protobuf:"bytes,2,opt,name=create,proto3" json:"create,omitempty"`
	Alloc                *ShardsPoolAllocCmd  `protobuf:"bytes,3,opt,name=alloc,proto3" json:"alloc,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *ShardsPoolCmd) Reset()         { *m = ShardsPoolCmd{} }
func (m *ShardsPoolCmd) String() string { return proto.CompactTextString(m) }
func (*ShardsPoolCmd) ProtoMessage()    {}
func (*ShardsPoolCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{29}
}
func (m *ShardsPoolCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardsPoolCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardsPoolCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardsPoolCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardsPoolCmd.Merge(m, src)
}
func (m *ShardsPoolCmd) XXX_Size() int {
	return m.Size()
}
func (m *ShardsPoolCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardsPoolCmd.DiscardUnknown(m)
}

var xxx_messageInfo_ShardsPoolCmd proto.InternalMessageInfo

func (m *ShardsPoolCmd) GetType() ShardsPoolCmdType {
	if m != nil {
		return m.Type
	}
	return ShardsPoolCmdType_CreateShard
}

func (m *ShardsPoolCmd) GetCreate() *ShardsPoolCreateCmd {
	if m != nil {
		return m.Create
	}
	return nil
}

func (m *ShardsPoolCmd) GetAlloc() *ShardsPoolAllocCmd {
	if m != nil {
		return m.Alloc
	}
	return nil
}

// ShardsPoolCreateCmd shards pool create cmd
type ShardsPoolCreateCmd struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShardsPoolCreateCmd) Reset()         { *m = ShardsPoolCreateCmd{} }
func (m *ShardsPoolCreateCmd) String() string { return proto.CompactTextString(m) }
func (*ShardsPoolCreateCmd) ProtoMessage()    {}
func (*ShardsPoolCreateCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{30}
}
func (m *ShardsPoolCreateCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardsPoolCreateCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardsPoolCreateCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardsPoolCreateCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardsPoolCreateCmd.Merge(m, src)
}
func (m *ShardsPoolCreateCmd) XXX_Size() int {
	return m.Size()
}
func (m *ShardsPoolCreateCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardsPoolCreateCmd.DiscardUnknown(m)
}

var xxx_messageInfo_ShardsPoolCreateCmd proto.InternalMessageInfo

// ShardsPoolAllocCmd shards pool create cmd
type ShardsPoolAllocCmd struct {
	Group                uint64   `protobuf:"varint,1,opt,name=group,proto3" json:"group,omitempty"`
	Purpose              []byte   `protobuf:"bytes,2,opt,name=purpose,proto3" json:"purpose,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShardsPoolAllocCmd) Reset()         { *m = ShardsPoolAllocCmd{} }
func (m *ShardsPoolAllocCmd) String() string { return proto.CompactTextString(m) }
func (*ShardsPoolAllocCmd) ProtoMessage()    {}
func (*ShardsPoolAllocCmd) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{31}
}
func (m *ShardsPoolAllocCmd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardsPoolAllocCmd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardsPoolAllocCmd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardsPoolAllocCmd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardsPoolAllocCmd.Merge(m, src)
}
func (m *ShardsPoolAllocCmd) XXX_Size() int {
	return m.Size()
}
func (m *ShardsPoolAllocCmd) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardsPoolAllocCmd.DiscardUnknown(m)
}

var xxx_messageInfo_ShardsPoolAllocCmd proto.InternalMessageInfo

func (m *ShardsPoolAllocCmd) GetGroup() uint64 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *ShardsPoolAllocCmd) GetPurpose() []byte {
	if m != nil {
		return m.Purpose
	}
	return nil
}

// SnapshotInfo contains additional information associated with a snapshot.
type SnapshotInfo struct {
	Extra                uint64   `protobuf:"varint,1,opt,name=extra,proto3" json:"extra,omitempty"`
	Dummy                bool     `protobuf:"varint,2,opt,name=dummy,proto3" json:"dummy,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SnapshotInfo) Reset()         { *m = SnapshotInfo{} }
func (m *SnapshotInfo) String() string { return proto.CompactTextString(m) }
func (*SnapshotInfo) ProtoMessage()    {}
func (*SnapshotInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_77b4d575d5a68dda, []int{32}
}
func (m *SnapshotInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotInfo.Merge(m, src)
}
func (m *SnapshotInfo) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotInfo proto.InternalMessageInfo

func (m *SnapshotInfo) GetExtra() uint64 {
	if m != nil {
		return m.Extra
	}
	return 0
}

func (m *SnapshotInfo) GetDummy() bool {
	if m != nil {
		return m.Dummy
	}
	return false
}

func init() {
	proto.RegisterEnum("metapb.ShardType", ShardType_name, ShardType_value)
	proto.RegisterEnum("metapb.StoreState", StoreState_name, StoreState_value)
	proto.RegisterEnum("metapb.ShardState", ShardState_name, ShardState_value)
	proto.RegisterEnum("metapb.ConfigChangeType", ConfigChangeType_name, ConfigChangeType_value)
	proto.RegisterEnum("metapb.ReplicaRole", ReplicaRole_name, ReplicaRole_value)
	proto.RegisterEnum("metapb.CheckPolicy", CheckPolicy_name, CheckPolicy_value)
	proto.RegisterEnum("metapb.OperatorStatus", OperatorStatus_name, OperatorStatus_value)
	proto.RegisterEnum("metapb.JobType", JobType_name, JobType_value)
	proto.RegisterEnum("metapb.JobState", JobState_name, JobState_value)
	proto.RegisterEnum("metapb.ReplicaState", ReplicaState_name, ReplicaState_value)
	proto.RegisterEnum("metapb.ShardsPoolCmdType", ShardsPoolCmdType_name, ShardsPoolCmdType_value)
	proto.RegisterType((*ShardEpoch)(nil), "metapb.ShardEpoch")
	proto.RegisterType((*Replica)(nil), "metapb.Replica")
	proto.RegisterType((*ReplicaStats)(nil), "metapb.ReplicaStats")
	proto.RegisterType((*Label)(nil), "metapb.Label")
	proto.RegisterType((*ShardStats)(nil), "metapb.ShardStats")
	proto.RegisterType((*StoreStats)(nil), "metapb.StoreStats")
	proto.RegisterType((*RecordPair)(nil), "metapb.RecordPair")
	proto.RegisterType((*Member)(nil), "metapb.Member")
	proto.RegisterType((*ProphetCluster)(nil), "metapb.ProphetCluster")
	proto.RegisterType((*TimeInterval)(nil), "metapb.TimeInterval")
	proto.RegisterType((*Job)(nil), "metapb.Job")
	proto.RegisterType((*RemoveShardJob)(nil), "metapb.RemoveShardJob")
	proto.RegisterType((*ShardPoolJob)(nil), "metapb.ShardPoolJob")
	proto.RegisterType((*ShardPoolJobMeta)(nil), "metapb.ShardPoolJobMeta")
	proto.RegisterType((*DestroyingStatus)(nil), "metapb.DestroyingStatus")
	proto.RegisterMapType((map[uint64]bool)(nil), "metapb.DestroyingStatus.ReplicasEntry")
	proto.RegisterType((*ShardExtra)(nil), "metapb.ShardExtra")
	proto.RegisterMapType((map[string]string)(nil), "metapb.ShardExtra.LabelsEntry")
	proto.RegisterType((*ScheduleGroupRule)(nil), "metapb.ScheduleGroupRule")
	proto.RegisterType((*RaftMessageBatch)(nil), "metapb.RaftMessageBatch")
	proto.RegisterType((*RaftMessage)(nil), "metapb.RaftMessage")
	proto.RegisterType((*SnapshotChunk)(nil), "metapb.SnapshotChunk")
	proto.RegisterType((*StoreIdent)(nil), "metapb.StoreIdent")
	proto.RegisterType((*Shard)(nil), "metapb.Shard")
	proto.RegisterType((*LogIndex)(nil), "metapb.LogIndex")
	proto.RegisterType((*ShardMetadata)(nil), "metapb.ShardMetadata")
	proto.RegisterType((*ShardLocalState)(nil), "metapb.ShardLocalState")
	proto.RegisterType((*Store)(nil), "metapb.Store")
	proto.RegisterType((*ShardsPool)(nil), "metapb.ShardsPool")
	proto.RegisterMapType((map[uint64]*ShardPool)(nil), "metapb.ShardsPool.PoolsEntry")
	proto.RegisterType((*ShardPool)(nil), "metapb.ShardPool")
	proto.RegisterType((*AllocatedShard)(nil), "metapb.AllocatedShard")
	proto.RegisterType((*ShardsPoolCmd)(nil), "metapb.ShardsPoolCmd")
	proto.RegisterType((*ShardsPoolCreateCmd)(nil), "metapb.ShardsPoolCreateCmd")
	proto.RegisterType((*ShardsPoolAllocCmd)(nil), "metapb.ShardsPoolAllocCmd")
	proto.RegisterType((*SnapshotInfo)(nil), "metapb.SnapshotInfo")
}

func init() { proto.RegisterFile("metapb.proto", fileDescriptor_77b4d575d5a68dda) }

var fileDescriptor_77b4d575d5a68dda = []byte{
	// 2416 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x59, 0x4f, 0x73, 0x23, 0x47,
	0x15, 0xf7, 0x8c, 0x64, 0x5b, 0x7a, 0xf2, 0x9f, 0x71, 0xef, 0x12, 0x84, 0x09, 0x1b, 0xd7, 0x10,
	0x12, 0x47, 0x24, 0x76, 0xd8, 0xdd, 0xa4, 0x92, 0x40, 0x51, 0xc8, 0x92, 0x49, 0x94, 0xf5, 0x7a,
	0x5d, 0x23, 0x3b, 0xc0, 0xb1, 0xa5, 0x69, 0xc9, 0x53, 0x3b, 0x33, 0x3d, 0x99, 0x69, 0x39, 0x2b,
	0xaa, 0xa8, 0xe2, 0x48, 0x71, 0xe0, 0x5b, 0x70, 0xe3, 0x13, 0x70, 0xa7, 0xc8, 0x8d, 0x9c, 0x39,
	0xa4, 0x60, 0xbf, 0x02, 0x57, 0x8a, 0xa2, 0xfa, 0x75, 0xcf, 0x4c, 0x8f, 0xe4, 0x3f, 0x7b, 0xb1,
	0xe6, 0xbd, 0x7e, 0xdd, 0xef, 0xf5, 0xfb, 0xd7, 0xbf, 0x6e, 0xc3, 0x46, 0xc4, 0x04, 0x4d, 0x46,
	0x07, 0x49, 0xca, 0x05, 0x27, 0x6b, 0x8a, 0xda, 0x7d, 0x6f, 0x1a, 0x88, 0xcb, 0xd9, 0xe8, 0x60,
	0xcc, 0xa3, 0xc3, 0x29, 0x9f, 0xf2, 0x43, 0x1c, 0x1e, 0xcd, 0x26, 0x48, 0x21, 0x81, 0x5f, 0x6a,
	0xda, 0xee, 0x3b, 0x53, 0x7e, 0xc0, 0xc4, 0xd8, 0x3f, 0x08, 0xf8, 0xa1, 0xfc, 0x3d, 0x4c, 0xe9,
	0x44, 0x1c, 0x5e, 0x3d, 0xc2, 0xdf, 0x64, 0x84, 0x3f, 0x4a, 0xd4, 0xfd, 0x1c, 0x60, 0x78, 0x49,
	0x53, 0xff, 0x38, 0xe1, 0xe3, 0x4b, 0xf2, 0x3a, 0x34, 0xc7, 0x3c, 0x9e, 0x04, 0xd3, 0x2f, 0x58,
	0xda, 0xb6, 0xf6, 0xac, 0xfd, 0xba, 0x57, 0x32, 0xc8, 0x03, 0x80, 0x29, 0x8b, 0x59, 0x4a, 0x45,
	0xc0, 0xe3, 0xb6, 0x8d, 0xc3, 0x06, 0xc7, 0xfd, 0xa3, 0x05, 0xeb, 0x1e, 0x4b, 0xc2, 0x60, 0x4c,
	0xc9, 0x6b, 0x60, 0x07, 0xbe, 0x5a, 0xe2, 0x68, 0xed, 0xe5, 0xb7, 0x6f, 0xd8, 0x83, 0xbe, 0x67,
	0x07, 0x3e, 0x69, 0xc3, 0x7a, 0x26, 0x78, 0xca, 0x06, 0x7d, 0xbd, 0x40, 0x4e, 0x92, 0xb7, 0xa1,
	0x9e, 0xf2, 0x90, 0xb5, 0x6b, 0x7b, 0xd6, 0xfe, 0xd6, 0xc3, 0x7b, 0x07, 0xda, 0x11, 0x7a, 0x41,
	0x8f, 0x87, 0xcc, 0x43, 0x01, 0xf2, 0x26, 0x6c, 0x06, 0x71, 0x20, 0x02, 0x1a, 0x3e, 0x65, 0xd1,
	0x88, 0xa5, 0xed, 0xfa, 0x9e, 0xb5, 0xdf, 0xf0, 0xaa, 0x4c, 0x97, 0xc2, 0x86, 0x9e, 0x3a, 0x14,
	0x54, 0x64, 0xe4, 0x10, 0xd6, 0x53, 0x45, 0xa3, 0x55, 0xad, 0x87, 0xdb, 0x0b, 0x1a, 0x8e, 0xea,
	0x5f, 0x7f, 0xfb, 0xc6, 0x8a, 0x97, 0x4b, 0x91, 0x3d, 0x68, 0xf9, 0xfc, 0xab, 0x78, 0xc8, 0xc6,
	0x3c, 0xf6, 0x33, 0x6d, 0xad, 0xc9, 0x72, 0x0f, 0x61, 0xf5, 0x84, 0x8e, 0x58, 0x48, 0x1c, 0xa8,
	0x3d, 0x67, 0x73, 0x5c, 0xb7, 0xe9, 0xc9, 0x4f, 0x72, 0x1f, 0x56, 0xaf, 0x68, 0x38, 0x63, 0x38,
	0xad, 0xe9, 0x29, 0xc2, 0xfd, 0x8b, 0xad, 0xbd, 0xad, 0x4c, 0x92, 0xbe, 0x90, 0xd4, 0xa0, 0xaf,
	0x7d, 0x9d, 0x93, 0xc4, 0x85, 0x8d, 0xaf, 0xd2, 0x40, 0x08, 0x16, 0x1f, 0xcd, 0x05, 0xcb, 0x95,
	0x57, 0x78, 0xd2, 0x3e, 0x4d, 0x3f, 0x61, 0xf3, 0x0c, 0xdd, 0x56, 0xf7, 0x4c, 0x96, 0x8c, 0x66,
	0xca, 0xa8, 0xaf, 0x96, 0xa8, 0xab, 0x68, 0x16, 0x0c, 0xb2, 0x0b, 0x0d, 0x49, 0xe0, 0xe4, 0x55,
	0x1c, 0x2c, 0x68, 0xb2, 0x0f, 0xdb, 0x34, 0x49, 0x52, 0xfe, 0x22, 0x88, 0xa8, 0x60, 0xc3, 0xe0,
	0xb7, 0xac, 0xbd, 0x86, 0x22, 0x8b, 0xec, 0x05, 0x49, 0x5c, 0x6c, 0x7d, 0x49, 0x12, 0xd7, 0x7c,
	0x1f, 0x1a, 0x41, 0x2c, 0x58, 0x7a, 0x45, 0xc3, 0x76, 0x03, 0x23, 0x70, 0x3f, 0x8f, 0xc0, 0x79,
	0x10, 0xb1, 0x81, 0x1e, 0xf3, 0x0a, 0x29, 0xf7, 0xbf, 0xab, 0x00, 0x43, 0x99, 0x1d, 0xa5, 0xbb,
	0x74, 0xea, 0x58, 0xd5, 0xd4, 0x79, 0x1d, 0x9a, 0x99, 0xa0, 0xa9, 0x90, 0xeb, 0x68, 0x5f, 0x95,
	0x8c, 0x8a, 0xe2, 0xda, 0xab, 0x28, 0x96, 0xae, 0x19, 0xd3, 0x84, 0x8e, 0x03, 0x31, 0xd7, 0x7e,
	0x2b, 0x68, 0xa9, 0x8b, 0x5e, 0xd1, 0x20, 0xa4, 0xa3, 0x90, 0x69, 0xbf, 0x95, 0x0c, 0x39, 0x73,
	0x96, 0x31, 0xdf, 0xf0, 0x58, 0x41, 0x93, 0xd7, 0x60, 0x2d, 0xc8, 0x8e, 0x66, 0xd9, 0x1c, 0x3d,
	0xd4, 0xf0, 0x34, 0x25, 0xcb, 0x0a, 0xe3, 0xde, 0xe3, 0xb3, 0x58, 0xa0, 0x6b, 0xea, 0x9e, 0xc1,
	0x21, 0x1d, 0x70, 0x32, 0x16, 0xfb, 0x41, 0x3c, 0x1d, 0xc6, 0x34, 0x51, 0x52, 0x4d, 0x94, 0x5a,
	0xe2, 0x93, 0x03, 0x20, 0x29, 0x1b, 0xb3, 0xe0, 0xaa, 0x22, 0x0d, 0x28, 0x7d, 0xcd, 0x08, 0x79,
	0x17, 0x76, 0x68, 0x92, 0x84, 0xf3, 0x8a, 0x78, 0x0b, 0xc5, 0x97, 0x07, 0x96, 0xd2, 0x72, 0xe3,
	0x9a, 0xb4, 0xac, 0x24, 0xdd, 0xe6, 0x62, 0xd2, 0x2d, 0x24, 0xed, 0xd6, 0x72, 0xd2, 0x9a, 0x69,
	0xb9, 0xbd, 0x90, 0x96, 0x1f, 0x42, 0x73, 0x9c, 0xcc, 0x2e, 0x32, 0x3a, 0x65, 0x59, 0xdb, 0xd9,
	0xab, 0xed, 0xb7, 0x1e, 0x92, 0xb2, 0x8a, 0xc7, 0x3c, 0xf5, 0xcf, 0x68, 0x90, 0xea, 0x42, 0x2e,
	0x45, 0xc9, 0x27, 0xd0, 0x92, 0x6b, 0x0c, 0x9e, 0x79, 0x54, 0x5a, 0xb5, 0x73, 0xc7, 0x4c, 0x53,
	0x98, 0xfc, 0x4c, 0xed, 0x99, 0xe5, 0x93, 0xc9, 0x1d, 0x93, 0x2b, 0xd2, 0x52, 0x33, 0x4f, 0x4e,
	0xa8, 0x60, 0xf1, 0x38, 0x60, 0x59, 0xfb, 0xde, 0x5d, 0x9a, 0x0d, 0x61, 0xf7, 0x31, 0x40, 0x29,
	0x70, 0x57, 0x8f, 0xa9, 0xe7, 0x3d, 0xe6, 0x33, 0x58, 0x53, 0x1d, 0xf0, 0xc6, 0x16, 0x4c, 0xa0,
	0x1e, 0xd3, 0x28, 0x6f, 0x4d, 0xf8, 0x2d, 0x79, 0xd4, 0xf7, 0x53, 0xac, 0x8f, 0xa6, 0x87, 0xdf,
	0xae, 0x07, 0x5b, 0x67, 0x29, 0x4f, 0x2e, 0x99, 0xe8, 0x85, 0xb3, 0x4c, 0xdc, 0xb2, 0xe2, 0x3e,
	0x6c, 0x47, 0xf4, 0x85, 0xee, 0xa3, 0x2a, 0x87, 0xe4, 0xe2, 0x9b, 0xde, 0x22, 0xdb, 0xfd, 0x10,
	0x36, 0xcc, 0x9a, 0x93, 0x7b, 0xc0, 0x42, 0xd5, 0x15, 0xad, 0x08, 0xb9, 0x57, 0x16, 0xfb, 0x7a,
	0x5f, 0xf2, 0xd3, 0x0d, 0xa1, 0xf6, 0x39, 0x1f, 0x91, 0x1f, 0x42, 0x5d, 0xcc, 0x13, 0x86, 0xd2,
	0x5b, 0x65, 0x07, 0xff, 0x9c, 0x8f, 0xce, 0xe7, 0x09, 0xf3, 0x70, 0x50, 0xf6, 0x89, 0x31, 0x8f,
	0x05, 0xd3, 0x56, 0x6c, 0x78, 0x39, 0x49, 0xde, 0x42, 0x6d, 0x22, 0x3f, 0x63, 0x1c, 0x63, 0xbe,
	0x6c, 0x31, 0xcc, 0x53, 0xc3, 0x2e, 0x83, 0x2d, 0x8f, 0x45, 0xfc, 0x8a, 0x61, 0xb3, 0x96, 0x8a,
	0xf7, 0x16, 0x5a, 0x75, 0xb1, 0xfd, 0xa2, 0x65, 0xff, 0x44, 0xe6, 0x2d, 0xee, 0x54, 0xb6, 0xeb,
	0xda, 0xcd, 0x07, 0x4c, 0x21, 0xe6, 0xf6, 0x61, 0x03, 0x15, 0x9c, 0x71, 0x1e, 0x4a, 0x25, 0x8f,
	0x61, 0x35, 0xe1, 0x3c, 0xcc, 0xda, 0x16, 0xce, 0x6f, 0xe7, 0xf3, 0x4d, 0xa1, 0xa7, 0x4c, 0xe4,
	0x0b, 0x29, 0x61, 0x77, 0x02, 0xce, 0xa2, 0x80, 0x74, 0xeb, 0x34, 0xe5, 0xb3, 0x24, 0x77, 0x2b,
	0x12, 0x95, 0xb6, 0x66, 0x2f, 0xb4, 0xb5, 0x3d, 0x68, 0xa5, 0x34, 0x9e, 0xb2, 0xb3, 0x94, 0x4d,
	0x82, 0x17, 0xe8, 0xa0, 0x0d, 0xcf, 0x64, 0xb9, 0xff, 0xb1, 0xc0, 0xe9, 0xb3, 0x4c, 0xa4, 0x1c,
	0x9b, 0x82, 0xa0, 0x62, 0x96, 0x49, 0x45, 0x41, 0xec, 0xb3, 0x17, 0xb9, 0x22, 0x24, 0xc8, 0xd1,
	0x92, 0x2f, 0xde, 0xca, 0xf7, 0xb2, 0xb8, 0x42, 0xee, 0x9c, 0xec, 0x38, 0x16, 0xe9, 0xbc, 0x74,
	0x0e, 0xd9, 0xaf, 0xc6, 0x8a, 0x54, 0x9c, 0x61, 0x46, 0x4b, 0xf6, 0xcf, 0x14, 0xa3, 0xd5, 0xa7,
	0x82, 0x6a, 0x30, 0x60, 0x70, 0x76, 0x7f, 0x0a, 0x9b, 0x15, 0x25, 0x66, 0x29, 0xd5, 0xaf, 0x29,
	0xa5, 0x86, 0x2e, 0xa5, 0x4f, 0xec, 0x8f, 0x2c, 0xf7, 0x6f, 0x56, 0x0e, 0x90, 0x5e, 0x88, 0x94,
	0x92, 0x0f, 0x61, 0x2d, 0x94, 0x47, 0x7e, 0x1e, 0xa3, 0x07, 0x15, 0xb3, 0x50, 0xe6, 0x00, 0x31,
	0x81, 0xde, 0x8f, 0x96, 0x26, 0x7d, 0x70, 0xfc, 0x85, 0x9d, 0xa3, 0x2e, 0x23, 0xca, 0x8b, 0x9e,
	0xf1, 0x96, 0x66, 0xec, 0x7e, 0x0c, 0x2d, 0x63, 0xf1, 0x57, 0x85, 0x1d, 0xb8, 0x8f, 0xdf, 0xc1,
	0xce, 0x70, 0x7c, 0xc9, 0xfc, 0x59, 0xc8, 0x3e, 0x95, 0xc9, 0xe0, 0xcd, 0x42, 0x76, 0x1b, 0x48,
	0xc3, 0x8c, 0x29, 0x41, 0x9a, 0x26, 0x8b, 0xde, 0x51, 0x33, 0x7a, 0x87, 0x0b, 0x1b, 0x38, 0x7c,
	0x34, 0x47, 0xe3, 0x30, 0x02, 0x4d, 0xaf, 0xc2, 0x73, 0x07, 0xe0, 0x78, 0x74, 0x22, 0x9e, 0xb2,
	0x4c, 0x76, 0xe4, 0x23, 0x2a, 0xc6, 0x97, 0xe4, 0x03, 0x68, 0x44, 0x8a, 0xce, 0xbd, 0x59, 0x82,
	0x3e, 0x43, 0x56, 0x57, 0x4d, 0x2e, 0xea, 0xfe, 0xb5, 0x06, 0x2d, 0x63, 0xfc, 0x16, 0x14, 0x55,
	0x54, 0x81, 0x6d, 0x56, 0xc1, 0x3b, 0x50, 0x9f, 0xa4, 0x3c, 0xd2, 0x50, 0xe0, 0x86, 0x22, 0x45,
	0x11, 0xf2, 0x23, 0xb0, 0x05, 0xc7, 0xfd, 0xdc, 0x28, 0x68, 0x0b, 0x2e, 0xa1, 0xa5, 0xb6, 0x0e,
	0x01, 0x81, 0x94, 0x55, 0x40, 0xfb, 0xa0, 0xba, 0x87, 0x5c, 0x8a, 0x7c, 0xa4, 0x4f, 0x7c, 0x04,
	0xdd, 0x88, 0x13, 0x5a, 0x0b, 0x09, 0x8e, 0x23, 0x7a, 0x9a, 0x21, 0x2b, 0xcb, 0x34, 0xc8, 0xce,
	0x79, 0x34, 0xca, 0x04, 0x8f, 0x99, 0x06, 0x12, 0x26, 0xab, 0xec, 0xa8, 0x0d, 0x2c, 0xe1, 0x6a,
	0x47, 0x6d, 0x22, 0x4f, 0x7e, 0x4a, 0x34, 0x32, 0x8b, 0x83, 0x2f, 0x67, 0x0c, 0xd1, 0x41, 0xd3,
	0xd3, 0x14, 0x56, 0x53, 0x9e, 0x24, 0x59, 0xbb, 0xb5, 0x57, 0xdb, 0x6f, 0x7a, 0x06, 0x47, 0x5a,
	0x30, 0xe6, 0x51, 0x14, 0x88, 0x01, 0xd6, 0xbd, 0x82, 0x00, 0x26, 0x4b, 0xb6, 0x19, 0x89, 0x4b,
	0x10, 0x8c, 0x29, 0x00, 0x50, 0xd0, 0xee, 0x3f, 0x6b, 0xb0, 0x29, 0xf1, 0x44, 0x76, 0xc9, 0x45,
	0xef, 0x72, 0x16, 0x3f, 0xbf, 0x05, 0xd5, 0x19, 0x81, 0xb5, 0xab, 0x81, 0x45, 0x8c, 0x81, 0x51,
	0x18, 0xf4, 0x35, 0xf0, 0x2d, 0x19, 0x32, 0x47, 0x31, 0xc0, 0x0a, 0xb9, 0xa9, 0x48, 0xca, 0x33,
	0x41, 0xaa, 0x1b, 0xf4, 0x35, 0x66, 0xcb, 0x49, 0xbc, 0xf2, 0xc8, 0x4f, 0x03, 0xb2, 0x95, 0x0c,
	0xe9, 0x0d, 0x24, 0xd4, 0xa1, 0xa6, 0x90, 0xad, 0xc1, 0x29, 0xfb, 0x5f, 0xc3, 0xec, 0x7f, 0x04,
	0xea, 0x82, 0xa5, 0x91, 0x46, 0x69, 0xf8, 0x2d, 0xbd, 0x32, 0x09, 0x42, 0x76, 0x46, 0xc5, 0xa5,
	0xf6, 0x78, 0x41, 0xe7, 0x63, 0x68, 0x82, 0x02, 0x5f, 0x05, 0x2d, 0xfd, 0x2d, 0xbf, 0x7b, 0xda,
	0x7a, 0xed, 0x6f, 0x83, 0x45, 0xde, 0x82, 0xad, 0x82, 0x54, 0x76, 0x2a, 0xaf, 0x2f, 0x70, 0xa5,
	0x55, 0xbe, 0xec, 0x90, 0x5b, 0x98, 0x04, 0xf8, 0x2d, 0xed, 0x67, 0xb2, 0x69, 0x21, 0xd4, 0xda,
	0xf0, 0x14, 0x41, 0x3e, 0x50, 0xd7, 0x40, 0xec, 0xb2, 0x6d, 0x07, 0xd3, 0x73, 0x27, 0x4f, 0xe9,
	0x5e, 0x3e, 0x50, 0xc0, 0xac, 0x9c, 0xe1, 0xf6, 0x35, 0x5c, 0x1f, 0xf8, 0xf2, 0xb0, 0x95, 0x8e,
	0x55, 0xb8, 0xa1, 0x08, 0x6d, 0xc9, 0xb8, 0xf9, 0x1e, 0xe8, 0xfe, 0xc3, 0x86, 0x55, 0xac, 0x81,
	0x1b, 0xdb, 0x53, 0x91, 0xe2, 0xf6, 0x35, 0x29, 0x5e, 0x2b, 0x53, 0xfc, 0x00, 0x56, 0x19, 0x56,
	0x58, 0xfd, 0x8e, 0x0a, 0x53, 0x62, 0xe5, 0x91, 0xb3, 0x7a, 0xd7, 0x91, 0x63, 0x1e, 0xf6, 0x6b,
	0xaf, 0x74, 0xd8, 0x97, 0xcd, 0x68, 0xdd, 0x6c, 0x46, 0x65, 0x15, 0x36, 0x6e, 0xa9, 0xc2, 0xe6,
	0x52, 0x15, 0xfe, 0xb8, 0x38, 0x87, 0x00, 0xd5, 0x6f, 0xe6, 0xea, 0xb1, 0xdd, 0x6a, 0xe5, 0x5a,
	0xc4, 0x7d, 0x0c, 0x8d, 0x13, 0x3e, 0x55, 0xc5, 0x79, 0xfd, 0x81, 0x9d, 0x27, 0xac, 0x5d, 0x26,
	0xac, 0xfb, 0x7b, 0x0b, 0x36, 0x71, 0xe7, 0x12, 0x51, 0x60, 0xb2, 0xdc, 0xdc, 0x69, 0x77, 0xa1,
	0x11, 0x6a, 0x0d, 0x39, 0xb2, 0xc8, 0x69, 0xf2, 0xb1, 0x6c, 0xf3, 0x6a, 0x05, 0xdd, 0x73, 0xbf,
	0x5b, 0x71, 0xec, 0x09, 0x1f, 0xd3, 0xd0, 0xcc, 0xa8, 0x42, 0xdc, 0xfd, 0x83, 0x05, 0xdb, 0x0b,
	0x32, 0xe4, 0x1d, 0x58, 0x45, 0xad, 0xfa, 0x16, 0xbf, 0x59, 0x59, 0x2b, 0x8f, 0x27, 0x4a, 0x90,
	0x4e, 0x1e, 0x4f, 0x1b, 0xe3, 0x79, 0x7f, 0x21, 0x44, 0xb7, 0x80, 0x88, 0xda, 0x22, 0x88, 0x70,
	0xff, 0x27, 0xb3, 0x52, 0x66, 0xe8, 0x8d, 0x59, 0x89, 0x08, 0x6a, 0x22, 0xba, 0xbe, 0x9f, 0xb2,
	0x2c, 0xd3, 0x27, 0xb0, 0xc9, 0x22, 0x6f, 0xc2, 0xe6, 0x38, 0x0c, 0x58, 0x5c, 0xc8, 0xa8, 0x53,
	0xb4, 0xca, 0x34, 0x42, 0x5b, 0xbf, 0x33, 0xb4, 0x37, 0xa7, 0x6c, 0x7e, 0x6d, 0x2e, 0x36, 0x58,
	0xb9, 0x23, 0xcb, 0x3e, 0x57, 0x33, 0xef, 0xc8, 0xef, 0xc2, 0x4e, 0x48, 0x33, 0xf1, 0x19, 0xa3,
	0xa9, 0x18, 0x31, 0xaa, 0xa4, 0xd6, 0x51, 0x6a, 0x79, 0x40, 0x26, 0xc2, 0x15, 0x4b, 0xb3, 0x80,
	0xc7, 0x3a, 0x6d, 0x73, 0x12, 0x21, 0xa6, 0x3a, 0x0a, 0xfa, 0xd8, 0xfd, 0x9a, 0x5e, 0x41, 0x4b,
	0x17, 0xfb, 0x2c, 0x09, 0xf9, 0xdc, 0xe8, 0x81, 0x06, 0x47, 0x5a, 0xa8, 0x11, 0x0f, 0xf3, 0xb1,
	0x0d, 0x36, 0xbc, 0x92, 0xe1, 0xfe, 0x29, 0x07, 0x62, 0x99, 0x04, 0xba, 0xe4, 0x51, 0x15, 0x2b,
	0xff, 0xa0, 0x92, 0x06, 0x28, 0x72, 0x20, 0xff, 0x68, 0x18, 0xa6, 0x64, 0x77, 0x9f, 0x00, 0x94,
	0xcc, 0x6b, 0x60, 0xe0, 0xdb, 0x26, 0x7c, 0x92, 0x3d, 0x6f, 0x11, 0x80, 0x9b, 0x88, 0xea, 0xef,
	0x16, 0x34, 0x8b, 0x81, 0x0a, 0xb6, 0xb6, 0x6e, 0xc7, 0xd6, 0xf6, 0x12, 0xb6, 0x26, 0xbf, 0x80,
	0x6d, 0x1a, 0x86, 0x7c, 0x4c, 0x05, 0xf3, 0xd5, 0x0e, 0xda, 0x35, 0xdc, 0xd7, 0x6b, 0xb9, 0x09,
	0xdd, 0xca, 0xb0, 0xb7, 0x28, 0x2e, 0x37, 0x93, 0xb1, 0x2f, 0xf5, 0x99, 0x27, 0x3f, 0xf1, 0x65,
	0x26, 0x17, 0x7a, 0x36, 0x99, 0x64, 0x4c, 0xe8, 0xa3, 0x6f, 0x91, 0xed, 0x4e, 0x60, 0xab, 0xba,
	0xfc, 0x2d, 0x95, 0xbe, 0x07, 0xad, 0x62, 0x7a, 0x57, 0xe4, 0xaf, 0x62, 0x06, 0x4b, 0xce, 0x4d,
	0x66, 0x69, 0xc2, 0x33, 0xa6, 0x7b, 0x71, 0x4e, 0xba, 0x7f, 0xce, 0x3b, 0x0a, 0xc6, 0xa7, 0x17,
	0xf9, 0xe4, 0xbd, 0xca, 0x7d, 0xee, 0x7b, 0xcb, 0x41, 0xec, 0x45, 0xbe, 0x71, 0xb3, 0x7b, 0x04,
	0x6b, 0xe3, 0x94, 0xe5, 0x15, 0xdd, 0x7a, 0xf8, 0xfd, 0x6b, 0x26, 0xe0, 0x78, 0x2f, 0xf2, 0x3d,
	0x2d, 0x4a, 0xde, 0x87, 0x55, 0x34, 0x4f, 0x37, 0x9f, 0xdd, 0xe5, 0x39, 0xb8, 0x79, 0x39, 0x45,
	0x09, 0xba, 0xdf, 0x81, 0x7b, 0xd7, 0x2c, 0xe8, 0xf6, 0x81, 0x2c, 0xcf, 0xb9, 0xe1, 0xaa, 0x65,
	0x38, 0xc1, 0xae, 0x3a, 0xe1, 0x13, 0xd8, 0xc8, 0x01, 0xd0, 0x20, 0x9e, 0xf0, 0xf2, 0x04, 0xd6,
	0xf3, 0xd5, 0x09, 0x7c, 0x1f, 0x56, 0xfd, 0x59, 0x14, 0xcd, 0xf3, 0x0b, 0x09, 0x12, 0x9d, 0x8e,
	0xce, 0x38, 0xe9, 0x12, 0xb2, 0x05, 0x70, 0xc2, 0xa8, 0xcf, 0xd2, 0x67, 0x71, 0x38, 0x77, 0x56,
	0xc8, 0x26, 0x34, 0xbb, 0x61, 0xa8, 0x2c, 0x74, 0xac, 0xce, 0x43, 0xe3, 0xed, 0x8c, 0x91, 0x35,
	0xb0, 0x2f, 0x12, 0x67, 0x85, 0x34, 0xa0, 0xde, 0xe7, 0x5f, 0xc5, 0x8e, 0x45, 0x08, 0x6c, 0xe1,
	0x78, 0x81, 0x1c, 0x1d, 0xbb, 0xf3, 0x4b, 0xe3, 0x79, 0x92, 0x91, 0x16, 0xac, 0x7b, 0xb3, 0x38,
	0x0e, 0xe2, 0xa9, 0xb3, 0x42, 0x36, 0xa0, 0x81, 0x9e, 0x90, 0x94, 0x25, 0x75, 0x97, 0xd7, 0x15,
	0xc7, 0x96, 0xba, 0xfb, 0x79, 0xa5, 0x3a, 0xb5, 0xce, 0x10, 0x9c, 0x1e, 0xbe, 0x1a, 0xf7, 0x2e,
	0x65, 0x92, 0xa3, 0xb9, 0x2d, 0x58, 0xef, 0xfa, 0xfe, 0x29, 0xf7, 0x99, 0xb3, 0x22, 0xe7, 0xab,
	0x0b, 0x36, 0xd2, 0xb8, 0xde, 0x45, 0xe2, 0x53, 0xa1, 0x68, 0x5b, 0x1a, 0xd7, 0xf5, 0xfd, 0x13,
	0x46, 0xd3, 0x98, 0xa5, 0xc8, 0xab, 0x75, 0x9e, 0x40, 0xcb, 0x78, 0x0b, 0x26, 0x4d, 0x58, 0xfd,
	0x82, 0x0b, 0x96, 0x3a, 0x2b, 0x72, 0x69, 0x2d, 0xea, 0x58, 0x64, 0x07, 0x36, 0x07, 0xf1, 0x98,
	0x47, 0x41, 0x3c, 0x55, 0xe3, 0xb6, 0x64, 0xf5, 0x59, 0xc4, 0x45, 0xc1, 0xaa, 0x75, 0x1e, 0x43,
	0xab, 0x77, 0xc9, 0xc6, 0xcf, 0xcf, 0x78, 0x18, 0x8c, 0xe7, 0xd2, 0x2d, 0xc3, 0x5e, 0xf7, 0xd4,
	0x59, 0x21, 0xdb, 0xd0, 0xea, 0x9e, 0x9d, 0x79, 0xcf, 0x7e, 0x3d, 0x78, 0xda, 0x3d, 0x3f, 0x76,
	0x2c, 0x02, 0xb0, 0x76, 0x31, 0x3c, 0x7e, 0x72, 0xfc, 0x1b, 0xc7, 0xee, 0x9c, 0xc1, 0xd6, 0xb3,
	0x84, 0xa5, 0x54, 0xf0, 0x54, 0xdf, 0x7f, 0x5b, 0xb0, 0x3e, 0xbc, 0xe8, 0xf5, 0x8e, 0x87, 0x43,
	0x65, 0xc7, 0xf9, 0xe0, 0xe9, 0xf1, 0xb3, 0x8b, 0x73, 0x35, 0xaf, 0xd7, 0x3d, 0xed, 0x1d, 0x9f,
	0x38, 0x36, 0x7a, 0xf2, 0xf8, 0xec, 0xa4, 0xdb, 0x3b, 0x76, 0x6a, 0x48, 0x5c, 0x9c, 0x9e, 0x0e,
	0x4e, 0x3f, 0x75, 0xea, 0x9d, 0x23, 0x58, 0xd7, 0x8f, 0x17, 0x52, 0xb3, 0xf1, 0xe8, 0xe0, 0xac,
	0x90, 0x7b, 0xb0, 0xad, 0x92, 0xaf, 0xe8, 0x32, 0x6a, 0x7b, 0xbd, 0x59, 0x26, 0x78, 0x34, 0x94,
	0xbd, 0xbb, 0x2b, 0x1c, 0xbf, 0xf3, 0x08, 0x1a, 0xf9, 0x03, 0x86, 0x5c, 0x5c, 0xcd, 0xf1, 0x95,
	0x3d, 0xbf, 0xe2, 0xe9, 0x73, 0x15, 0xb2, 0x4d, 0x68, 0xf6, 0x78, 0x94, 0x84, 0x4c, 0x8e, 0xd9,
	0x9d, 0x9f, 0x57, 0x9e, 0xc7, 0x99, 0x34, 0xf7, 0x94, 0xa7, 0x11, 0x0d, 0x55, 0xac, 0xbb, 0xfa,
	0xed, 0xcf, 0xb1, 0xc8, 0x7d, 0x70, 0xb4, 0xa4, 0x99, 0x2a, 0x8f, 0x61, 0x67, 0xa9, 0x4a, 0xe5,
	0x16, 0x0c, 0x8b, 0x55, 0x9c, 0xb1, 0x50, 0x14, 0x6d, 0x1d, 0x39, 0xdf, 0xfc, 0xfb, 0x81, 0xf5,
	0xf5, 0xcb, 0x07, 0xd6, 0x37, 0x2f, 0x1f, 0x58, 0xff, 0x7a, 0xf9, 0xc0, 0x1a, 0xad, 0xe1, 0xbf,
	0x21, 0x1e, 0xfd, 0x3f, 0x00, 0x00, 0xff, 0xff, 0x5b, 0xf3, 0x40, 0x81, 0xf8, 0x18, 0x00, 0x00,
}

func (m *ShardEpoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardEpoch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ConfigVer != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ConfigVer))
	}
	if m.Generation != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Generation))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Replica) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Replica) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
	}
	if m.StoreID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.StoreID))
	}
	if m.Role != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Role))
	}
	if m.InitialMember {
		dAtA[i] = 0x20
		i++
		if m.InitialMember {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ReplicaStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReplicaStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Replica.Size()))
	n1, err := m.Replica.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if m.DownSeconds != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.DownSeconds))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Label) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Label) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShardStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ShardID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ShardID))
	}
	if m.WrittenBytes != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.WrittenBytes))
	}
	if m.WrittenKeys != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.WrittenKeys))
	}
	if m.ReadBytes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ReadBytes))
	}
	if m.ReadKeys != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ReadKeys))
	}
	if m.ApproximateSize != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ApproximateSize))
	}
	if m.ApproximateKeys != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ApproximateKeys))
	}
	if m.Interval != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Interval.Size()))
		n2, err := m.Interval.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StoreStats) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreStats) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StoreID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.StoreID))
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.StartTime))
	}
	if m.Interval != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Interval.Size()))
		n3, err := m.Interval.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Capacity != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Capacity))
	}
	if m.Available != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Available))
	}
	if m.UsedSize != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.UsedSize))
	}
	if m.IsBusy {
		dAtA[i] = 0x38
		i++
		if m.IsBusy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.ShardCount != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ShardCount))
	}
	if m.SendingSnapCount != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.SendingSnapCount))
	}
	if m.ReceivingSnapCount != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ReceivingSnapCount))
	}
	if m.ApplyingSnapCount != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ApplyingSnapCount))
	}
	if m.WrittenBytes != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.WrittenBytes))
	}
	if m.ReadBytes != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ReadBytes))
	}
	if m.WrittenKeys != 0 {
		dAtA[i] = 0x70
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.WrittenKeys))
	}
	if m.ReadKeys != 0 {
		dAtA[i] = 0x78
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ReadKeys))
	}
	if len(m.CpuUsages) > 0 {
		for _, msg := range m.CpuUsages {
			dAtA[i] = 0x82
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ReadIORates) > 0 {
		for _, msg := range m.ReadIORates {
			dAtA[i] = 0x8a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.WriteIORates) > 0 {
		for _, msg := range m.WriteIORates {
			dAtA[i] = 0x92
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OpLatencies) > 0 {
		for _, msg := range m.OpLatencies {
			dAtA[i] = 0x9a
			i++
			dAtA[i] = 0x1
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RecordPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecordPair) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Value != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Member) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Member) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Addr) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Addr)))
		i += copy(dAtA[i:], m.Addr)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProphetCluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProphetCluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
	}
	if m.MaxReplicaCount != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.MaxReplicaCount))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TimeInterval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeInterval) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Start != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Start))
	}
	if m.End != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.End))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Job) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Job) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Type))
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if m.State != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RemoveShardJob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveShardJob) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
	}
	if len(m.Replicas) > 0 {
		for _, msg := range m.Replicas {
			dAtA[i] = 0x12
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShardPoolJob) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardPoolJob) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for _, msg := range m.Pools {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShardPoolJobMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardPoolJobMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Group != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Group))
	}
	if m.Capacity != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Capacity))
	}
	if len(m.RangePrefix) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.RangePrefix)))
		i += copy(dAtA[i:], m.RangePrefix)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DestroyingStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DestroyingStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Index))
	}
	if len(m.Replicas) > 0 {
		for k, _ := range m.Replicas {
			dAtA[i] = 0x12
			i++
			v := m.Replicas[k]
			mapSize := 1 + sovMetapb(uint64(k)) + 1 + 1
			i = encodeVarintMetapb(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if m.State != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.State))
	}
	if m.RemoveData {
		dAtA[i] = 0x20
		i++
		if m.RemoveData {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShardExtra) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardExtra) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0xa
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovMetapb(uint64(len(k))) + 1 + len(v) + sovMetapb(uint64(len(v)))
			i = encodeVarintMetapb(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if m.DestroyingStatus != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.DestroyingStatus.Size()))
		n4, err := m.DestroyingStatus.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ScheduleGroupRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ScheduleGroupRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
	}
	if m.GroupID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.GroupID))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.GroupByLabel) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.GroupByLabel)))
		i += copy(dAtA[i:], m.GroupByLabel)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RaftMessageBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftMessageBatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, msg := range m.Messages {
			dAtA[i] = 0xa
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RaftMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftMessage) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ShardID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ShardID))
	}
	if m.Group != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Group))
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.From.Size()))
	n5, err := m.From.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x22
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.To.Size()))
	n6, err := m.To.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x2a
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Message.Size()))
	n7, err := m.Message.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x32
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ShardEpoch.Size()))
	n8, err := m.ShardEpoch.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	if m.IsTombstone {
		dAtA[i] = 0x38
		i++
		if m.IsTombstone {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Start) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Start)))
		i += copy(dAtA[i:], m.Start)
	}
	if len(m.End) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.End)))
		i += copy(dAtA[i:], m.End)
	}
	if len(m.Unique) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Unique)))
		i += copy(dAtA[i:], m.Unique)
	}
	if len(m.RuleGroups) > 0 {
		for _, s := range m.RuleGroups {
			dAtA[i] = 0x5a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.CommitIndex != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.CommitIndex))
	}
	if m.SendTime != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.SendTime))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SnapshotChunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotChunk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StoreID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.StoreID))
	}
	if m.ShardID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ShardID))
	}
	if m.ReplicaID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ReplicaID))
	}
	if m.From != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.From))
	}
	if m.ChunkID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ChunkID))
	}
	if m.ChunkSize != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ChunkSize))
	}
	if m.ChunkCount != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ChunkCount))
	}
	if m.Index != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Index))
	}
	if m.Term != 0 {
		dAtA[i] = 0x48
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Term))
	}
	if len(m.FilePath) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.FilePath)))
		i += copy(dAtA[i:], m.FilePath)
	}
	if m.FileSize != 0 {
		dAtA[i] = 0x58
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.FileSize))
	}
	if m.FileChunkID != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.FileChunkID))
	}
	if m.FileChunkCount != 0 {
		dAtA[i] = 0x68
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.FileChunkCount))
	}
	if len(m.Data) > 0 {
		dAtA[i] = 0x72
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if len(m.Extra) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Extra)))
		i += copy(dAtA[i:], m.Extra)
	}
	dAtA[i] = 0x82
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.ConfState.Size()))
	n9, err := m.ConfState.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StoreIdent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreIdent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ClusterID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ClusterID))
	}
	if m.StoreID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.StoreID))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Shard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Shard) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
	}
	if len(m.Start) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Start)))
		i += copy(dAtA[i:], m.Start)
	}
	if len(m.End) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.End)))
		i += copy(dAtA[i:], m.End)
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Epoch.Size()))
	n10, err := m.Epoch.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	if m.State != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.State))
	}
	if len(m.Replicas) > 0 {
		for _, msg := range m.Replicas {
			dAtA[i] = 0x32
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Group != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Group))
	}
	if len(m.Unique) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Unique)))
		i += copy(dAtA[i:], m.Unique)
	}
	if len(m.RuleGroups) > 0 {
		for _, s := range m.RuleGroups {
			dAtA[i] = 0x4a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.Labels) > 0 {
		for _, msg := range m.Labels {
			dAtA[i] = 0x52
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LogIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogIndex) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Index))
	}
	if m.Term != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Term))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShardMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardMetadata) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ShardID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ShardID))
	}
	if m.LogIndex != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.LogIndex))
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Metadata.Size()))
	n11, err := m.Metadata.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShardLocalState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardLocalState) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintMetapb(dAtA, i, uint64(m.Shard.Size()))
	n12, err := m.Shard.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	if m.State != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.State))
	}
	if m.RemoveData {
		dAtA[i] = 0x18
		i++
		if m.RemoveData {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Store) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Store) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ID))
	}
	if len(m.RaftAddress) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.RaftAddress)))
		i += copy(dAtA[i:], m.RaftAddress)
	}
	if len(m.ClientAddress) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.ClientAddress)))
		i += copy(dAtA[i:], m.ClientAddress)
	}
	if len(m.Labels) > 0 {
		for _, msg := range m.Labels {
			dAtA[i] = 0x22
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.State != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.State))
	}
	if m.StartTime != 0 {
		dAtA[i] = 0x30
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.StartTime))
	}
	if m.LastHeartbeatTime != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.LastHeartbeatTime))
	}
	if len(m.Version) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Version)))
		i += copy(dAtA[i:], m.Version)
	}
	if len(m.CommitID) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.CommitID)))
		i += copy(dAtA[i:], m.CommitID)
	}
	if len(m.DeployPath) > 0 {
		dAtA[i] = 0x52
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.DeployPath)))
		i += copy(dAtA[i:], m.DeployPath)
	}
	if m.Destroyed {
		dAtA[i] = 0x58
		i++
		if m.Destroyed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShardsPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardsPool) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for k, _ := range m.Pools {
			dAtA[i] = 0xa
			i++
			v := m.Pools[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovMetapb(uint64(msgSize))
			}
			mapSize := 1 + sovMetapb(uint64(k)) + msgSize
			i = encodeVarintMetapb(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintMetapb(dAtA, i, uint64(v.Size()))
				n13, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n13
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShardPool) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardPool) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Capacity != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Capacity))
	}
	if len(m.RangePrefix) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.RangePrefix)))
		i += copy(dAtA[i:], m.RangePrefix)
	}
	if len(m.AllocatedShards) > 0 {
		for _, msg := range m.AllocatedShards {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintMetapb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Seq != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Seq))
	}
	if m.AllocatedOffset != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.AllocatedOffset))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AllocatedShard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocatedShard) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ShardID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.ShardID))
	}
	if m.AllocatedAt != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.AllocatedAt))
	}
	if len(m.Purpose) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Purpose)))
		i += copy(dAtA[i:], m.Purpose)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShardsPoolCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardsPoolCmd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Type))
	}
	if m.Create != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Create.Size()))
		n14, err := m.Create.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Alloc != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Alloc.Size()))
		n15, err := m.Alloc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShardsPoolCreateCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardsPoolCreateCmd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShardsPoolAllocCmd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardsPoolAllocCmd) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Group != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Group))
	}
	if len(m.Purpose) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(len(m.Purpose)))
		i += copy(dAtA[i:], m.Purpose)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SnapshotInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotInfo) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Extra != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintMetapb(dAtA, i, uint64(m.Extra))
	}
	if m.Dummy {
		dAtA[i] = 0x10
		i++
		if m.Dummy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintMetapb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ShardEpoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfigVer != 0 {
		n += 1 + sovMetapb(uint64(m.ConfigVer))
	}
	if m.Generation != 0 {
		n += 1 + sovMetapb(uint64(m.Generation))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Replica) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMetapb(uint64(m.ID))
	}
	if m.StoreID != 0 {
		n += 1 + sovMetapb(uint64(m.StoreID))
	}
	if m.Role != 0 {
		n += 1 + sovMetapb(uint64(m.Role))
	}
	if m.InitialMember {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReplicaStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Replica.Size()
	n += 1 + l + sovMetapb(uint64(l))
	if m.DownSeconds != 0 {
		n += 1 + sovMetapb(uint64(m.DownSeconds))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Label) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardID != 0 {
		n += 1 + sovMetapb(uint64(m.ShardID))
	}
	if m.WrittenBytes != 0 {
		n += 1 + sovMetapb(uint64(m.WrittenBytes))
	}
	if m.WrittenKeys != 0 {
		n += 1 + sovMetapb(uint64(m.WrittenKeys))
	}
	if m.ReadBytes != 0 {
		n += 1 + sovMetapb(uint64(m.ReadBytes))
	}
	if m.ReadKeys != 0 {
		n += 1 + sovMetapb(uint64(m.ReadKeys))
	}
	if m.ApproximateSize != 0 {
		n += 1 + sovMetapb(uint64(m.ApproximateSize))
	}
	if m.ApproximateKeys != 0 {
		n += 1 + sovMetapb(uint64(m.ApproximateKeys))
	}
	if m.Interval != nil {
		l = m.Interval.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StoreStats) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StoreID != 0 {
		n += 1 + sovMetapb(uint64(m.StoreID))
	}
	if m.StartTime != 0 {
		n += 1 + sovMetapb(uint64(m.StartTime))
	}
	if m.Interval != nil {
		l = m.Interval.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.Capacity != 0 {
		n += 1 + sovMetapb(uint64(m.Capacity))
	}
	if m.Available != 0 {
		n += 1 + sovMetapb(uint64(m.Available))
	}
	if m.UsedSize != 0 {
		n += 1 + sovMetapb(uint64(m.UsedSize))
	}
	if m.IsBusy {
		n += 2
	}
	if m.ShardCount != 0 {
		n += 1 + sovMetapb(uint64(m.ShardCount))
	}
	if m.SendingSnapCount != 0 {
		n += 1 + sovMetapb(uint64(m.SendingSnapCount))
	}
	if m.ReceivingSnapCount != 0 {
		n += 1 + sovMetapb(uint64(m.ReceivingSnapCount))
	}
	if m.ApplyingSnapCount != 0 {
		n += 1 + sovMetapb(uint64(m.ApplyingSnapCount))
	}
	if m.WrittenBytes != 0 {
		n += 1 + sovMetapb(uint64(m.WrittenBytes))
	}
	if m.ReadBytes != 0 {
		n += 1 + sovMetapb(uint64(m.ReadBytes))
	}
	if m.WrittenKeys != 0 {
		n += 1 + sovMetapb(uint64(m.WrittenKeys))
	}
	if m.ReadKeys != 0 {
		n += 1 + sovMetapb(uint64(m.ReadKeys))
	}
	if len(m.CpuUsages) > 0 {
		for _, e := range m.CpuUsages {
			l = e.Size()
			n += 2 + l + sovMetapb(uint64(l))
		}
	}
	if len(m.ReadIORates) > 0 {
		for _, e := range m.ReadIORates {
			l = e.Size()
			n += 2 + l + sovMetapb(uint64(l))
		}
	}
	if len(m.WriteIORates) > 0 {
		for _, e := range m.WriteIORates {
			l = e.Size()
			n += 2 + l + sovMetapb(uint64(l))
		}
	}
	if len(m.OpLatencies) > 0 {
		for _, e := range m.OpLatencies {
			l = e.Size()
			n += 2 + l + sovMetapb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RecordPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovMetapb(uint64(m.Value))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Member) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMetapb(uint64(m.ID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProphetCluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMetapb(uint64(m.ID))
	}
	if m.MaxReplicaCount != 0 {
		n += 1 + sovMetapb(uint64(m.MaxReplicaCount))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TimeInterval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovMetapb(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovMetapb(uint64(m.End))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Job) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMetapb(uint64(m.Type))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovMetapb(uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoveShardJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMetapb(uint64(m.ID))
	}
	if len(m.Replicas) > 0 {
		for _, e := range m.Replicas {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardPoolJob) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for _, e := range m.Pools {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardPoolJobMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Group != 0 {
		n += 1 + sovMetapb(uint64(m.Group))
	}
	if m.Capacity != 0 {
		n += 1 + sovMetapb(uint64(m.Capacity))
	}
	l = len(m.RangePrefix)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DestroyingStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovMetapb(uint64(m.Index))
	}
	if len(m.Replicas) > 0 {
		for k, v := range m.Replicas {
			_ = k
			_ = v
			mapEntrySize := 1 + sovMetapb(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovMetapb(uint64(mapEntrySize))
		}
	}
	if m.State != 0 {
		n += 1 + sovMetapb(uint64(m.State))
	}
	if m.RemoveData {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardExtra) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovMetapb(uint64(len(k))) + 1 + len(v) + sovMetapb(uint64(len(v)))
			n += mapEntrySize + 1 + sovMetapb(uint64(mapEntrySize))
		}
	}
	if m.DestroyingStatus != nil {
		l = m.DestroyingStatus.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ScheduleGroupRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMetapb(uint64(m.ID))
	}
	if m.GroupID != 0 {
		n += 1 + sovMetapb(uint64(m.GroupID))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.GroupByLabel)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftMessageBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Messages) > 0 {
		for _, e := range m.Messages {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RaftMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardID != 0 {
		n += 1 + sovMetapb(uint64(m.ShardID))
	}
	if m.Group != 0 {
		n += 1 + sovMetapb(uint64(m.Group))
	}
	l = m.From.Size()
	n += 1 + l + sovMetapb(uint64(l))
	l = m.To.Size()
	n += 1 + l + sovMetapb(uint64(l))
	l = m.Message.Size()
	n += 1 + l + sovMetapb(uint64(l))
	l = m.ShardEpoch.Size()
	n += 1 + l + sovMetapb(uint64(l))
	if m.IsTombstone {
		n += 2
	}
	l = len(m.Start)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.End)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.Unique)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if len(m.RuleGroups) > 0 {
		for _, s := range m.RuleGroups {
			l = len(s)
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.CommitIndex != 0 {
		n += 1 + sovMetapb(uint64(m.CommitIndex))
	}
	if m.SendTime != 0 {
		n += 1 + sovMetapb(uint64(m.SendTime))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SnapshotChunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StoreID != 0 {
		n += 1 + sovMetapb(uint64(m.StoreID))
	}
	if m.ShardID != 0 {
		n += 1 + sovMetapb(uint64(m.ShardID))
	}
	if m.ReplicaID != 0 {
		n += 1 + sovMetapb(uint64(m.ReplicaID))
	}
	if m.From != 0 {
		n += 1 + sovMetapb(uint64(m.From))
	}
	if m.ChunkID != 0 {
		n += 1 + sovMetapb(uint64(m.ChunkID))
	}
	if m.ChunkSize != 0 {
		n += 1 + sovMetapb(uint64(m.ChunkSize))
	}
	if m.ChunkCount != 0 {
		n += 1 + sovMetapb(uint64(m.ChunkCount))
	}
	if m.Index != 0 {
		n += 1 + sovMetapb(uint64(m.Index))
	}
	if m.Term != 0 {
		n += 1 + sovMetapb(uint64(m.Term))
	}
	l = len(m.FilePath)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.FileSize != 0 {
		n += 1 + sovMetapb(uint64(m.FileSize))
	}
	if m.FileChunkID != 0 {
		n += 1 + sovMetapb(uint64(m.FileChunkID))
	}
	if m.FileChunkCount != 0 {
		n += 1 + sovMetapb(uint64(m.FileChunkCount))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.Extra)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = m.ConfState.Size()
	n += 2 + l + sovMetapb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StoreIdent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ClusterID != 0 {
		n += 1 + sovMetapb(uint64(m.ClusterID))
	}
	if m.StoreID != 0 {
		n += 1 + sovMetapb(uint64(m.StoreID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Shard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMetapb(uint64(m.ID))
	}
	l = len(m.Start)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.End)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = m.Epoch.Size()
	n += 1 + l + sovMetapb(uint64(l))
	if m.State != 0 {
		n += 1 + sovMetapb(uint64(m.State))
	}
	if len(m.Replicas) > 0 {
		for _, e := range m.Replicas {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.Group != 0 {
		n += 1 + sovMetapb(uint64(m.Group))
	}
	l = len(m.Unique)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if len(m.RuleGroups) > 0 {
		for _, s := range m.RuleGroups {
			l = len(s)
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LogIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovMetapb(uint64(m.Index))
	}
	if m.Term != 0 {
		n += 1 + sovMetapb(uint64(m.Term))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardID != 0 {
		n += 1 + sovMetapb(uint64(m.ShardID))
	}
	if m.LogIndex != 0 {
		n += 1 + sovMetapb(uint64(m.LogIndex))
	}
	l = m.Metadata.Size()
	n += 1 + l + sovMetapb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardLocalState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Shard.Size()
	n += 1 + l + sovMetapb(uint64(l))
	if m.State != 0 {
		n += 1 + sovMetapb(uint64(m.State))
	}
	if m.RemoveData {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Store) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovMetapb(uint64(m.ID))
	}
	l = len(m.RaftAddress)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.ClientAddress)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.State != 0 {
		n += 1 + sovMetapb(uint64(m.State))
	}
	if m.StartTime != 0 {
		n += 1 + sovMetapb(uint64(m.StartTime))
	}
	if m.LastHeartbeatTime != 0 {
		n += 1 + sovMetapb(uint64(m.LastHeartbeatTime))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.CommitID)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	l = len(m.DeployPath)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.Destroyed {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardsPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Pools) > 0 {
		for k, v := range m.Pools {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovMetapb(uint64(l))
			}
			mapEntrySize := 1 + sovMetapb(uint64(k)) + l
			n += mapEntrySize + 1 + sovMetapb(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardPool) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Capacity != 0 {
		n += 1 + sovMetapb(uint64(m.Capacity))
	}
	l = len(m.RangePrefix)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if len(m.AllocatedShards) > 0 {
		for _, e := range m.AllocatedShards {
			l = e.Size()
			n += 1 + l + sovMetapb(uint64(l))
		}
	}
	if m.Seq != 0 {
		n += 1 + sovMetapb(uint64(m.Seq))
	}
	if m.AllocatedOffset != 0 {
		n += 1 + sovMetapb(uint64(m.AllocatedOffset))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllocatedShard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardID != 0 {
		n += 1 + sovMetapb(uint64(m.ShardID))
	}
	if m.AllocatedAt != 0 {
		n += 1 + sovMetapb(uint64(m.AllocatedAt))
	}
	l = len(m.Purpose)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardsPoolCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovMetapb(uint64(m.Type))
	}
	if m.Create != nil {
		l = m.Create.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.Alloc != nil {
		l = m.Alloc.Size()
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardsPoolCreateCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardsPoolAllocCmd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Group != 0 {
		n += 1 + sovMetapb(uint64(m.Group))
	}
	l = len(m.Purpose)
	if l > 0 {
		n += 1 + l + sovMetapb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SnapshotInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Extra != 0 {
		n += 1 + sovMetapb(uint64(m.Extra))
	}
	if m.Dummy {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovMetapb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozMetapb(x uint64) (n int) {
	return sovMetapb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ShardEpoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardEpoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardEpoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigVer", wireType)
			}
			m.ConfigVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigVer |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Generation", wireType)
			}
			m.Generation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Generation |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Replica) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Replica: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Replica: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= ReplicaRole(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialMember", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.InitialMember = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReplicaStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReplicaStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReplicaStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Replica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownSeconds", wireType)
			}
			m.DownSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownSeconds |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Label) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Label: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Label: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WrittenBytes", wireType)
			}
			m.WrittenBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WrittenBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WrittenKeys", wireType)
			}
			m.WrittenKeys = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WrittenKeys |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadBytes", wireType)
			}
			m.ReadBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadKeys", wireType)
			}
			m.ReadKeys = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadKeys |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproximateSize", wireType)
			}
			m.ApproximateSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApproximateSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApproximateKeys", wireType)
			}
			m.ApproximateKeys = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApproximateKeys |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interval == nil {
				m.Interval = &TimeInterval{}
			}
			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreStats) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreStats: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreStats: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interval == nil {
				m.Interval = &TimeInterval{}
			}
			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capacity", wireType)
			}
			m.Capacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Capacity |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Available", wireType)
			}
			m.Available = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Available |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UsedSize", wireType)
			}
			m.UsedSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UsedSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBusy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBusy = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardCount", wireType)
			}
			m.ShardCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendingSnapCount", wireType)
			}
			m.SendingSnapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendingSnapCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReceivingSnapCount", wireType)
			}
			m.ReceivingSnapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReceivingSnapCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApplyingSnapCount", wireType)
			}
			m.ApplyingSnapCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApplyingSnapCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WrittenBytes", wireType)
			}
			m.WrittenBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WrittenBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadBytes", wireType)
			}
			m.ReadBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WrittenKeys", wireType)
			}
			m.WrittenKeys = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WrittenKeys |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadKeys", wireType)
			}
			m.ReadKeys = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadKeys |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CpuUsages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CpuUsages = append(m.CpuUsages, RecordPair{})
			if err := m.CpuUsages[len(m.CpuUsages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadIORates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ReadIORates = append(m.ReadIORates, RecordPair{})
			if err := m.ReadIORates[len(m.ReadIORates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteIORates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WriteIORates = append(m.WriteIORates, RecordPair{})
			if err := m.WriteIORates[len(m.WriteIORates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpLatencies", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpLatencies = append(m.OpLatencies, RecordPair{})
			if err := m.OpLatencies[len(m.OpLatencies)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecordPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecordPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecordPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Member) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Member: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Member: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProphetCluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProphetCluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProphetCluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxReplicaCount", wireType)
			}
			m.MaxReplicaCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxReplicaCount |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeInterval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeInterval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeInterval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Job) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Job: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Job: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= JobType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= JobState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveShardJob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveShardJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveShardJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replicas = append(m.Replicas, Replica{})
			if err := m.Replicas[len(m.Replicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardPoolJob) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardPoolJob: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardPoolJob: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pools = append(m.Pools, ShardPoolJobMeta{})
			if err := m.Pools[len(m.Pools)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardPoolJobMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardPoolJobMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardPoolJobMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capacity", wireType)
			}
			m.Capacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Capacity |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangePrefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RangePrefix = append(m.RangePrefix[:0], dAtA[iNdEx:postIndex]...)
			if m.RangePrefix == nil {
				m.RangePrefix = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DestroyingStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DestroyingStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DestroyingStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Replicas == nil {
				m.Replicas = make(map[uint64]bool)
			}
			var mapkey uint64
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetapb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetapb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetapb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetapb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMetapb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Replicas[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ShardState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveData", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RemoveData = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardExtra) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardExtra: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardExtra: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetapb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetapb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthMetapb
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthMetapb
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetapb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthMetapb
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthMetapb
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetapb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMetapb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestroyingStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DestroyingStatus == nil {
				m.DestroyingStatus = &DestroyingStatus{}
			}
			if err := m.DestroyingStatus.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScheduleGroupRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScheduleGroupRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScheduleGroupRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			m.GroupID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GroupID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupByLabel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupByLabel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftMessageBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftMessageBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftMessageBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Messages", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Messages = append(m.Messages, RaftMessage{})
			if err := m.Messages[len(m.Messages)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.From.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.To.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Message.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ShardEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTombstone", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTombstone = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Start = append(m.Start[:0], dAtA[iNdEx:postIndex]...)
			if m.Start == nil {
				m.Start = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.End = append(m.End[:0], dAtA[iNdEx:postIndex]...)
			if m.End == nil {
				m.End = []byte{}
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unique", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unique = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleGroups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleGroups = append(m.RuleGroups, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitIndex", wireType)
			}
			m.CommitIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommitIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendTime", wireType)
			}
			m.SendTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotChunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotChunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotChunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaID", wireType)
			}
			m.ReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkID", wireType)
			}
			m.ChunkID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSize", wireType)
			}
			m.ChunkSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkCount", wireType)
			}
			m.ChunkCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FilePath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileChunkID", wireType)
			}
			m.FileChunkID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileChunkID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileChunkCount", wireType)
			}
			m.FileChunkCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileChunkCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extra", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extra = append(m.Extra[:0], dAtA[iNdEx:postIndex]...)
			if m.Extra == nil {
				m.Extra = []byte{}
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ConfState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreIdent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreIdent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreIdent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterID", wireType)
			}
			m.ClusterID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Shard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Shard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Shard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Start = append(m.Start[:0], dAtA[iNdEx:postIndex]...)
			if m.Start == nil {
				m.Start = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.End = append(m.End[:0], dAtA[iNdEx:postIndex]...)
			if m.End == nil {
				m.End = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Epoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ShardState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Replicas = append(m.Replicas, Replica{})
			if err := m.Replicas[len(m.Replicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Unique", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Unique = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuleGroups", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuleGroups = append(m.RuleGroups, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, Label{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogIndex", wireType)
			}
			m.LogIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardLocalState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardLocalState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardLocalState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= ReplicaState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveData", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RemoveData = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Store) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Store: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Store: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RaftAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RaftAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, Label{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= StoreState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartTime", wireType)
			}
			m.StartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StartTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeartbeatTime", wireType)
			}
			m.LastHeartbeatTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastHeartbeatTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeployPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeployPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destroyed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Destroyed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardsPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardsPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardsPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pools", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pools == nil {
				m.Pools = make(map[uint64]*ShardPool)
			}
			var mapkey uint64
			var mapvalue *ShardPool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowMetapb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetapb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowMetapb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthMetapb
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthMetapb
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &ShardPool{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipMetapb(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthMetapb
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Pools[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardPool) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardPool: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardPool: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Capacity", wireType)
			}
			m.Capacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Capacity |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RangePrefix", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RangePrefix = append(m.RangePrefix[:0], dAtA[iNdEx:postIndex]...)
			if m.RangePrefix == nil {
				m.RangePrefix = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocatedShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AllocatedShards = append(m.AllocatedShards, &AllocatedShard{})
			if err := m.AllocatedShards[len(m.AllocatedShards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocatedOffset", wireType)
			}
			m.AllocatedOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllocatedOffset |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocatedShard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocatedShard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocatedShard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocatedAt", wireType)
			}
			m.AllocatedAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AllocatedAt |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Purpose", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Purpose = append(m.Purpose[:0], dAtA[iNdEx:postIndex]...)
			if m.Purpose == nil {
				m.Purpose = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardsPoolCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardsPoolCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardsPoolCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ShardsPoolCmdType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Create", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Create == nil {
				m.Create = &ShardsPoolCreateCmd{}
			}
			if err := m.Create.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alloc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Alloc == nil {
				m.Alloc = &ShardsPoolAllocCmd{}
			}
			if err := m.Alloc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardsPoolCreateCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardsPoolCreateCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardsPoolCreateCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardsPoolAllocCmd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardsPoolAllocCmd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardsPoolAllocCmd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Purpose", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMetapb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMetapb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Purpose = append(m.Purpose[:0], dAtA[iNdEx:postIndex]...)
			if m.Purpose == nil {
				m.Purpose = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extra", wireType)
			}
			m.Extra = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Extra |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dummy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dummy = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipMetapb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthMetapb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMetapb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMetapb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMetapb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMetapb
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthMetapb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowMetapb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipMetapb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthMetapb
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthMetapb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMetapb   = fmt.Errorf("proto: integer overflow")
)
