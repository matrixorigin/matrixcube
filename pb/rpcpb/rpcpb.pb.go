// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rpcpb.proto

package rpcpb

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	errorpb "github.com/matrixorigin/matrixcube/pb/errorpb"
	metapb "github.com/matrixorigin/matrixcube/pb/metapb"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Type rpc type
type Type int32

const (
	TypeRegisterStore           Type = 0
	TypeShardHeartbeatReq       Type = 1
	TypeShardHeartbeatRsp       Type = 2
	TypeStoreHeartbeatReq       Type = 3
	TypeStoreHeartbeatRsp       Type = 4
	TypePutStoreReq             Type = 5
	TypePutStoreRsp             Type = 6
	TypeGetStoreReq             Type = 7
	TypeGetStoreRsp             Type = 8
	TypeAllocIDReq              Type = 9
	TypeAllocIDRsp              Type = 10
	TypeAskBatchSplitReq        Type = 11
	TypeAskBatchSplitRsp        Type = 12
	TypeCreateDestroyingReq     Type = 13
	TypeCreateDestroyingRsp     Type = 14
	TypeReportDestroyedReq      Type = 15
	TypeReportDestroyedRsp      Type = 16
	TypeGetDestroyingReq        Type = 17
	TypeGetDestroyingRsp        Type = 18
	TypeCreateWatcherReq        Type = 19
	TypeEventNotify             Type = 20
	TypeCreateShardsReq         Type = 21
	TypeCreateShardsRsp         Type = 22
	TypeRemoveShardsReq         Type = 23
	TypeRemoveShardsRsp         Type = 24
	TypeCheckShardStateReq      Type = 25
	TypeCheckShardStateRsp      Type = 26
	TypePutPlacementRuleReq     Type = 27
	TypePutPlacementRuleRsp     Type = 28
	TypeGetAppliedRulesReq      Type = 29
	TypeGetAppliedRulesRsp      Type = 30
	TypeCreateJobReq            Type = 31
	TypeCreateJobRsp            Type = 32
	TypeRemoveJobReq            Type = 33
	TypeRemoveJobRsp            Type = 34
	TypeExecuteJobReq           Type = 35
	TypeExecuteJobRsp           Type = 36
	TypeAddScheduleGroupRuleReq Type = 37
	TypeAddScheduleGroupRuleRsp Type = 38
	TypeGetScheduleGroupRuleReq Type = 39
	TypeGetScheduleGroupRuleRsp Type = 40
)

var Type_name = map[int32]string{
	0:  "TypeRegisterStore",
	1:  "TypeShardHeartbeatReq",
	2:  "TypeShardHeartbeatRsp",
	3:  "TypeStoreHeartbeatReq",
	4:  "TypeStoreHeartbeatRsp",
	5:  "TypePutStoreReq",
	6:  "TypePutStoreRsp",
	7:  "TypeGetStoreReq",
	8:  "TypeGetStoreRsp",
	9:  "TypeAllocIDReq",
	10: "TypeAllocIDRsp",
	11: "TypeAskBatchSplitReq",
	12: "TypeAskBatchSplitRsp",
	13: "TypeCreateDestroyingReq",
	14: "TypeCreateDestroyingRsp",
	15: "TypeReportDestroyedReq",
	16: "TypeReportDestroyedRsp",
	17: "TypeGetDestroyingReq",
	18: "TypeGetDestroyingRsp",
	19: "TypeCreateWatcherReq",
	20: "TypeEventNotify",
	21: "TypeCreateShardsReq",
	22: "TypeCreateShardsRsp",
	23: "TypeRemoveShardsReq",
	24: "TypeRemoveShardsRsp",
	25: "TypeCheckShardStateReq",
	26: "TypeCheckShardStateRsp",
	27: "TypePutPlacementRuleReq",
	28: "TypePutPlacementRuleRsp",
	29: "TypeGetAppliedRulesReq",
	30: "TypeGetAppliedRulesRsp",
	31: "TypeCreateJobReq",
	32: "TypeCreateJobRsp",
	33: "TypeRemoveJobReq",
	34: "TypeRemoveJobRsp",
	35: "TypeExecuteJobReq",
	36: "TypeExecuteJobRsp",
	37: "TypeAddScheduleGroupRuleReq",
	38: "TypeAddScheduleGroupRuleRsp",
	39: "TypeGetScheduleGroupRuleReq",
	40: "TypeGetScheduleGroupRuleRsp",
}

var Type_value = map[string]int32{
	"TypeRegisterStore":           0,
	"TypeShardHeartbeatReq":       1,
	"TypeShardHeartbeatRsp":       2,
	"TypeStoreHeartbeatReq":       3,
	"TypeStoreHeartbeatRsp":       4,
	"TypePutStoreReq":             5,
	"TypePutStoreRsp":             6,
	"TypeGetStoreReq":             7,
	"TypeGetStoreRsp":             8,
	"TypeAllocIDReq":              9,
	"TypeAllocIDRsp":              10,
	"TypeAskBatchSplitReq":        11,
	"TypeAskBatchSplitRsp":        12,
	"TypeCreateDestroyingReq":     13,
	"TypeCreateDestroyingRsp":     14,
	"TypeReportDestroyedReq":      15,
	"TypeReportDestroyedRsp":      16,
	"TypeGetDestroyingReq":        17,
	"TypeGetDestroyingRsp":        18,
	"TypeCreateWatcherReq":        19,
	"TypeEventNotify":             20,
	"TypeCreateShardsReq":         21,
	"TypeCreateShardsRsp":         22,
	"TypeRemoveShardsReq":         23,
	"TypeRemoveShardsRsp":         24,
	"TypeCheckShardStateReq":      25,
	"TypeCheckShardStateRsp":      26,
	"TypePutPlacementRuleReq":     27,
	"TypePutPlacementRuleRsp":     28,
	"TypeGetAppliedRulesReq":      29,
	"TypeGetAppliedRulesRsp":      30,
	"TypeCreateJobReq":            31,
	"TypeCreateJobRsp":            32,
	"TypeRemoveJobReq":            33,
	"TypeRemoveJobRsp":            34,
	"TypeExecuteJobReq":           35,
	"TypeExecuteJobRsp":           36,
	"TypeAddScheduleGroupRuleReq": 37,
	"TypeAddScheduleGroupRuleRsp": 38,
	"TypeGetScheduleGroupRuleReq": 39,
	"TypeGetScheduleGroupRuleRsp": 40,
}

func (x Type) String() string {
	return proto.EnumName(Type_name, int32(x))
}

func (Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{0}
}

// PeerRoleType is the expected peer type of the placement rule
type ReplicaRoleType int32

const (
	// Voter can either match a leader peer or follower peer
	Voter ReplicaRoleType = 0
	// Leader matches a leader.
	Leader ReplicaRoleType = 1
	// Follower matches a follower.
	Follower ReplicaRoleType = 2
	// Learner matches a learner.
	Learner ReplicaRoleType = 3
)

var ReplicaRoleType_name = map[int32]string{
	0: "Voter",
	1: "Leader",
	2: "Follower",
	3: "Learner",
}

var ReplicaRoleType_value = map[string]int32{
	"Voter":    0,
	"Leader":   1,
	"Follower": 2,
	"Learner":  3,
}

func (x ReplicaRoleType) String() string {
	return proto.EnumName(ReplicaRoleType_name, int32(x))
}

func (ReplicaRoleType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{1}
}

// LabelConstraintOp defines how a LabelConstraint matches a store. It can be one of
// 'in', 'notIn', 'exists', or 'notExists'.
type LabelConstraintOp int32

const (
	// In If label does not exist, `in` is always false.
	In LabelConstraintOp = 0
	// NotIn restricts the store label value should not in the value list.
	NotIn LabelConstraintOp = 1
	// Exists restricts the store should have the label.
	Exists LabelConstraintOp = 2
	// NotExists restricts the store should not have the label.
	NotExists LabelConstraintOp = 3
)

var LabelConstraintOp_name = map[int32]string{
	0: "In",
	1: "NotIn",
	2: "Exists",
	3: "NotExists",
}

var LabelConstraintOp_value = map[string]int32{
	"In":        0,
	"NotIn":     1,
	"Exists":    2,
	"NotExists": 3,
}

func (x LabelConstraintOp) String() string {
	return proto.EnumName(LabelConstraintOp_name, int32(x))
}

func (LabelConstraintOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{2}
}

type CmdType int32

const (
	Write CmdType = 0
	Read  CmdType = 1
	Admin CmdType = 2
)

var CmdType_name = map[int32]string{
	0: "Write",
	1: "Read",
	2: "Admin",
}

var CmdType_value = map[string]int32{
	"Write": 0,
	"Read":  1,
	"Admin": 2,
}

func (x CmdType) String() string {
	return proto.EnumName(CmdType_name, int32(x))
}

func (CmdType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{3}
}

// AdminCmdType admin cmd type
type AdminCmdType int32

const (
	AdminConfigChange   AdminCmdType = 0
	AdminCompactLog     AdminCmdType = 1
	AdminTransferLeader AdminCmdType = 2
	AdminBatchSplit     AdminCmdType = 5
	AdminUpdateMetadata AdminCmdType = 6
	AdminUpdateLabels   AdminCmdType = 7
)

var AdminCmdType_name = map[int32]string{
	0: "AdminConfigChange",
	1: "AdminCompactLog",
	2: "AdminTransferLeader",
	5: "AdminBatchSplit",
	6: "AdminUpdateMetadata",
	7: "AdminUpdateLabels",
}

var AdminCmdType_value = map[string]int32{
	"AdminConfigChange":   0,
	"AdminCompactLog":     1,
	"AdminTransferLeader": 2,
	"AdminBatchSplit":     5,
	"AdminUpdateMetadata": 6,
	"AdminUpdateLabels":   7,
}

func (x AdminCmdType) String() string {
	return proto.EnumName(AdminCmdType_name, int32(x))
}

func (AdminCmdType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{4}
}

// UpdatePolicy update policy
type UpdatePolicy int32

const (
	// Add add or update
	Add UpdatePolicy = 0
	// Remove remove
	Remove UpdatePolicy = 1
	// Reset reset
	Reset UpdatePolicy = 2
	// Clear clear
	Clear UpdatePolicy = 3
)

var UpdatePolicy_name = map[int32]string{
	0: "Add",
	1: "Remove",
	2: "Reset",
	3: "Clear",
}

var UpdatePolicy_value = map[string]int32{
	"Add":    0,
	"Remove": 1,
	"Reset":  2,
	"Clear":  3,
}

func (x UpdatePolicy) String() string {
	return proto.EnumName(UpdatePolicy_name, int32(x))
}

func (UpdatePolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{5}
}

// ProphetRequest the prophet rpc request
type ProphetRequest struct {
	ID                   uint64                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	StoreID              uint64                  `protobuf:"varint,2,opt,name=storeID,proto3" json:"storeID,omitempty"`
	Type                 Type                    `protobuf:"varint,3,opt,name=type,proto3,enum=rpcpb.Type" json:"type,omitempty"`
	ShardHeartbeat       ShardHeartbeatReq       `protobuf:"bytes,4,opt,name=shardHeartbeat,proto3" json:"shardHeartbeat"`
	StoreHeartbeat       StoreHeartbeatReq       `protobuf:"bytes,5,opt,name=storeHeartbeat,proto3" json:"storeHeartbeat"`
	PutStore             PutStoreReq             `protobuf:"bytes,6,opt,name=putStore,proto3" json:"putStore"`
	GetStore             GetStoreReq             `protobuf:"bytes,7,opt,name=getStore,proto3" json:"getStore"`
	AllocID              AllocIDReq              `protobuf:"bytes,8,opt,name=allocID,proto3" json:"allocID"`
	AskBatchSplit        AskBatchSplitReq        `protobuf:"bytes,9,opt,name=askBatchSplit,proto3" json:"askBatchSplit"`
	CreateDestroying     CreateDestroyingReq     `protobuf:"bytes,10,opt,name=createDestroying,proto3" json:"createDestroying"`
	ReportDestroyed      ReportDestroyedReq      `protobuf:"bytes,11,opt,name=ReportDestroyed,proto3" json:"ReportDestroyed"`
	GetDestroying        GetDestroyingReq        `protobuf:"bytes,12,opt,name=getDestroying,proto3" json:"getDestroying"`
	CreateWatcher        CreateWatcherReq        `protobuf:"bytes,13,opt,name=createWatcher,proto3" json:"createWatcher"`
	CreateShards         CreateShardsReq         `protobuf:"bytes,14,opt,name=createShards,proto3" json:"createShards"`
	RemoveShards         RemoveShardsReq         `protobuf:"bytes,15,opt,name=removeShards,proto3" json:"removeShards"`
	CheckShardState      CheckShardStateReq      `protobuf:"bytes,16,opt,name=checkShardState,proto3" json:"checkShardState"`
	PutPlacementRule     PutPlacementRuleReq     `protobuf:"bytes,17,opt,name=putPlacementRule,proto3" json:"putPlacementRule"`
	GetAppliedRules      GetAppliedRulesReq      `protobuf:"bytes,18,opt,name=getAppliedRules,proto3" json:"getAppliedRules"`
	CreateJob            CreateJobReq            `protobuf:"bytes,19,opt,name=createJob,proto3" json:"createJob"`
	RemoveJob            RemoveJobReq            `protobuf:"bytes,20,opt,name=removeJob,proto3" json:"removeJob"`
	ExecuteJob           ExecuteJobReq           `protobuf:"bytes,21,opt,name=executeJob,proto3" json:"executeJob"`
	AddScheduleGroupRule AddScheduleGroupRuleReq `protobuf:"bytes,22,opt,name=addScheduleGroupRule,proto3" json:"addScheduleGroupRule"`
	GetScheduleGroupRule GetScheduleGroupRuleReq `protobuf:"bytes,23,opt,name=getScheduleGroupRule,proto3" json:"getScheduleGroupRule"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *ProphetRequest) Reset()         { *m = ProphetRequest{} }
func (m *ProphetRequest) String() string { return proto.CompactTextString(m) }
func (*ProphetRequest) ProtoMessage()    {}
func (*ProphetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{0}
}
func (m *ProphetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProphetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProphetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProphetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProphetRequest.Merge(m, src)
}
func (m *ProphetRequest) XXX_Size() int {
	return m.Size()
}
func (m *ProphetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ProphetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ProphetRequest proto.InternalMessageInfo

func (m *ProphetRequest) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ProphetRequest) GetStoreID() uint64 {
	if m != nil {
		return m.StoreID
	}
	return 0
}

func (m *ProphetRequest) GetType() Type {
	if m != nil {
		return m.Type
	}
	return TypeRegisterStore
}

func (m *ProphetRequest) GetShardHeartbeat() ShardHeartbeatReq {
	if m != nil {
		return m.ShardHeartbeat
	}
	return ShardHeartbeatReq{}
}

func (m *ProphetRequest) GetStoreHeartbeat() StoreHeartbeatReq {
	if m != nil {
		return m.StoreHeartbeat
	}
	return StoreHeartbeatReq{}
}

func (m *ProphetRequest) GetPutStore() PutStoreReq {
	if m != nil {
		return m.PutStore
	}
	return PutStoreReq{}
}

func (m *ProphetRequest) GetGetStore() GetStoreReq {
	if m != nil {
		return m.GetStore
	}
	return GetStoreReq{}
}

func (m *ProphetRequest) GetAllocID() AllocIDReq {
	if m != nil {
		return m.AllocID
	}
	return AllocIDReq{}
}

func (m *ProphetRequest) GetAskBatchSplit() AskBatchSplitReq {
	if m != nil {
		return m.AskBatchSplit
	}
	return AskBatchSplitReq{}
}

func (m *ProphetRequest) GetCreateDestroying() CreateDestroyingReq {
	if m != nil {
		return m.CreateDestroying
	}
	return CreateDestroyingReq{}
}

func (m *ProphetRequest) GetReportDestroyed() ReportDestroyedReq {
	if m != nil {
		return m.ReportDestroyed
	}
	return ReportDestroyedReq{}
}

func (m *ProphetRequest) GetGetDestroying() GetDestroyingReq {
	if m != nil {
		return m.GetDestroying
	}
	return GetDestroyingReq{}
}

func (m *ProphetRequest) GetCreateWatcher() CreateWatcherReq {
	if m != nil {
		return m.CreateWatcher
	}
	return CreateWatcherReq{}
}

func (m *ProphetRequest) GetCreateShards() CreateShardsReq {
	if m != nil {
		return m.CreateShards
	}
	return CreateShardsReq{}
}

func (m *ProphetRequest) GetRemoveShards() RemoveShardsReq {
	if m != nil {
		return m.RemoveShards
	}
	return RemoveShardsReq{}
}

func (m *ProphetRequest) GetCheckShardState() CheckShardStateReq {
	if m != nil {
		return m.CheckShardState
	}
	return CheckShardStateReq{}
}

func (m *ProphetRequest) GetPutPlacementRule() PutPlacementRuleReq {
	if m != nil {
		return m.PutPlacementRule
	}
	return PutPlacementRuleReq{}
}

func (m *ProphetRequest) GetGetAppliedRules() GetAppliedRulesReq {
	if m != nil {
		return m.GetAppliedRules
	}
	return GetAppliedRulesReq{}
}

func (m *ProphetRequest) GetCreateJob() CreateJobReq {
	if m != nil {
		return m.CreateJob
	}
	return CreateJobReq{}
}

func (m *ProphetRequest) GetRemoveJob() RemoveJobReq {
	if m != nil {
		return m.RemoveJob
	}
	return RemoveJobReq{}
}

func (m *ProphetRequest) GetExecuteJob() ExecuteJobReq {
	if m != nil {
		return m.ExecuteJob
	}
	return ExecuteJobReq{}
}

func (m *ProphetRequest) GetAddScheduleGroupRule() AddScheduleGroupRuleReq {
	if m != nil {
		return m.AddScheduleGroupRule
	}
	return AddScheduleGroupRuleReq{}
}

func (m *ProphetRequest) GetGetScheduleGroupRule() GetScheduleGroupRuleReq {
	if m != nil {
		return m.GetScheduleGroupRule
	}
	return GetScheduleGroupRuleReq{}
}

// ProphetResponse the prophet rpc response
type ProphetResponse struct {
	ID                   uint64                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type                 Type                    `protobuf:"varint,2,opt,name=type,proto3,enum=rpcpb.Type" json:"type,omitempty"`
	Error                string                  `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	Leader               string                  `protobuf:"bytes,4,opt,name=leader,proto3" json:"leader,omitempty"`
	ShardHeartbeat       ShardHeartbeatRsp       `protobuf:"bytes,5,opt,name=shardHeartbeat,proto3" json:"shardHeartbeat"`
	StoreHeartbeat       StoreHeartbeatRsp       `protobuf:"bytes,6,opt,name=storeHeartbeat,proto3" json:"storeHeartbeat"`
	PutStore             PutStoreRsp             `protobuf:"bytes,7,opt,name=putStore,proto3" json:"putStore"`
	GetStore             GetStoreRsp             `protobuf:"bytes,8,opt,name=getStore,proto3" json:"getStore"`
	AllocID              AllocIDRsp              `protobuf:"bytes,9,opt,name=allocID,proto3" json:"allocID"`
	AskBatchSplit        AskBatchSplitRsp        `protobuf:"bytes,10,opt,name=askBatchSplit,proto3" json:"askBatchSplit"`
	CreateDestroying     CreateDestroyingRsp     `protobuf:"bytes,11,opt,name=createDestroying,proto3" json:"createDestroying"`
	ReportDestroyed      ReportDestroyedRsp      `protobuf:"bytes,12,opt,name=ReportDestroyed,proto3" json:"ReportDestroyed"`
	GetDestroying        GetDestroyingRsp        `protobuf:"bytes,13,opt,name=getDestroying,proto3" json:"getDestroying"`
	Event                EventNotify             `protobuf:"bytes,14,opt,name=event,proto3" json:"event"`
	CreateShards         CreateShardsRsp         `protobuf:"bytes,15,opt,name=createShards,proto3" json:"createShards"`
	RemoveShards         RemoveShardsRsp         `protobuf:"bytes,16,opt,name=removeShards,proto3" json:"removeShards"`
	CheckShardState      CheckShardStateRsp      `protobuf:"bytes,17,opt,name=checkShardState,proto3" json:"checkShardState"`
	PutPlacementRule     PutPlacementRuleRsp     `protobuf:"bytes,18,opt,name=putPlacementRule,proto3" json:"putPlacementRule"`
	GetAppliedRules      GetAppliedRulesRsp      `protobuf:"bytes,19,opt,name=getAppliedRules,proto3" json:"getAppliedRules"`
	CreateJob            CreateJobRsp            `protobuf:"bytes,20,opt,name=createJob,proto3" json:"createJob"`
	RemoveJob            RemoveJobRsp            `protobuf:"bytes,21,opt,name=removeJob,proto3" json:"removeJob"`
	ExecuteJob           ExecuteJobRsp           `protobuf:"bytes,22,opt,name=executeJob,proto3" json:"executeJob"`
	AddScheduleGroupRule AddScheduleGroupRuleRsp `protobuf:"bytes,23,opt,name=addScheduleGroupRule,proto3" json:"addScheduleGroupRule"`
	GetScheduleGroupRule GetScheduleGroupRuleRsp `protobuf:"bytes,24,opt,name=getScheduleGroupRule,proto3" json:"getScheduleGroupRule"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *ProphetResponse) Reset()         { *m = ProphetResponse{} }
func (m *ProphetResponse) String() string { return proto.CompactTextString(m) }
func (*ProphetResponse) ProtoMessage()    {}
func (*ProphetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{1}
}
func (m *ProphetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProphetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProphetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProphetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProphetResponse.Merge(m, src)
}
func (m *ProphetResponse) XXX_Size() int {
	return m.Size()
}
func (m *ProphetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ProphetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ProphetResponse proto.InternalMessageInfo

func (m *ProphetResponse) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ProphetResponse) GetType() Type {
	if m != nil {
		return m.Type
	}
	return TypeRegisterStore
}

func (m *ProphetResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *ProphetResponse) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

func (m *ProphetResponse) GetShardHeartbeat() ShardHeartbeatRsp {
	if m != nil {
		return m.ShardHeartbeat
	}
	return ShardHeartbeatRsp{}
}

func (m *ProphetResponse) GetStoreHeartbeat() StoreHeartbeatRsp {
	if m != nil {
		return m.StoreHeartbeat
	}
	return StoreHeartbeatRsp{}
}

func (m *ProphetResponse) GetPutStore() PutStoreRsp {
	if m != nil {
		return m.PutStore
	}
	return PutStoreRsp{}
}

func (m *ProphetResponse) GetGetStore() GetStoreRsp {
	if m != nil {
		return m.GetStore
	}
	return GetStoreRsp{}
}

func (m *ProphetResponse) GetAllocID() AllocIDRsp {
	if m != nil {
		return m.AllocID
	}
	return AllocIDRsp{}
}

func (m *ProphetResponse) GetAskBatchSplit() AskBatchSplitRsp {
	if m != nil {
		return m.AskBatchSplit
	}
	return AskBatchSplitRsp{}
}

func (m *ProphetResponse) GetCreateDestroying() CreateDestroyingRsp {
	if m != nil {
		return m.CreateDestroying
	}
	return CreateDestroyingRsp{}
}

func (m *ProphetResponse) GetReportDestroyed() ReportDestroyedRsp {
	if m != nil {
		return m.ReportDestroyed
	}
	return ReportDestroyedRsp{}
}

func (m *ProphetResponse) GetGetDestroying() GetDestroyingRsp {
	if m != nil {
		return m.GetDestroying
	}
	return GetDestroyingRsp{}
}

func (m *ProphetResponse) GetEvent() EventNotify {
	if m != nil {
		return m.Event
	}
	return EventNotify{}
}

func (m *ProphetResponse) GetCreateShards() CreateShardsRsp {
	if m != nil {
		return m.CreateShards
	}
	return CreateShardsRsp{}
}

func (m *ProphetResponse) GetRemoveShards() RemoveShardsRsp {
	if m != nil {
		return m.RemoveShards
	}
	return RemoveShardsRsp{}
}

func (m *ProphetResponse) GetCheckShardState() CheckShardStateRsp {
	if m != nil {
		return m.CheckShardState
	}
	return CheckShardStateRsp{}
}

func (m *ProphetResponse) GetPutPlacementRule() PutPlacementRuleRsp {
	if m != nil {
		return m.PutPlacementRule
	}
	return PutPlacementRuleRsp{}
}

func (m *ProphetResponse) GetGetAppliedRules() GetAppliedRulesRsp {
	if m != nil {
		return m.GetAppliedRules
	}
	return GetAppliedRulesRsp{}
}

func (m *ProphetResponse) GetCreateJob() CreateJobRsp {
	if m != nil {
		return m.CreateJob
	}
	return CreateJobRsp{}
}

func (m *ProphetResponse) GetRemoveJob() RemoveJobRsp {
	if m != nil {
		return m.RemoveJob
	}
	return RemoveJobRsp{}
}

func (m *ProphetResponse) GetExecuteJob() ExecuteJobRsp {
	if m != nil {
		return m.ExecuteJob
	}
	return ExecuteJobRsp{}
}

func (m *ProphetResponse) GetAddScheduleGroupRule() AddScheduleGroupRuleRsp {
	if m != nil {
		return m.AddScheduleGroupRule
	}
	return AddScheduleGroupRuleRsp{}
}

func (m *ProphetResponse) GetGetScheduleGroupRule() GetScheduleGroupRuleRsp {
	if m != nil {
		return m.GetScheduleGroupRule
	}
	return GetScheduleGroupRuleRsp{}
}

// ShardHeartbeatReq shard heartbeat request
type ShardHeartbeatReq struct {
	StoreID uint64 `protobuf:"varint,1,opt,name=storeID,proto3" json:"storeID,omitempty"`
	Shard   []byte `protobuf:"bytes,2,opt,name=shard,proto3" json:"shard,omitempty"`
	// Term is the term of raft group.
	Term                 uint64                `protobuf:"varint,3,opt,name=term,proto3" json:"term,omitempty"`
	Leader               *metapb.Replica       `protobuf:"bytes,4,opt,name=leader,proto3" json:"leader,omitempty"`
	DownReplicas         []metapb.ReplicaStats `protobuf:"bytes,5,rep,name=downReplicas,proto3" json:"downReplicas"`
	PendingReplicas      []metapb.Replica      `protobuf:"bytes,6,rep,name=pendingReplicas,proto3" json:"pendingReplicas"`
	Stats                metapb.ShardStats     `protobuf:"bytes,7,opt,name=stats,proto3" json:"stats"`
	GroupKey             string                `protobuf:"bytes,8,opt,name=groupKey,proto3" json:"groupKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ShardHeartbeatReq) Reset()         { *m = ShardHeartbeatReq{} }
func (m *ShardHeartbeatReq) String() string { return proto.CompactTextString(m) }
func (*ShardHeartbeatReq) ProtoMessage()    {}
func (*ShardHeartbeatReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{2}
}
func (m *ShardHeartbeatReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardHeartbeatReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardHeartbeatReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardHeartbeatReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardHeartbeatReq.Merge(m, src)
}
func (m *ShardHeartbeatReq) XXX_Size() int {
	return m.Size()
}
func (m *ShardHeartbeatReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardHeartbeatReq.DiscardUnknown(m)
}

var xxx_messageInfo_ShardHeartbeatReq proto.InternalMessageInfo

func (m *ShardHeartbeatReq) GetStoreID() uint64 {
	if m != nil {
		return m.StoreID
	}
	return 0
}

func (m *ShardHeartbeatReq) GetShard() []byte {
	if m != nil {
		return m.Shard
	}
	return nil
}

func (m *ShardHeartbeatReq) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *ShardHeartbeatReq) GetLeader() *metapb.Replica {
	if m != nil {
		return m.Leader
	}
	return nil
}

func (m *ShardHeartbeatReq) GetDownReplicas() []metapb.ReplicaStats {
	if m != nil {
		return m.DownReplicas
	}
	return nil
}

func (m *ShardHeartbeatReq) GetPendingReplicas() []metapb.Replica {
	if m != nil {
		return m.PendingReplicas
	}
	return nil
}

func (m *ShardHeartbeatReq) GetStats() metapb.ShardStats {
	if m != nil {
		return m.Stats
	}
	return metapb.ShardStats{}
}

func (m *ShardHeartbeatReq) GetGroupKey() string {
	if m != nil {
		return m.GroupKey
	}
	return ""
}

// ShardHeartbeatRsp shard heartbeat response.
type ShardHeartbeatRsp struct {
	ShardID    uint64            `protobuf:"varint,1,opt,name=shardID,proto3" json:"shardID,omitempty"`
	ShardEpoch metapb.ShardEpoch `protobuf:"bytes,2,opt,name=shardEpoch,proto3" json:"shardEpoch"`
	// Leader of the shard at the moment of the corresponding request was made.
	TargetReplica *metapb.Replica `protobuf:"bytes,3,opt,name=targetReplica,proto3" json:"targetReplica,omitempty"`
	// Notice, prophet only allows handling reported epoch >= current prophet's.
	// Leader peer reports shard status with ShardHeartbeatReq
	// to prophet regularly, prophet will determine whether this shard
	// should do ChangePeer or not.
	// E,g, max peer number is 3, shard A, first only peer 1 in A.
	// 1. prophet shard state -> Peers (1), ConfVer (1).
	// 2. Leader peer 1 reports shard state to prophet, prophet finds the
	// peer number is < 3, so first changes its current shard
	// state -> Peers (1, 2), ConfVer (1), and returns ChangePeer Adding 2.
	// 3. Leader does ChangePeer, then reports Peers (1, 2), ConfVer (2),
	// prophet updates its state -> Peers (1, 2), ConfVer (2).
	// 4. Leader may report old Peers (1), ConfVer (1) to pd before ConfChange
	// finished, pd stills responses ChangePeer Adding 2, of course, we must
	// guarantee the second ChangePeer can't be applied in your application.
	ConfigChange   *ConfigChange   `protobuf:"bytes,4,opt,name=configChange,proto3" json:"configChange,omitempty"`
	TransferLeader *TransferLeader `protobuf:"bytes,5,opt,name=transferLeader,proto3" json:"transferLeader,omitempty"`
	Merge          *Merge          `protobuf:"bytes,6,opt,name=merge,proto3" json:"merge,omitempty"`
	SplitShard     *SplitShard     `protobuf:"bytes,7,opt,name=splitShard,proto3" json:"splitShard,omitempty"`
	ConfigChangeV2 *ConfigChangeV2 `protobuf:"bytes,8,opt,name=configChangeV2,proto3" json:"configChangeV2,omitempty"`
	// DestroyDirectly the shard has been removed, destroy directly without raft.
	DestroyDirectly      bool     `protobuf:"varint,9,opt,name=destroyDirectly,proto3" json:"destroyDirectly,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShardHeartbeatRsp) Reset()         { *m = ShardHeartbeatRsp{} }
func (m *ShardHeartbeatRsp) String() string { return proto.CompactTextString(m) }
func (*ShardHeartbeatRsp) ProtoMessage()    {}
func (*ShardHeartbeatRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{3}
}
func (m *ShardHeartbeatRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardHeartbeatRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardHeartbeatRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardHeartbeatRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardHeartbeatRsp.Merge(m, src)
}
func (m *ShardHeartbeatRsp) XXX_Size() int {
	return m.Size()
}
func (m *ShardHeartbeatRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardHeartbeatRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ShardHeartbeatRsp proto.InternalMessageInfo

func (m *ShardHeartbeatRsp) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *ShardHeartbeatRsp) GetShardEpoch() metapb.ShardEpoch {
	if m != nil {
		return m.ShardEpoch
	}
	return metapb.ShardEpoch{}
}

func (m *ShardHeartbeatRsp) GetTargetReplica() *metapb.Replica {
	if m != nil {
		return m.TargetReplica
	}
	return nil
}

func (m *ShardHeartbeatRsp) GetConfigChange() *ConfigChange {
	if m != nil {
		return m.ConfigChange
	}
	return nil
}

func (m *ShardHeartbeatRsp) GetTransferLeader() *TransferLeader {
	if m != nil {
		return m.TransferLeader
	}
	return nil
}

func (m *ShardHeartbeatRsp) GetMerge() *Merge {
	if m != nil {
		return m.Merge
	}
	return nil
}

func (m *ShardHeartbeatRsp) GetSplitShard() *SplitShard {
	if m != nil {
		return m.SplitShard
	}
	return nil
}

func (m *ShardHeartbeatRsp) GetConfigChangeV2() *ConfigChangeV2 {
	if m != nil {
		return m.ConfigChangeV2
	}
	return nil
}

func (m *ShardHeartbeatRsp) GetDestroyDirectly() bool {
	if m != nil {
		return m.DestroyDirectly
	}
	return false
}

// PutStoreReq put store request
type PutStoreReq struct {
	Store                []byte   `protobuf:"bytes,1,opt,name=store,proto3" json:"store,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PutStoreReq) Reset()         { *m = PutStoreReq{} }
func (m *PutStoreReq) String() string { return proto.CompactTextString(m) }
func (*PutStoreReq) ProtoMessage()    {}
func (*PutStoreReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{4}
}
func (m *PutStoreReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutStoreReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutStoreReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutStoreReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutStoreReq.Merge(m, src)
}
func (m *PutStoreReq) XXX_Size() int {
	return m.Size()
}
func (m *PutStoreReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PutStoreReq.DiscardUnknown(m)
}

var xxx_messageInfo_PutStoreReq proto.InternalMessageInfo

func (m *PutStoreReq) GetStore() []byte {
	if m != nil {
		return m.Store
	}
	return nil
}

// PutStoreRsp put store response
type PutStoreRsp struct {
	DestroyShards        []byte   `protobuf:"bytes,1,opt,name=destroyShards,proto3" json:"destroyShards,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PutStoreRsp) Reset()         { *m = PutStoreRsp{} }
func (m *PutStoreRsp) String() string { return proto.CompactTextString(m) }
func (*PutStoreRsp) ProtoMessage()    {}
func (*PutStoreRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{5}
}
func (m *PutStoreRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutStoreRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutStoreRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutStoreRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutStoreRsp.Merge(m, src)
}
func (m *PutStoreRsp) XXX_Size() int {
	return m.Size()
}
func (m *PutStoreRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_PutStoreRsp.DiscardUnknown(m)
}

var xxx_messageInfo_PutStoreRsp proto.InternalMessageInfo

func (m *PutStoreRsp) GetDestroyShards() []byte {
	if m != nil {
		return m.DestroyShards
	}
	return nil
}

// StoreHeartbeatReq store heartbeat request
type StoreHeartbeatReq struct {
	Stats                metapb.StoreStats `protobuf:"bytes,1,opt,name=stats,proto3" json:"stats"`
	Data                 []byte            `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *StoreHeartbeatReq) Reset()         { *m = StoreHeartbeatReq{} }
func (m *StoreHeartbeatReq) String() string { return proto.CompactTextString(m) }
func (*StoreHeartbeatReq) ProtoMessage()    {}
func (*StoreHeartbeatReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{6}
}
func (m *StoreHeartbeatReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreHeartbeatReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreHeartbeatReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreHeartbeatReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreHeartbeatReq.Merge(m, src)
}
func (m *StoreHeartbeatReq) XXX_Size() int {
	return m.Size()
}
func (m *StoreHeartbeatReq) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreHeartbeatReq.DiscardUnknown(m)
}

var xxx_messageInfo_StoreHeartbeatReq proto.InternalMessageInfo

func (m *StoreHeartbeatReq) GetStats() metapb.StoreStats {
	if m != nil {
		return m.Stats
	}
	return metapb.StoreStats{}
}

func (m *StoreHeartbeatReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// StoreHeartbeatRsp store heartbeat response
type StoreHeartbeatRsp struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StoreHeartbeatRsp) Reset()         { *m = StoreHeartbeatRsp{} }
func (m *StoreHeartbeatRsp) String() string { return proto.CompactTextString(m) }
func (*StoreHeartbeatRsp) ProtoMessage()    {}
func (*StoreHeartbeatRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{7}
}
func (m *StoreHeartbeatRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreHeartbeatRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreHeartbeatRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreHeartbeatRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreHeartbeatRsp.Merge(m, src)
}
func (m *StoreHeartbeatRsp) XXX_Size() int {
	return m.Size()
}
func (m *StoreHeartbeatRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreHeartbeatRsp.DiscardUnknown(m)
}

var xxx_messageInfo_StoreHeartbeatRsp proto.InternalMessageInfo

func (m *StoreHeartbeatRsp) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// GetStoreReq get store request
type GetStoreReq struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetStoreReq) Reset()         { *m = GetStoreReq{} }
func (m *GetStoreReq) String() string { return proto.CompactTextString(m) }
func (*GetStoreReq) ProtoMessage()    {}
func (*GetStoreReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{8}
}
func (m *GetStoreReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStoreReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetStoreReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetStoreReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStoreReq.Merge(m, src)
}
func (m *GetStoreReq) XXX_Size() int {
	return m.Size()
}
func (m *GetStoreReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStoreReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetStoreReq proto.InternalMessageInfo

func (m *GetStoreReq) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

// GetStoreRsp get store response
type GetStoreRsp struct {
	Data                 []byte             `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Stats                *metapb.StoreStats `protobuf:"bytes,2,opt,name=stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *GetStoreRsp) Reset()         { *m = GetStoreRsp{} }
func (m *GetStoreRsp) String() string { return proto.CompactTextString(m) }
func (*GetStoreRsp) ProtoMessage()    {}
func (*GetStoreRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{9}
}
func (m *GetStoreRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStoreRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetStoreRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetStoreRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStoreRsp.Merge(m, src)
}
func (m *GetStoreRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetStoreRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStoreRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetStoreRsp proto.InternalMessageInfo

func (m *GetStoreRsp) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *GetStoreRsp) GetStats() *metapb.StoreStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// AllocIDReq alloc id request
type AllocIDReq struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AllocIDReq) Reset()         { *m = AllocIDReq{} }
func (m *AllocIDReq) String() string { return proto.CompactTextString(m) }
func (*AllocIDReq) ProtoMessage()    {}
func (*AllocIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{10}
}
func (m *AllocIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllocIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllocIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocIDReq.Merge(m, src)
}
func (m *AllocIDReq) XXX_Size() int {
	return m.Size()
}
func (m *AllocIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_AllocIDReq proto.InternalMessageInfo

// AllocIDRsp alloc id response
type AllocIDRsp struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AllocIDRsp) Reset()         { *m = AllocIDRsp{} }
func (m *AllocIDRsp) String() string { return proto.CompactTextString(m) }
func (*AllocIDRsp) ProtoMessage()    {}
func (*AllocIDRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{11}
}
func (m *AllocIDRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocIDRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllocIDRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllocIDRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocIDRsp.Merge(m, src)
}
func (m *AllocIDRsp) XXX_Size() int {
	return m.Size()
}
func (m *AllocIDRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocIDRsp.DiscardUnknown(m)
}

var xxx_messageInfo_AllocIDRsp proto.InternalMessageInfo

func (m *AllocIDRsp) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

// AskBatchSplitReq ask batch split request
type AskBatchSplitReq struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Count                uint32   `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AskBatchSplitReq) Reset()         { *m = AskBatchSplitReq{} }
func (m *AskBatchSplitReq) String() string { return proto.CompactTextString(m) }
func (*AskBatchSplitReq) ProtoMessage()    {}
func (*AskBatchSplitReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{12}
}
func (m *AskBatchSplitReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AskBatchSplitReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AskBatchSplitReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AskBatchSplitReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AskBatchSplitReq.Merge(m, src)
}
func (m *AskBatchSplitReq) XXX_Size() int {
	return m.Size()
}
func (m *AskBatchSplitReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AskBatchSplitReq.DiscardUnknown(m)
}

var xxx_messageInfo_AskBatchSplitReq proto.InternalMessageInfo

func (m *AskBatchSplitReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *AskBatchSplitReq) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

// AskBatchSplitRsp ask batch split response
type AskBatchSplitRsp struct {
	SplitIDs             []SplitID `protobuf:"bytes,1,rep,name=splitIDs,proto3" json:"splitIDs"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *AskBatchSplitRsp) Reset()         { *m = AskBatchSplitRsp{} }
func (m *AskBatchSplitRsp) String() string { return proto.CompactTextString(m) }
func (*AskBatchSplitRsp) ProtoMessage()    {}
func (*AskBatchSplitRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{13}
}
func (m *AskBatchSplitRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AskBatchSplitRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AskBatchSplitRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AskBatchSplitRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AskBatchSplitRsp.Merge(m, src)
}
func (m *AskBatchSplitRsp) XXX_Size() int {
	return m.Size()
}
func (m *AskBatchSplitRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_AskBatchSplitRsp.DiscardUnknown(m)
}

var xxx_messageInfo_AskBatchSplitRsp proto.InternalMessageInfo

func (m *AskBatchSplitRsp) GetSplitIDs() []SplitID {
	if m != nil {
		return m.SplitIDs
	}
	return nil
}

// CreateDestroyingReq create destroying status request
type CreateDestroyingReq struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Index                uint64   `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	Replicas             []uint64 `protobuf:"varint,3,rep,packed,name=replicas,proto3" json:"replicas,omitempty"`
	RemoveData           bool     `protobuf:"varint,4,opt,name=removeData,proto3" json:"removeData,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateDestroyingReq) Reset()         { *m = CreateDestroyingReq{} }
func (m *CreateDestroyingReq) String() string { return proto.CompactTextString(m) }
func (*CreateDestroyingReq) ProtoMessage()    {}
func (*CreateDestroyingReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{14}
}
func (m *CreateDestroyingReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateDestroyingReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateDestroyingReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateDestroyingReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateDestroyingReq.Merge(m, src)
}
func (m *CreateDestroyingReq) XXX_Size() int {
	return m.Size()
}
func (m *CreateDestroyingReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateDestroyingReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreateDestroyingReq proto.InternalMessageInfo

func (m *CreateDestroyingReq) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *CreateDestroyingReq) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *CreateDestroyingReq) GetReplicas() []uint64 {
	if m != nil {
		return m.Replicas
	}
	return nil
}

func (m *CreateDestroyingReq) GetRemoveData() bool {
	if m != nil {
		return m.RemoveData
	}
	return false
}

// CreateDestroyingRsp create destroying status response
type CreateDestroyingRsp struct {
	State                metapb.ShardState `protobuf:"varint,1,opt,name=state,proto3,enum=metapb.ShardState" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *CreateDestroyingRsp) Reset()         { *m = CreateDestroyingRsp{} }
func (m *CreateDestroyingRsp) String() string { return proto.CompactTextString(m) }
func (*CreateDestroyingRsp) ProtoMessage()    {}
func (*CreateDestroyingRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{15}
}
func (m *CreateDestroyingRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateDestroyingRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateDestroyingRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateDestroyingRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateDestroyingRsp.Merge(m, src)
}
func (m *CreateDestroyingRsp) XXX_Size() int {
	return m.Size()
}
func (m *CreateDestroyingRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateDestroyingRsp.DiscardUnknown(m)
}

var xxx_messageInfo_CreateDestroyingRsp proto.InternalMessageInfo

func (m *CreateDestroyingRsp) GetState() metapb.ShardState {
	if m != nil {
		return m.State
	}
	return metapb.ShardState_Running
}

// GetDestroyingReq get destroying status request
type GetDestroyingReq struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetDestroyingReq) Reset()         { *m = GetDestroyingReq{} }
func (m *GetDestroyingReq) String() string { return proto.CompactTextString(m) }
func (*GetDestroyingReq) ProtoMessage()    {}
func (*GetDestroyingReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{16}
}
func (m *GetDestroyingReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetDestroyingReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetDestroyingReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetDestroyingReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDestroyingReq.Merge(m, src)
}
func (m *GetDestroyingReq) XXX_Size() int {
	return m.Size()
}
func (m *GetDestroyingReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDestroyingReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetDestroyingReq proto.InternalMessageInfo

func (m *GetDestroyingReq) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

// GetDestroyingRsp get destroying status response
type GetDestroyingRsp struct {
	Status               *metapb.DestroyingStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *GetDestroyingRsp) Reset()         { *m = GetDestroyingRsp{} }
func (m *GetDestroyingRsp) String() string { return proto.CompactTextString(m) }
func (*GetDestroyingRsp) ProtoMessage()    {}
func (*GetDestroyingRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{17}
}
func (m *GetDestroyingRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetDestroyingRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetDestroyingRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetDestroyingRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDestroyingRsp.Merge(m, src)
}
func (m *GetDestroyingRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetDestroyingRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDestroyingRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetDestroyingRsp proto.InternalMessageInfo

func (m *GetDestroyingRsp) GetStatus() *metapb.DestroyingStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// ReportDestroyedReq report destroying request
type ReportDestroyedReq struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	ReplicaID            uint64   `protobuf:"varint,2,opt,name=replicaID,proto3" json:"replicaID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReportDestroyedReq) Reset()         { *m = ReportDestroyedReq{} }
func (m *ReportDestroyedReq) String() string { return proto.CompactTextString(m) }
func (*ReportDestroyedReq) ProtoMessage()    {}
func (*ReportDestroyedReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{18}
}
func (m *ReportDestroyedReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportDestroyedReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportDestroyedReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportDestroyedReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportDestroyedReq.Merge(m, src)
}
func (m *ReportDestroyedReq) XXX_Size() int {
	return m.Size()
}
func (m *ReportDestroyedReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportDestroyedReq.DiscardUnknown(m)
}

var xxx_messageInfo_ReportDestroyedReq proto.InternalMessageInfo

func (m *ReportDestroyedReq) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ReportDestroyedReq) GetReplicaID() uint64 {
	if m != nil {
		return m.ReplicaID
	}
	return 0
}

// ReportDestroyedRsp report destroying rsp
type ReportDestroyedRsp struct {
	State                metapb.ShardState `protobuf:"varint,1,opt,name=state,proto3,enum=metapb.ShardState" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ReportDestroyedRsp) Reset()         { *m = ReportDestroyedRsp{} }
func (m *ReportDestroyedRsp) String() string { return proto.CompactTextString(m) }
func (*ReportDestroyedRsp) ProtoMessage()    {}
func (*ReportDestroyedRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{19}
}
func (m *ReportDestroyedRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportDestroyedRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportDestroyedRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportDestroyedRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportDestroyedRsp.Merge(m, src)
}
func (m *ReportDestroyedRsp) XXX_Size() int {
	return m.Size()
}
func (m *ReportDestroyedRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportDestroyedRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ReportDestroyedRsp proto.InternalMessageInfo

func (m *ReportDestroyedRsp) GetState() metapb.ShardState {
	if m != nil {
		return m.State
	}
	return metapb.ShardState_Running
}

// SplitID split id
type SplitID struct {
	NewID                uint64   `protobuf:"varint,1,opt,name=newID,proto3" json:"newID,omitempty"`
	NewReplicaIDs        []uint64 `protobuf:"varint,2,rep,packed,name=newReplicaIDs,proto3" json:"newReplicaIDs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SplitID) Reset()         { *m = SplitID{} }
func (m *SplitID) String() string { return proto.CompactTextString(m) }
func (*SplitID) ProtoMessage()    {}
func (*SplitID) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{20}
}
func (m *SplitID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitID.Merge(m, src)
}
func (m *SplitID) XXX_Size() int {
	return m.Size()
}
func (m *SplitID) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitID.DiscardUnknown(m)
}

var xxx_messageInfo_SplitID proto.InternalMessageInfo

func (m *SplitID) GetNewID() uint64 {
	if m != nil {
		return m.NewID
	}
	return 0
}

func (m *SplitID) GetNewReplicaIDs() []uint64 {
	if m != nil {
		return m.NewReplicaIDs
	}
	return nil
}

// CreateWatcherReq create watcher req
type CreateWatcherReq struct {
	Flag                 uint32   `protobuf:"varint,1,opt,name=flag,proto3" json:"flag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateWatcherReq) Reset()         { *m = CreateWatcherReq{} }
func (m *CreateWatcherReq) String() string { return proto.CompactTextString(m) }
func (*CreateWatcherReq) ProtoMessage()    {}
func (*CreateWatcherReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{21}
}
func (m *CreateWatcherReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateWatcherReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateWatcherReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateWatcherReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateWatcherReq.Merge(m, src)
}
func (m *CreateWatcherReq) XXX_Size() int {
	return m.Size()
}
func (m *CreateWatcherReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateWatcherReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreateWatcherReq proto.InternalMessageInfo

func (m *CreateWatcherReq) GetFlag() uint32 {
	if m != nil {
		return m.Flag
	}
	return 0
}

// CreateShardsReq create shards req
type CreateShardsReq struct {
	Shards               [][]byte `protobuf:"bytes,1,rep,name=shards,proto3" json:"shards,omitempty"`
	LeastReplicas        []uint64 `protobuf:"varint,2,rep,packed,name=leastReplicas,proto3" json:"leastReplicas,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateShardsReq) Reset()         { *m = CreateShardsReq{} }
func (m *CreateShardsReq) String() string { return proto.CompactTextString(m) }
func (*CreateShardsReq) ProtoMessage()    {}
func (*CreateShardsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{22}
}
func (m *CreateShardsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateShardsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateShardsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateShardsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateShardsReq.Merge(m, src)
}
func (m *CreateShardsReq) XXX_Size() int {
	return m.Size()
}
func (m *CreateShardsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateShardsReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreateShardsReq proto.InternalMessageInfo

func (m *CreateShardsReq) GetShards() [][]byte {
	if m != nil {
		return m.Shards
	}
	return nil
}

func (m *CreateShardsReq) GetLeastReplicas() []uint64 {
	if m != nil {
		return m.LeastReplicas
	}
	return nil
}

// CreateShardsRsp create shards rsp
type CreateShardsRsp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateShardsRsp) Reset()         { *m = CreateShardsRsp{} }
func (m *CreateShardsRsp) String() string { return proto.CompactTextString(m) }
func (*CreateShardsRsp) ProtoMessage()    {}
func (*CreateShardsRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{23}
}
func (m *CreateShardsRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateShardsRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateShardsRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateShardsRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateShardsRsp.Merge(m, src)
}
func (m *CreateShardsRsp) XXX_Size() int {
	return m.Size()
}
func (m *CreateShardsRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateShardsRsp.DiscardUnknown(m)
}

var xxx_messageInfo_CreateShardsRsp proto.InternalMessageInfo

// RemoveShardsReq remove shards req
type RemoveShardsReq struct {
	IDs                  []uint64 `protobuf:"varint,1,rep,packed,name=ids,proto3" json:"ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoveShardsReq) Reset()         { *m = RemoveShardsReq{} }
func (m *RemoveShardsReq) String() string { return proto.CompactTextString(m) }
func (*RemoveShardsReq) ProtoMessage()    {}
func (*RemoveShardsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{24}
}
func (m *RemoveShardsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveShardsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveShardsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveShardsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveShardsReq.Merge(m, src)
}
func (m *RemoveShardsReq) XXX_Size() int {
	return m.Size()
}
func (m *RemoveShardsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveShardsReq.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveShardsReq proto.InternalMessageInfo

func (m *RemoveShardsReq) GetIDs() []uint64 {
	if m != nil {
		return m.IDs
	}
	return nil
}

// RemoveShardsRsp remove shards rsp
type RemoveShardsRsp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoveShardsRsp) Reset()         { *m = RemoveShardsRsp{} }
func (m *RemoveShardsRsp) String() string { return proto.CompactTextString(m) }
func (*RemoveShardsRsp) ProtoMessage()    {}
func (*RemoveShardsRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{25}
}
func (m *RemoveShardsRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveShardsRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveShardsRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveShardsRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveShardsRsp.Merge(m, src)
}
func (m *RemoveShardsRsp) XXX_Size() int {
	return m.Size()
}
func (m *RemoveShardsRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveShardsRsp.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveShardsRsp proto.InternalMessageInfo

// CheckShardStateReq check shard state req
type CheckShardStateReq struct {
	IDs                  []byte   `protobuf:"bytes,1,opt,name=ids,proto3" json:"ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckShardStateReq) Reset()         { *m = CheckShardStateReq{} }
func (m *CheckShardStateReq) String() string { return proto.CompactTextString(m) }
func (*CheckShardStateReq) ProtoMessage()    {}
func (*CheckShardStateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{26}
}
func (m *CheckShardStateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckShardStateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckShardStateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckShardStateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckShardStateReq.Merge(m, src)
}
func (m *CheckShardStateReq) XXX_Size() int {
	return m.Size()
}
func (m *CheckShardStateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckShardStateReq.DiscardUnknown(m)
}

var xxx_messageInfo_CheckShardStateReq proto.InternalMessageInfo

func (m *CheckShardStateReq) GetIDs() []byte {
	if m != nil {
		return m.IDs
	}
	return nil
}

// CheckShardStateReq check shard state rsp
type CheckShardStateRsp struct {
	Destroyed            []byte   `protobuf:"bytes,1,opt,name=destroyed,proto3" json:"destroyed,omitempty"`
	Destroying           []byte   `protobuf:"bytes,2,opt,name=destroying,proto3" json:"destroying,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckShardStateRsp) Reset()         { *m = CheckShardStateRsp{} }
func (m *CheckShardStateRsp) String() string { return proto.CompactTextString(m) }
func (*CheckShardStateRsp) ProtoMessage()    {}
func (*CheckShardStateRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{27}
}
func (m *CheckShardStateRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckShardStateRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckShardStateRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckShardStateRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckShardStateRsp.Merge(m, src)
}
func (m *CheckShardStateRsp) XXX_Size() int {
	return m.Size()
}
func (m *CheckShardStateRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckShardStateRsp.DiscardUnknown(m)
}

var xxx_messageInfo_CheckShardStateRsp proto.InternalMessageInfo

func (m *CheckShardStateRsp) GetDestroyed() []byte {
	if m != nil {
		return m.Destroyed
	}
	return nil
}

func (m *CheckShardStateRsp) GetDestroying() []byte {
	if m != nil {
		return m.Destroying
	}
	return nil
}

// PutPlacementRuleReq put placement rule req
type PutPlacementRuleReq struct {
	Rule                 PlacementRule `protobuf:"bytes,1,opt,name=rule,proto3" json:"rule"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *PutPlacementRuleReq) Reset()         { *m = PutPlacementRuleReq{} }
func (m *PutPlacementRuleReq) String() string { return proto.CompactTextString(m) }
func (*PutPlacementRuleReq) ProtoMessage()    {}
func (*PutPlacementRuleReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{28}
}
func (m *PutPlacementRuleReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutPlacementRuleReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutPlacementRuleReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutPlacementRuleReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutPlacementRuleReq.Merge(m, src)
}
func (m *PutPlacementRuleReq) XXX_Size() int {
	return m.Size()
}
func (m *PutPlacementRuleReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PutPlacementRuleReq.DiscardUnknown(m)
}

var xxx_messageInfo_PutPlacementRuleReq proto.InternalMessageInfo

func (m *PutPlacementRuleReq) GetRule() PlacementRule {
	if m != nil {
		return m.Rule
	}
	return PlacementRule{}
}

// PutPlacementRuleRsp put placement rule rsp
type PutPlacementRuleRsp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PutPlacementRuleRsp) Reset()         { *m = PutPlacementRuleRsp{} }
func (m *PutPlacementRuleRsp) String() string { return proto.CompactTextString(m) }
func (*PutPlacementRuleRsp) ProtoMessage()    {}
func (*PutPlacementRuleRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{29}
}
func (m *PutPlacementRuleRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutPlacementRuleRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutPlacementRuleRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutPlacementRuleRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutPlacementRuleRsp.Merge(m, src)
}
func (m *PutPlacementRuleRsp) XXX_Size() int {
	return m.Size()
}
func (m *PutPlacementRuleRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_PutPlacementRuleRsp.DiscardUnknown(m)
}

var xxx_messageInfo_PutPlacementRuleRsp proto.InternalMessageInfo

// GetAppliedRulesReq get applied rules req
type GetAppliedRulesReq struct {
	ShardID              uint64   `protobuf:"varint,1,opt,name=shardID,proto3" json:"shardID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetAppliedRulesReq) Reset()         { *m = GetAppliedRulesReq{} }
func (m *GetAppliedRulesReq) String() string { return proto.CompactTextString(m) }
func (*GetAppliedRulesReq) ProtoMessage()    {}
func (*GetAppliedRulesReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{30}
}
func (m *GetAppliedRulesReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAppliedRulesReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAppliedRulesReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAppliedRulesReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAppliedRulesReq.Merge(m, src)
}
func (m *GetAppliedRulesReq) XXX_Size() int {
	return m.Size()
}
func (m *GetAppliedRulesReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAppliedRulesReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetAppliedRulesReq proto.InternalMessageInfo

func (m *GetAppliedRulesReq) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

// GetAppliedRulesRsp get applied rules rsp
type GetAppliedRulesRsp struct {
	Rules                []PlacementRule `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetAppliedRulesRsp) Reset()         { *m = GetAppliedRulesRsp{} }
func (m *GetAppliedRulesRsp) String() string { return proto.CompactTextString(m) }
func (*GetAppliedRulesRsp) ProtoMessage()    {}
func (*GetAppliedRulesRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{31}
}
func (m *GetAppliedRulesRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAppliedRulesRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAppliedRulesRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAppliedRulesRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAppliedRulesRsp.Merge(m, src)
}
func (m *GetAppliedRulesRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetAppliedRulesRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAppliedRulesRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetAppliedRulesRsp proto.InternalMessageInfo

func (m *GetAppliedRulesRsp) GetRules() []PlacementRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// CreateJobReq create job req
type CreateJobReq struct {
	Job                  metapb.Job `protobuf:"bytes,1,opt,name=job,proto3" json:"job"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *CreateJobReq) Reset()         { *m = CreateJobReq{} }
func (m *CreateJobReq) String() string { return proto.CompactTextString(m) }
func (*CreateJobReq) ProtoMessage()    {}
func (*CreateJobReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{32}
}
func (m *CreateJobReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateJobReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateJobReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateJobReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateJobReq.Merge(m, src)
}
func (m *CreateJobReq) XXX_Size() int {
	return m.Size()
}
func (m *CreateJobReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateJobReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreateJobReq proto.InternalMessageInfo

func (m *CreateJobReq) GetJob() metapb.Job {
	if m != nil {
		return m.Job
	}
	return metapb.Job{}
}

// CreateJobRsp create job rsp
type CreateJobRsp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateJobRsp) Reset()         { *m = CreateJobRsp{} }
func (m *CreateJobRsp) String() string { return proto.CompactTextString(m) }
func (*CreateJobRsp) ProtoMessage()    {}
func (*CreateJobRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{33}
}
func (m *CreateJobRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateJobRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateJobRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateJobRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateJobRsp.Merge(m, src)
}
func (m *CreateJobRsp) XXX_Size() int {
	return m.Size()
}
func (m *CreateJobRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateJobRsp.DiscardUnknown(m)
}

var xxx_messageInfo_CreateJobRsp proto.InternalMessageInfo

// RemoveJobReq Remove job req
type RemoveJobReq struct {
	Job                  metapb.Job `protobuf:"bytes,1,opt,name=job,proto3" json:"job"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RemoveJobReq) Reset()         { *m = RemoveJobReq{} }
func (m *RemoveJobReq) String() string { return proto.CompactTextString(m) }
func (*RemoveJobReq) ProtoMessage()    {}
func (*RemoveJobReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{34}
}
func (m *RemoveJobReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveJobReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveJobReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveJobReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveJobReq.Merge(m, src)
}
func (m *RemoveJobReq) XXX_Size() int {
	return m.Size()
}
func (m *RemoveJobReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveJobReq.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveJobReq proto.InternalMessageInfo

func (m *RemoveJobReq) GetJob() metapb.Job {
	if m != nil {
		return m.Job
	}
	return metapb.Job{}
}

// RemoveJobRsp Remove job rsp
type RemoveJobRsp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoveJobRsp) Reset()         { *m = RemoveJobRsp{} }
func (m *RemoveJobRsp) String() string { return proto.CompactTextString(m) }
func (*RemoveJobRsp) ProtoMessage()    {}
func (*RemoveJobRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{35}
}
func (m *RemoveJobRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveJobRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveJobRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveJobRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveJobRsp.Merge(m, src)
}
func (m *RemoveJobRsp) XXX_Size() int {
	return m.Size()
}
func (m *RemoveJobRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveJobRsp.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveJobRsp proto.InternalMessageInfo

// ExecuteJobReq execute on job request
type ExecuteJobReq struct {
	Job                  metapb.Job `protobuf:"bytes,1,opt,name=job,proto3" json:"job"`
	Data                 []byte     `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ExecuteJobReq) Reset()         { *m = ExecuteJobReq{} }
func (m *ExecuteJobReq) String() string { return proto.CompactTextString(m) }
func (*ExecuteJobReq) ProtoMessage()    {}
func (*ExecuteJobReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{36}
}
func (m *ExecuteJobReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteJobReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteJobReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteJobReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteJobReq.Merge(m, src)
}
func (m *ExecuteJobReq) XXX_Size() int {
	return m.Size()
}
func (m *ExecuteJobReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteJobReq.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteJobReq proto.InternalMessageInfo

func (m *ExecuteJobReq) GetJob() metapb.Job {
	if m != nil {
		return m.Job
	}
	return metapb.Job{}
}

func (m *ExecuteJobReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// ExecuteJobRsp execute on job response
type ExecuteJobRsp struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExecuteJobRsp) Reset()         { *m = ExecuteJobRsp{} }
func (m *ExecuteJobRsp) String() string { return proto.CompactTextString(m) }
func (*ExecuteJobRsp) ProtoMessage()    {}
func (*ExecuteJobRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{37}
}
func (m *ExecuteJobRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteJobRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteJobRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteJobRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteJobRsp.Merge(m, src)
}
func (m *ExecuteJobRsp) XXX_Size() int {
	return m.Size()
}
func (m *ExecuteJobRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteJobRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteJobRsp proto.InternalMessageInfo

func (m *ExecuteJobRsp) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type AddScheduleGroupRuleReq struct {
	Rule                 metapb.ScheduleGroupRule `protobuf:"bytes,1,opt,name=rule,proto3" json:"rule"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *AddScheduleGroupRuleReq) Reset()         { *m = AddScheduleGroupRuleReq{} }
func (m *AddScheduleGroupRuleReq) String() string { return proto.CompactTextString(m) }
func (*AddScheduleGroupRuleReq) ProtoMessage()    {}
func (*AddScheduleGroupRuleReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{38}
}
func (m *AddScheduleGroupRuleReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddScheduleGroupRuleReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddScheduleGroupRuleReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddScheduleGroupRuleReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddScheduleGroupRuleReq.Merge(m, src)
}
func (m *AddScheduleGroupRuleReq) XXX_Size() int {
	return m.Size()
}
func (m *AddScheduleGroupRuleReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AddScheduleGroupRuleReq.DiscardUnknown(m)
}

var xxx_messageInfo_AddScheduleGroupRuleReq proto.InternalMessageInfo

func (m *AddScheduleGroupRuleReq) GetRule() metapb.ScheduleGroupRule {
	if m != nil {
		return m.Rule
	}
	return metapb.ScheduleGroupRule{}
}

type AddScheduleGroupRuleRsp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddScheduleGroupRuleRsp) Reset()         { *m = AddScheduleGroupRuleRsp{} }
func (m *AddScheduleGroupRuleRsp) String() string { return proto.CompactTextString(m) }
func (*AddScheduleGroupRuleRsp) ProtoMessage()    {}
func (*AddScheduleGroupRuleRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{39}
}
func (m *AddScheduleGroupRuleRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddScheduleGroupRuleRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddScheduleGroupRuleRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddScheduleGroupRuleRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddScheduleGroupRuleRsp.Merge(m, src)
}
func (m *AddScheduleGroupRuleRsp) XXX_Size() int {
	return m.Size()
}
func (m *AddScheduleGroupRuleRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_AddScheduleGroupRuleRsp.DiscardUnknown(m)
}

var xxx_messageInfo_AddScheduleGroupRuleRsp proto.InternalMessageInfo

type GetScheduleGroupRuleReq struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetScheduleGroupRuleReq) Reset()         { *m = GetScheduleGroupRuleReq{} }
func (m *GetScheduleGroupRuleReq) String() string { return proto.CompactTextString(m) }
func (*GetScheduleGroupRuleReq) ProtoMessage()    {}
func (*GetScheduleGroupRuleReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{40}
}
func (m *GetScheduleGroupRuleReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetScheduleGroupRuleReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetScheduleGroupRuleReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetScheduleGroupRuleReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetScheduleGroupRuleReq.Merge(m, src)
}
func (m *GetScheduleGroupRuleReq) XXX_Size() int {
	return m.Size()
}
func (m *GetScheduleGroupRuleReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetScheduleGroupRuleReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetScheduleGroupRuleReq proto.InternalMessageInfo

type GetScheduleGroupRuleRsp struct {
	Rules                []metapb.ScheduleGroupRule `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *GetScheduleGroupRuleRsp) Reset()         { *m = GetScheduleGroupRuleRsp{} }
func (m *GetScheduleGroupRuleRsp) String() string { return proto.CompactTextString(m) }
func (*GetScheduleGroupRuleRsp) ProtoMessage()    {}
func (*GetScheduleGroupRuleRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{41}
}
func (m *GetScheduleGroupRuleRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetScheduleGroupRuleRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetScheduleGroupRuleRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetScheduleGroupRuleRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetScheduleGroupRuleRsp.Merge(m, src)
}
func (m *GetScheduleGroupRuleRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetScheduleGroupRuleRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetScheduleGroupRuleRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetScheduleGroupRuleRsp proto.InternalMessageInfo

func (m *GetScheduleGroupRuleRsp) GetRules() []metapb.ScheduleGroupRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// EventNotify event notify
type EventNotify struct {
	Seq                  uint64             `protobuf:"varint,1,opt,name=seq,proto3" json:"seq,omitempty"`
	Type                 uint32             `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	InitEvent            *InitEventData     `protobuf:"bytes,3,opt,name=initEvent,proto3" json:"initEvent,omitempty"`
	ShardEvent           *ShardEventData    `protobuf:"bytes,4,opt,name=shardEvent,proto3" json:"shardEvent,omitempty"`
	StoreEvent           *StoreEventData    `protobuf:"bytes,5,opt,name=storeEvent,proto3" json:"storeEvent,omitempty"`
	ShardStatsEvent      *metapb.ShardStats `protobuf:"bytes,6,opt,name=shardStatsEvent,proto3" json:"shardStatsEvent,omitempty"`
	StoreStatsEvent      *metapb.StoreStats `protobuf:"bytes,7,opt,name=storeStatsEvent,proto3" json:"storeStatsEvent,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *EventNotify) Reset()         { *m = EventNotify{} }
func (m *EventNotify) String() string { return proto.CompactTextString(m) }
func (*EventNotify) ProtoMessage()    {}
func (*EventNotify) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{42}
}
func (m *EventNotify) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventNotify) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventNotify.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventNotify) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventNotify.Merge(m, src)
}
func (m *EventNotify) XXX_Size() int {
	return m.Size()
}
func (m *EventNotify) XXX_DiscardUnknown() {
	xxx_messageInfo_EventNotify.DiscardUnknown(m)
}

var xxx_messageInfo_EventNotify proto.InternalMessageInfo

func (m *EventNotify) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *EventNotify) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *EventNotify) GetInitEvent() *InitEventData {
	if m != nil {
		return m.InitEvent
	}
	return nil
}

func (m *EventNotify) GetShardEvent() *ShardEventData {
	if m != nil {
		return m.ShardEvent
	}
	return nil
}

func (m *EventNotify) GetStoreEvent() *StoreEventData {
	if m != nil {
		return m.StoreEvent
	}
	return nil
}

func (m *EventNotify) GetShardStatsEvent() *metapb.ShardStats {
	if m != nil {
		return m.ShardStatsEvent
	}
	return nil
}

func (m *EventNotify) GetStoreStatsEvent() *metapb.StoreStats {
	if m != nil {
		return m.StoreStatsEvent
	}
	return nil
}

// InitEventData init event data
type InitEventData struct {
	Shards               [][]byte `protobuf:"bytes,1,rep,name=shards,proto3" json:"shards,omitempty"`
	Leaders              []uint64 `protobuf:"varint,2,rep,packed,name=leaders,proto3" json:"leaders,omitempty"`
	Stores               [][]byte `protobuf:"bytes,3,rep,name=stores,proto3" json:"stores,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InitEventData) Reset()         { *m = InitEventData{} }
func (m *InitEventData) String() string { return proto.CompactTextString(m) }
func (*InitEventData) ProtoMessage()    {}
func (*InitEventData) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{43}
}
func (m *InitEventData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InitEventData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InitEventData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InitEventData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitEventData.Merge(m, src)
}
func (m *InitEventData) XXX_Size() int {
	return m.Size()
}
func (m *InitEventData) XXX_DiscardUnknown() {
	xxx_messageInfo_InitEventData.DiscardUnknown(m)
}

var xxx_messageInfo_InitEventData proto.InternalMessageInfo

func (m *InitEventData) GetShards() [][]byte {
	if m != nil {
		return m.Shards
	}
	return nil
}

func (m *InitEventData) GetLeaders() []uint64 {
	if m != nil {
		return m.Leaders
	}
	return nil
}

func (m *InitEventData) GetStores() [][]byte {
	if m != nil {
		return m.Stores
	}
	return nil
}

// ShardEventData shard created or updated
type ShardEventData struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Leader               uint64   `protobuf:"varint,2,opt,name=leader,proto3" json:"leader,omitempty"`
	Removed              bool     `protobuf:"varint,3,opt,name=removed,proto3" json:"removed,omitempty"`
	Create               bool     `protobuf:"varint,4,opt,name=create,proto3" json:"create,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShardEventData) Reset()         { *m = ShardEventData{} }
func (m *ShardEventData) String() string { return proto.CompactTextString(m) }
func (*ShardEventData) ProtoMessage()    {}
func (*ShardEventData) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{44}
}
func (m *ShardEventData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardEventData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardEventData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardEventData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardEventData.Merge(m, src)
}
func (m *ShardEventData) XXX_Size() int {
	return m.Size()
}
func (m *ShardEventData) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardEventData.DiscardUnknown(m)
}

var xxx_messageInfo_ShardEventData proto.InternalMessageInfo

func (m *ShardEventData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ShardEventData) GetLeader() uint64 {
	if m != nil {
		return m.Leader
	}
	return 0
}

func (m *ShardEventData) GetRemoved() bool {
	if m != nil {
		return m.Removed
	}
	return false
}

func (m *ShardEventData) GetCreate() bool {
	if m != nil {
		return m.Create
	}
	return false
}

// StoreEventData store created or updated
type StoreEventData struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StoreEventData) Reset()         { *m = StoreEventData{} }
func (m *StoreEventData) String() string { return proto.CompactTextString(m) }
func (*StoreEventData) ProtoMessage()    {}
func (*StoreEventData) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{45}
}
func (m *StoreEventData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreEventData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreEventData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreEventData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreEventData.Merge(m, src)
}
func (m *StoreEventData) XXX_Size() int {
	return m.Size()
}
func (m *StoreEventData) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreEventData.DiscardUnknown(m)
}

var xxx_messageInfo_StoreEventData proto.InternalMessageInfo

func (m *StoreEventData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// ChangePeer change peer
type ConfigChange struct {
	Replica              metapb.Replica          `protobuf:"bytes,1,opt,name=replica,proto3" json:"replica"`
	ChangeType           metapb.ConfigChangeType `protobuf:"varint,2,opt,name=changeType,proto3,enum=metapb.ConfigChangeType" json:"changeType,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *ConfigChange) Reset()         { *m = ConfigChange{} }
func (m *ConfigChange) String() string { return proto.CompactTextString(m) }
func (*ConfigChange) ProtoMessage()    {}
func (*ConfigChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{46}
}
func (m *ConfigChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigChange.Merge(m, src)
}
func (m *ConfigChange) XXX_Size() int {
	return m.Size()
}
func (m *ConfigChange) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigChange.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigChange proto.InternalMessageInfo

func (m *ConfigChange) GetReplica() metapb.Replica {
	if m != nil {
		return m.Replica
	}
	return metapb.Replica{}
}

func (m *ConfigChange) GetChangeType() metapb.ConfigChangeType {
	if m != nil {
		return m.ChangeType
	}
	return metapb.ConfigChangeType_AddNode
}

// TransferLeader transfer leader
type TransferLeader struct {
	Replica              metapb.Replica `protobuf:"bytes,1,opt,name=replica,proto3" json:"replica"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TransferLeader) Reset()         { *m = TransferLeader{} }
func (m *TransferLeader) String() string { return proto.CompactTextString(m) }
func (*TransferLeader) ProtoMessage()    {}
func (*TransferLeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{47}
}
func (m *TransferLeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferLeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferLeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferLeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferLeader.Merge(m, src)
}
func (m *TransferLeader) XXX_Size() int {
	return m.Size()
}
func (m *TransferLeader) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferLeader.DiscardUnknown(m)
}

var xxx_messageInfo_TransferLeader proto.InternalMessageInfo

func (m *TransferLeader) GetReplica() metapb.Replica {
	if m != nil {
		return m.Replica
	}
	return metapb.Replica{}
}

// ConfigChangeV2 change peer v2
type ConfigChangeV2 struct {
	// If changes is empty, it means that to exit joint state.
	Changes              []ConfigChange `protobuf:"bytes,1,rep,name=changes,proto3" json:"changes"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ConfigChangeV2) Reset()         { *m = ConfigChangeV2{} }
func (m *ConfigChangeV2) String() string { return proto.CompactTextString(m) }
func (*ConfigChangeV2) ProtoMessage()    {}
func (*ConfigChangeV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{48}
}
func (m *ConfigChangeV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigChangeV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigChangeV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigChangeV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigChangeV2.Merge(m, src)
}
func (m *ConfigChangeV2) XXX_Size() int {
	return m.Size()
}
func (m *ConfigChangeV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigChangeV2.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigChangeV2 proto.InternalMessageInfo

func (m *ConfigChangeV2) GetChanges() []ConfigChange {
	if m != nil {
		return m.Changes
	}
	return nil
}

// Merge merge
type Merge struct {
	// target shard
	Target               []byte   `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Merge) Reset()         { *m = Merge{} }
func (m *Merge) String() string { return proto.CompactTextString(m) }
func (*Merge) ProtoMessage()    {}
func (*Merge) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{49}
}
func (m *Merge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Merge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Merge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Merge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Merge.Merge(m, src)
}
func (m *Merge) XXX_Size() int {
	return m.Size()
}
func (m *Merge) XXX_DiscardUnknown() {
	xxx_messageInfo_Merge.DiscardUnknown(m)
}

var xxx_messageInfo_Merge proto.InternalMessageInfo

func (m *Merge) GetTarget() []byte {
	if m != nil {
		return m.Target
	}
	return nil
}

// SplitShard split shard
type SplitShard struct {
	Policy               metapb.CheckPolicy `protobuf:"varint,1,opt,name=policy,proto3,enum=metapb.CheckPolicy" json:"policy,omitempty"`
	Keys                 [][]byte           `protobuf:"bytes,2,rep,name=keys,proto3" json:"keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *SplitShard) Reset()         { *m = SplitShard{} }
func (m *SplitShard) String() string { return proto.CompactTextString(m) }
func (*SplitShard) ProtoMessage()    {}
func (*SplitShard) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{50}
}
func (m *SplitShard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitShard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitShard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitShard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitShard.Merge(m, src)
}
func (m *SplitShard) XXX_Size() int {
	return m.Size()
}
func (m *SplitShard) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitShard.DiscardUnknown(m)
}

var xxx_messageInfo_SplitShard proto.InternalMessageInfo

func (m *SplitShard) GetPolicy() metapb.CheckPolicy {
	if m != nil {
		return m.Policy
	}
	return metapb.CheckPolicy_SCAN
}

func (m *SplitShard) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

// LabelConstraint is used to filter store when trying to place peer of a shard.
type LabelConstraint struct {
	Key                  string            `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Op                   LabelConstraintOp `protobuf:"varint,2,opt,name=op,proto3,enum=rpcpb.LabelConstraintOp" json:"op,omitempty"`
	Values               []string          `protobuf:"bytes,3,rep,name=values,proto3" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *LabelConstraint) Reset()         { *m = LabelConstraint{} }
func (m *LabelConstraint) String() string { return proto.CompactTextString(m) }
func (*LabelConstraint) ProtoMessage()    {}
func (*LabelConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{51}
}
func (m *LabelConstraint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LabelConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LabelConstraint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LabelConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LabelConstraint.Merge(m, src)
}
func (m *LabelConstraint) XXX_Size() int {
	return m.Size()
}
func (m *LabelConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_LabelConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_LabelConstraint proto.InternalMessageInfo

func (m *LabelConstraint) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *LabelConstraint) GetOp() LabelConstraintOp {
	if m != nil {
		return m.Op
	}
	return In
}

func (m *LabelConstraint) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

// PlacementRule place rule
type PlacementRule struct {
	// ID unique ID within a group
	ID string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// GroupID mark the source that add the rule
	GroupID string `protobuf:"bytes,2,opt,name=groupID,proto3" json:"groupID,omitempty"`
	// Index rule apply order in a group, rule with less ID is applied first when indexes are equal
	Index uint32 `protobuf:"varint,3,opt,name=index,proto3" json:"index,omitempty"`
	// Override when it is true, all rules with less indexes are disabled
	Override bool   `protobuf:"varint,4,opt,name=override,proto3" json:"override,omitempty"`
	StartKey []byte `protobuf:"bytes,5,opt,name=startKey,proto3" json:"startKey,omitempty"`
	EndKey   []byte `protobuf:"bytes,6,opt,name=endKey,proto3" json:"endKey,omitempty"`
	// Role expected role of the peers
	Role ReplicaRoleType `protobuf:"varint,7,opt,name=role,proto3,enum=rpcpb.ReplicaRoleType" json:"role,omitempty"`
	// Count expected count of the peers
	Count uint32 `protobuf:"varint,8,opt,name=count,proto3" json:"count,omitempty"`
	// LabelConstraints used to select stores to place peers
	LabelConstraints []LabelConstraint `protobuf:"bytes,9,rep,name=labelConstraints,proto3" json:"labelConstraints"`
	// LocationLabels used to make peers isolated physically
	LocationLabels []string `protobuf:"bytes,10,rep,name=locationLabels,proto3" json:"locationLabels,omitempty"`
	// IsolationLevelused to isolate replicas explicitly and forcibly
	IsolationLevel       string   `protobuf:"bytes,11,opt,name=isolationLevel,proto3" json:"isolationLevel,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlacementRule) Reset()         { *m = PlacementRule{} }
func (m *PlacementRule) String() string { return proto.CompactTextString(m) }
func (*PlacementRule) ProtoMessage()    {}
func (*PlacementRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{52}
}
func (m *PlacementRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlacementRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlacementRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlacementRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlacementRule.Merge(m, src)
}
func (m *PlacementRule) XXX_Size() int {
	return m.Size()
}
func (m *PlacementRule) XXX_DiscardUnknown() {
	xxx_messageInfo_PlacementRule.DiscardUnknown(m)
}

var xxx_messageInfo_PlacementRule proto.InternalMessageInfo

func (m *PlacementRule) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *PlacementRule) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

func (m *PlacementRule) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *PlacementRule) GetOverride() bool {
	if m != nil {
		return m.Override
	}
	return false
}

func (m *PlacementRule) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *PlacementRule) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *PlacementRule) GetRole() ReplicaRoleType {
	if m != nil {
		return m.Role
	}
	return Voter
}

func (m *PlacementRule) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *PlacementRule) GetLabelConstraints() []LabelConstraint {
	if m != nil {
		return m.LabelConstraints
	}
	return nil
}

func (m *PlacementRule) GetLocationLabels() []string {
	if m != nil {
		return m.LocationLabels
	}
	return nil
}

func (m *PlacementRule) GetIsolationLevel() string {
	if m != nil {
		return m.IsolationLevel
	}
	return ""
}

// RequestHeader raft request header, it contains the shard's metadata
type RequestBatchHeader struct {
	ID                   []byte         `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	ShardID              uint64         `protobuf:"varint,2,opt,name=shardID,proto3" json:"shardID,omitempty"`
	Replica              metapb.Replica `protobuf:"bytes,3,opt,name=replica,proto3" json:"replica"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *RequestBatchHeader) Reset()         { *m = RequestBatchHeader{} }
func (m *RequestBatchHeader) String() string { return proto.CompactTextString(m) }
func (*RequestBatchHeader) ProtoMessage()    {}
func (*RequestBatchHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{53}
}
func (m *RequestBatchHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestBatchHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestBatchHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestBatchHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestBatchHeader.Merge(m, src)
}
func (m *RequestBatchHeader) XXX_Size() int {
	return m.Size()
}
func (m *RequestBatchHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestBatchHeader.DiscardUnknown(m)
}

var xxx_messageInfo_RequestBatchHeader proto.InternalMessageInfo

func (m *RequestBatchHeader) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *RequestBatchHeader) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *RequestBatchHeader) GetReplica() metapb.Replica {
	if m != nil {
		return m.Replica
	}
	return metapb.Replica{}
}

type ResponseBatchHeader struct {
	ID                   []byte        `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Error                errorpb.Error `protobuf:"bytes,2,opt,name=error,proto3" json:"error"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ResponseBatchHeader) Reset()         { *m = ResponseBatchHeader{} }
func (m *ResponseBatchHeader) String() string { return proto.CompactTextString(m) }
func (*ResponseBatchHeader) ProtoMessage()    {}
func (*ResponseBatchHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{54}
}
func (m *ResponseBatchHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseBatchHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseBatchHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseBatchHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseBatchHeader.Merge(m, src)
}
func (m *ResponseBatchHeader) XXX_Size() int {
	return m.Size()
}
func (m *ResponseBatchHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseBatchHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseBatchHeader proto.InternalMessageInfo

func (m *ResponseBatchHeader) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *ResponseBatchHeader) GetError() errorpb.Error {
	if m != nil {
		return m.Error
	}
	return errorpb.Error{}
}

// RequestBatch we can't include both normal requests and administrator request
// at same time.
type RequestBatch struct {
	Header               RequestBatchHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Requests             []Request          `protobuf:"bytes,2,rep,name=requests,proto3" json:"requests"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *RequestBatch) Reset()         { *m = RequestBatch{} }
func (m *RequestBatch) String() string { return proto.CompactTextString(m) }
func (*RequestBatch) ProtoMessage()    {}
func (*RequestBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{55}
}
func (m *RequestBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestBatch.Merge(m, src)
}
func (m *RequestBatch) XXX_Size() int {
	return m.Size()
}
func (m *RequestBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestBatch.DiscardUnknown(m)
}

var xxx_messageInfo_RequestBatch proto.InternalMessageInfo

func (m *RequestBatch) GetHeader() RequestBatchHeader {
	if m != nil {
		return m.Header
	}
	return RequestBatchHeader{}
}

func (m *RequestBatch) GetRequests() []Request {
	if m != nil {
		return m.Requests
	}
	return nil
}

// ResponseBatch response batch
type ResponseBatch struct {
	Header               ResponseBatchHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Responses            []Response          `protobuf:"bytes,2,rep,name=responses,proto3" json:"responses"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ResponseBatch) Reset()         { *m = ResponseBatch{} }
func (m *ResponseBatch) String() string { return proto.CompactTextString(m) }
func (*ResponseBatch) ProtoMessage()    {}
func (*ResponseBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{56}
}
func (m *ResponseBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseBatch.Merge(m, src)
}
func (m *ResponseBatch) XXX_Size() int {
	return m.Size()
}
func (m *ResponseBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseBatch.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseBatch proto.InternalMessageInfo

func (m *ResponseBatch) GetHeader() ResponseBatchHeader {
	if m != nil {
		return m.Header
	}
	return ResponseBatchHeader{}
}

func (m *ResponseBatch) GetResponses() []Response {
	if m != nil {
		return m.Responses
	}
	return nil
}

// Request request
type Request struct {
	ID                   []byte            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Group                uint64            `protobuf:"varint,2,opt,name=group,proto3" json:"group,omitempty"`
	Type                 CmdType           `protobuf:"varint,3,opt,name=type,proto3,enum=rpcpb.CmdType" json:"type,omitempty"`
	CustomType           uint64            `protobuf:"varint,4,opt,name=customType,proto3" json:"customType,omitempty"`
	Key                  []byte            `protobuf:"bytes,5,opt,name=key,proto3" json:"key,omitempty"`
	Cmd                  []byte            `protobuf:"bytes,6,opt,name=cmd,proto3" json:"cmd,omitempty"`
	PID                  int64             `protobuf:"varint,7,opt,name=pid,proto3" json:"pid,omitempty"`
	StopAt               int64             `protobuf:"varint,8,opt,name=stopAt,proto3" json:"stopAt,omitempty"`
	ToShard              uint64            `protobuf:"varint,9,opt,name=toShard,proto3" json:"toShard,omitempty"`
	IgnoreEpochCheck     bool              `protobuf:"varint,10,opt,name=ignoreEpochCheck,proto3" json:"ignoreEpochCheck,omitempty"`
	Epoch                metapb.ShardEpoch `protobuf:"bytes,11,opt,name=epoch,proto3" json:"epoch"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{57}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *Request) GetGroup() uint64 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *Request) GetType() CmdType {
	if m != nil {
		return m.Type
	}
	return Write
}

func (m *Request) GetCustomType() uint64 {
	if m != nil {
		return m.CustomType
	}
	return 0
}

func (m *Request) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Request) GetCmd() []byte {
	if m != nil {
		return m.Cmd
	}
	return nil
}

func (m *Request) GetPID() int64 {
	if m != nil {
		return m.PID
	}
	return 0
}

func (m *Request) GetStopAt() int64 {
	if m != nil {
		return m.StopAt
	}
	return 0
}

func (m *Request) GetToShard() uint64 {
	if m != nil {
		return m.ToShard
	}
	return 0
}

func (m *Request) GetIgnoreEpochCheck() bool {
	if m != nil {
		return m.IgnoreEpochCheck
	}
	return false
}

func (m *Request) GetEpoch() metapb.ShardEpoch {
	if m != nil {
		return m.Epoch
	}
	return metapb.ShardEpoch{}
}

// Response response
type Response struct {
	ID                   []byte        `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Type                 CmdType       `protobuf:"varint,2,opt,name=type,proto3,enum=rpcpb.CmdType" json:"type,omitempty"`
	CustomType           uint64        `protobuf:"varint,3,opt,name=customType,proto3" json:"customType,omitempty"`
	Value                []byte        `protobuf:"bytes,4,opt,name=value,proto3" json:"value,omitempty"`
	PID                  int64         `protobuf:"varint,5,opt,name=pid,proto3" json:"pid,omitempty"`
	Error                errorpb.Error `protobuf:"bytes,6,opt,name=error,proto3" json:"error"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{58}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *Response) GetType() CmdType {
	if m != nil {
		return m.Type
	}
	return Write
}

func (m *Response) GetCustomType() uint64 {
	if m != nil {
		return m.CustomType
	}
	return 0
}

func (m *Response) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Response) GetPID() int64 {
	if m != nil {
		return m.PID
	}
	return 0
}

func (m *Response) GetError() errorpb.Error {
	if m != nil {
		return m.Error
	}
	return errorpb.Error{}
}

type ConfigChangeRequest struct {
	// This can be only called in internal RaftStore now.
	ChangeType           metapb.ConfigChangeType `protobuf:"varint,1,opt,name=changeType,proto3,enum=metapb.ConfigChangeType" json:"changeType,omitempty"`
	Replica              metapb.Replica          `protobuf:"bytes,2,opt,name=replica,proto3" json:"replica"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *ConfigChangeRequest) Reset()         { *m = ConfigChangeRequest{} }
func (m *ConfigChangeRequest) String() string { return proto.CompactTextString(m) }
func (*ConfigChangeRequest) ProtoMessage()    {}
func (*ConfigChangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{59}
}
func (m *ConfigChangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigChangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigChangeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigChangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigChangeRequest.Merge(m, src)
}
func (m *ConfigChangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *ConfigChangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigChangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigChangeRequest proto.InternalMessageInfo

func (m *ConfigChangeRequest) GetChangeType() metapb.ConfigChangeType {
	if m != nil {
		return m.ChangeType
	}
	return metapb.ConfigChangeType_AddNode
}

func (m *ConfigChangeRequest) GetReplica() metapb.Replica {
	if m != nil {
		return m.Replica
	}
	return metapb.Replica{}
}

// ConfigChangeResponse change peer response
type ConfigChangeResponse struct {
	Shard                metapb.Shard `protobuf:"bytes,1,opt,name=shard,proto3" json:"shard"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ConfigChangeResponse) Reset()         { *m = ConfigChangeResponse{} }
func (m *ConfigChangeResponse) String() string { return proto.CompactTextString(m) }
func (*ConfigChangeResponse) ProtoMessage()    {}
func (*ConfigChangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{60}
}
func (m *ConfigChangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigChangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigChangeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigChangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigChangeResponse.Merge(m, src)
}
func (m *ConfigChangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *ConfigChangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigChangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigChangeResponse proto.InternalMessageInfo

func (m *ConfigChangeResponse) GetShard() metapb.Shard {
	if m != nil {
		return m.Shard
	}
	return metapb.Shard{}
}

// CompactLogRequest compact raft log
type CompactLogRequest struct {
	CompactIndex         uint64   `protobuf:"varint,1,opt,name=compactIndex,proto3" json:"compactIndex,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CompactLogRequest) Reset()         { *m = CompactLogRequest{} }
func (m *CompactLogRequest) String() string { return proto.CompactTextString(m) }
func (*CompactLogRequest) ProtoMessage()    {}
func (*CompactLogRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{61}
}
func (m *CompactLogRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactLogRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactLogRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompactLogRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactLogRequest.Merge(m, src)
}
func (m *CompactLogRequest) XXX_Size() int {
	return m.Size()
}
func (m *CompactLogRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactLogRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CompactLogRequest proto.InternalMessageInfo

func (m *CompactLogRequest) GetCompactIndex() uint64 {
	if m != nil {
		return m.CompactIndex
	}
	return 0
}

// CompactLogResponse compact raft log
type CompactLogResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CompactLogResponse) Reset()         { *m = CompactLogResponse{} }
func (m *CompactLogResponse) String() string { return proto.CompactTextString(m) }
func (*CompactLogResponse) ProtoMessage()    {}
func (*CompactLogResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{62}
}
func (m *CompactLogResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactLogResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactLogResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompactLogResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactLogResponse.Merge(m, src)
}
func (m *CompactLogResponse) XXX_Size() int {
	return m.Size()
}
func (m *CompactLogResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactLogResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CompactLogResponse proto.InternalMessageInfo

// TransferLeaderRequest transfer leader
type TransferLeaderRequest struct {
	Replica              metapb.Replica `protobuf:"bytes,1,opt,name=replica,proto3" json:"replica"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TransferLeaderRequest) Reset()         { *m = TransferLeaderRequest{} }
func (m *TransferLeaderRequest) String() string { return proto.CompactTextString(m) }
func (*TransferLeaderRequest) ProtoMessage()    {}
func (*TransferLeaderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{63}
}
func (m *TransferLeaderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferLeaderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferLeaderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferLeaderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferLeaderRequest.Merge(m, src)
}
func (m *TransferLeaderRequest) XXX_Size() int {
	return m.Size()
}
func (m *TransferLeaderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferLeaderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TransferLeaderRequest proto.InternalMessageInfo

func (m *TransferLeaderRequest) GetReplica() metapb.Replica {
	if m != nil {
		return m.Replica
	}
	return metapb.Replica{}
}

type TransferLeaderResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TransferLeaderResponse) Reset()         { *m = TransferLeaderResponse{} }
func (m *TransferLeaderResponse) String() string { return proto.CompactTextString(m) }
func (*TransferLeaderResponse) ProtoMessage()    {}
func (*TransferLeaderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{64}
}
func (m *TransferLeaderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferLeaderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferLeaderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferLeaderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferLeaderResponse.Merge(m, src)
}
func (m *TransferLeaderResponse) XXX_Size() int {
	return m.Size()
}
func (m *TransferLeaderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferLeaderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TransferLeaderResponse proto.InternalMessageInfo

type VerifyHashRequest struct {
	Index                uint64   `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Hash                 []byte   `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	Context              []byte   `protobuf:"bytes,3,opt,name=context,proto3" json:"context,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VerifyHashRequest) Reset()         { *m = VerifyHashRequest{} }
func (m *VerifyHashRequest) String() string { return proto.CompactTextString(m) }
func (*VerifyHashRequest) ProtoMessage()    {}
func (*VerifyHashRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{65}
}
func (m *VerifyHashRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyHashRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyHashRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyHashRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyHashRequest.Merge(m, src)
}
func (m *VerifyHashRequest) XXX_Size() int {
	return m.Size()
}
func (m *VerifyHashRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyHashRequest.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyHashRequest proto.InternalMessageInfo

func (m *VerifyHashRequest) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *VerifyHashRequest) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

func (m *VerifyHashRequest) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

type VerifyHashResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *VerifyHashResponse) Reset()         { *m = VerifyHashResponse{} }
func (m *VerifyHashResponse) String() string { return proto.CompactTextString(m) }
func (*VerifyHashResponse) ProtoMessage()    {}
func (*VerifyHashResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{66}
}
func (m *VerifyHashResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VerifyHashResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VerifyHashResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VerifyHashResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VerifyHashResponse.Merge(m, src)
}
func (m *VerifyHashResponse) XXX_Size() int {
	return m.Size()
}
func (m *VerifyHashResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VerifyHashResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VerifyHashResponse proto.InternalMessageInfo

// BatchSplitRequest batch split requests.
type BatchSplitRequest struct {
	// The requests for splitting a shard into multiple shards.
	// We split Shard A [0, 10) into B [0, 5) and C [5, 10), the len(requests) = 2, and
	// Shard A will not used after split completed.
	Requests             []SplitRequest `protobuf:"bytes,1,rep,name=requests,proto3" json:"requests"`
	Context              []byte         `protobuf:"bytes,2,opt,name=context,proto3" json:"context,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *BatchSplitRequest) Reset()         { *m = BatchSplitRequest{} }
func (m *BatchSplitRequest) String() string { return proto.CompactTextString(m) }
func (*BatchSplitRequest) ProtoMessage()    {}
func (*BatchSplitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{67}
}
func (m *BatchSplitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSplitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSplitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSplitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSplitRequest.Merge(m, src)
}
func (m *BatchSplitRequest) XXX_Size() int {
	return m.Size()
}
func (m *BatchSplitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSplitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSplitRequest proto.InternalMessageInfo

func (m *BatchSplitRequest) GetRequests() []SplitRequest {
	if m != nil {
		return m.Requests
	}
	return nil
}

func (m *BatchSplitRequest) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

type SplitRequest struct {
	// The start of the sub shard range
	Start []byte `protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"`
	// The end of the sub shard range
	End []byte `protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`
	// The new shard id
	NewShardID uint64 `protobuf:"varint,3,opt,name=newShardID,proto3" json:"newShardID,omitempty"`
	// The new replicas of the new shard
	NewReplicas          []metapb.Replica `protobuf:"bytes,4,rep,name=newReplicas,proto3" json:"newReplicas"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SplitRequest) Reset()         { *m = SplitRequest{} }
func (m *SplitRequest) String() string { return proto.CompactTextString(m) }
func (*SplitRequest) ProtoMessage()    {}
func (*SplitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{68}
}
func (m *SplitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitRequest.Merge(m, src)
}
func (m *SplitRequest) XXX_Size() int {
	return m.Size()
}
func (m *SplitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SplitRequest proto.InternalMessageInfo

func (m *SplitRequest) GetStart() []byte {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *SplitRequest) GetEnd() []byte {
	if m != nil {
		return m.End
	}
	return nil
}

func (m *SplitRequest) GetNewShardID() uint64 {
	if m != nil {
		return m.NewShardID
	}
	return 0
}

func (m *SplitRequest) GetNewReplicas() []metapb.Replica {
	if m != nil {
		return m.NewReplicas
	}
	return nil
}

type BatchSplitResponse struct {
	Shards               []metapb.Shard `protobuf:"bytes,1,rep,name=shards,proto3" json:"shards"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *BatchSplitResponse) Reset()         { *m = BatchSplitResponse{} }
func (m *BatchSplitResponse) String() string { return proto.CompactTextString(m) }
func (*BatchSplitResponse) ProtoMessage()    {}
func (*BatchSplitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{69}
}
func (m *BatchSplitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSplitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSplitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSplitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSplitResponse.Merge(m, src)
}
func (m *BatchSplitResponse) XXX_Size() int {
	return m.Size()
}
func (m *BatchSplitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSplitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSplitResponse proto.InternalMessageInfo

func (m *BatchSplitResponse) GetShards() []metapb.Shard {
	if m != nil {
		return m.Shards
	}
	return nil
}

type UpdateMetadataRequest struct {
	Metadata             metapb.ShardLocalState `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *UpdateMetadataRequest) Reset()         { *m = UpdateMetadataRequest{} }
func (m *UpdateMetadataRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateMetadataRequest) ProtoMessage()    {}
func (*UpdateMetadataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{70}
}
func (m *UpdateMetadataRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateMetadataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateMetadataRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateMetadataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateMetadataRequest.Merge(m, src)
}
func (m *UpdateMetadataRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateMetadataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateMetadataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateMetadataRequest proto.InternalMessageInfo

func (m *UpdateMetadataRequest) GetMetadata() metapb.ShardLocalState {
	if m != nil {
		return m.Metadata
	}
	return metapb.ShardLocalState{}
}

type UpdateMetadataResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateMetadataResponse) Reset()         { *m = UpdateMetadataResponse{} }
func (m *UpdateMetadataResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateMetadataResponse) ProtoMessage()    {}
func (*UpdateMetadataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{71}
}
func (m *UpdateMetadataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateMetadataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateMetadataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateMetadataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateMetadataResponse.Merge(m, src)
}
func (m *UpdateMetadataResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateMetadataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateMetadataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateMetadataResponse proto.InternalMessageInfo

type UpdateLabelsRequest struct {
	Labels               []metapb.Label `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels"`
	Policy               UpdatePolicy   `protobuf:"varint,2,opt,name=policy,proto3,enum=rpcpb.UpdatePolicy" json:"policy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *UpdateLabelsRequest) Reset()         { *m = UpdateLabelsRequest{} }
func (m *UpdateLabelsRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateLabelsRequest) ProtoMessage()    {}
func (*UpdateLabelsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{72}
}
func (m *UpdateLabelsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateLabelsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateLabelsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateLabelsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateLabelsRequest.Merge(m, src)
}
func (m *UpdateLabelsRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateLabelsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateLabelsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateLabelsRequest proto.InternalMessageInfo

func (m *UpdateLabelsRequest) GetLabels() []metapb.Label {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *UpdateLabelsRequest) GetPolicy() UpdatePolicy {
	if m != nil {
		return m.Policy
	}
	return Add
}

type UpdateLabelsResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateLabelsResponse) Reset()         { *m = UpdateLabelsResponse{} }
func (m *UpdateLabelsResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateLabelsResponse) ProtoMessage()    {}
func (*UpdateLabelsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{73}
}
func (m *UpdateLabelsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateLabelsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateLabelsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateLabelsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateLabelsResponse.Merge(m, src)
}
func (m *UpdateLabelsResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateLabelsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateLabelsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateLabelsResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("rpcpb.Type", Type_name, Type_value)
	proto.RegisterEnum("rpcpb.ReplicaRoleType", ReplicaRoleType_name, ReplicaRoleType_value)
	proto.RegisterEnum("rpcpb.LabelConstraintOp", LabelConstraintOp_name, LabelConstraintOp_value)
	proto.RegisterEnum("rpcpb.CmdType", CmdType_name, CmdType_value)
	proto.RegisterEnum("rpcpb.AdminCmdType", AdminCmdType_name, AdminCmdType_value)
	proto.RegisterEnum("rpcpb.UpdatePolicy", UpdatePolicy_name, UpdatePolicy_value)
	proto.RegisterType((*ProphetRequest)(nil), "rpcpb.ProphetRequest")
	proto.RegisterType((*ProphetResponse)(nil), "rpcpb.ProphetResponse")
	proto.RegisterType((*ShardHeartbeatReq)(nil), "rpcpb.ShardHeartbeatReq")
	proto.RegisterType((*ShardHeartbeatRsp)(nil), "rpcpb.ShardHeartbeatRsp")
	proto.RegisterType((*PutStoreReq)(nil), "rpcpb.PutStoreReq")
	proto.RegisterType((*PutStoreRsp)(nil), "rpcpb.PutStoreRsp")
	proto.RegisterType((*StoreHeartbeatReq)(nil), "rpcpb.StoreHeartbeatReq")
	proto.RegisterType((*StoreHeartbeatRsp)(nil), "rpcpb.StoreHeartbeatRsp")
	proto.RegisterType((*GetStoreReq)(nil), "rpcpb.GetStoreReq")
	proto.RegisterType((*GetStoreRsp)(nil), "rpcpb.GetStoreRsp")
	proto.RegisterType((*AllocIDReq)(nil), "rpcpb.AllocIDReq")
	proto.RegisterType((*AllocIDRsp)(nil), "rpcpb.AllocIDRsp")
	proto.RegisterType((*AskBatchSplitReq)(nil), "rpcpb.AskBatchSplitReq")
	proto.RegisterType((*AskBatchSplitRsp)(nil), "rpcpb.AskBatchSplitRsp")
	proto.RegisterType((*CreateDestroyingReq)(nil), "rpcpb.CreateDestroyingReq")
	proto.RegisterType((*CreateDestroyingRsp)(nil), "rpcpb.CreateDestroyingRsp")
	proto.RegisterType((*GetDestroyingReq)(nil), "rpcpb.GetDestroyingReq")
	proto.RegisterType((*GetDestroyingRsp)(nil), "rpcpb.GetDestroyingRsp")
	proto.RegisterType((*ReportDestroyedReq)(nil), "rpcpb.ReportDestroyedReq")
	proto.RegisterType((*ReportDestroyedRsp)(nil), "rpcpb.ReportDestroyedRsp")
	proto.RegisterType((*SplitID)(nil), "rpcpb.SplitID")
	proto.RegisterType((*CreateWatcherReq)(nil), "rpcpb.CreateWatcherReq")
	proto.RegisterType((*CreateShardsReq)(nil), "rpcpb.CreateShardsReq")
	proto.RegisterType((*CreateShardsRsp)(nil), "rpcpb.CreateShardsRsp")
	proto.RegisterType((*RemoveShardsReq)(nil), "rpcpb.RemoveShardsReq")
	proto.RegisterType((*RemoveShardsRsp)(nil), "rpcpb.RemoveShardsRsp")
	proto.RegisterType((*CheckShardStateReq)(nil), "rpcpb.CheckShardStateReq")
	proto.RegisterType((*CheckShardStateRsp)(nil), "rpcpb.CheckShardStateRsp")
	proto.RegisterType((*PutPlacementRuleReq)(nil), "rpcpb.PutPlacementRuleReq")
	proto.RegisterType((*PutPlacementRuleRsp)(nil), "rpcpb.PutPlacementRuleRsp")
	proto.RegisterType((*GetAppliedRulesReq)(nil), "rpcpb.GetAppliedRulesReq")
	proto.RegisterType((*GetAppliedRulesRsp)(nil), "rpcpb.GetAppliedRulesRsp")
	proto.RegisterType((*CreateJobReq)(nil), "rpcpb.CreateJobReq")
	proto.RegisterType((*CreateJobRsp)(nil), "rpcpb.CreateJobRsp")
	proto.RegisterType((*RemoveJobReq)(nil), "rpcpb.RemoveJobReq")
	proto.RegisterType((*RemoveJobRsp)(nil), "rpcpb.RemoveJobRsp")
	proto.RegisterType((*ExecuteJobReq)(nil), "rpcpb.ExecuteJobReq")
	proto.RegisterType((*ExecuteJobRsp)(nil), "rpcpb.ExecuteJobRsp")
	proto.RegisterType((*AddScheduleGroupRuleReq)(nil), "rpcpb.AddScheduleGroupRuleReq")
	proto.RegisterType((*AddScheduleGroupRuleRsp)(nil), "rpcpb.AddScheduleGroupRuleRsp")
	proto.RegisterType((*GetScheduleGroupRuleReq)(nil), "rpcpb.GetScheduleGroupRuleReq")
	proto.RegisterType((*GetScheduleGroupRuleRsp)(nil), "rpcpb.GetScheduleGroupRuleRsp")
	proto.RegisterType((*EventNotify)(nil), "rpcpb.EventNotify")
	proto.RegisterType((*InitEventData)(nil), "rpcpb.InitEventData")
	proto.RegisterType((*ShardEventData)(nil), "rpcpb.ShardEventData")
	proto.RegisterType((*StoreEventData)(nil), "rpcpb.StoreEventData")
	proto.RegisterType((*ConfigChange)(nil), "rpcpb.ConfigChange")
	proto.RegisterType((*TransferLeader)(nil), "rpcpb.TransferLeader")
	proto.RegisterType((*ConfigChangeV2)(nil), "rpcpb.ConfigChangeV2")
	proto.RegisterType((*Merge)(nil), "rpcpb.Merge")
	proto.RegisterType((*SplitShard)(nil), "rpcpb.SplitShard")
	proto.RegisterType((*LabelConstraint)(nil), "rpcpb.LabelConstraint")
	proto.RegisterType((*PlacementRule)(nil), "rpcpb.PlacementRule")
	proto.RegisterType((*RequestBatchHeader)(nil), "rpcpb.RequestBatchHeader")
	proto.RegisterType((*ResponseBatchHeader)(nil), "rpcpb.ResponseBatchHeader")
	proto.RegisterType((*RequestBatch)(nil), "rpcpb.RequestBatch")
	proto.RegisterType((*ResponseBatch)(nil), "rpcpb.ResponseBatch")
	proto.RegisterType((*Request)(nil), "rpcpb.Request")
	proto.RegisterType((*Response)(nil), "rpcpb.Response")
	proto.RegisterType((*ConfigChangeRequest)(nil), "rpcpb.ConfigChangeRequest")
	proto.RegisterType((*ConfigChangeResponse)(nil), "rpcpb.ConfigChangeResponse")
	proto.RegisterType((*CompactLogRequest)(nil), "rpcpb.CompactLogRequest")
	proto.RegisterType((*CompactLogResponse)(nil), "rpcpb.CompactLogResponse")
	proto.RegisterType((*TransferLeaderRequest)(nil), "rpcpb.TransferLeaderRequest")
	proto.RegisterType((*TransferLeaderResponse)(nil), "rpcpb.TransferLeaderResponse")
	proto.RegisterType((*VerifyHashRequest)(nil), "rpcpb.VerifyHashRequest")
	proto.RegisterType((*VerifyHashResponse)(nil), "rpcpb.VerifyHashResponse")
	proto.RegisterType((*BatchSplitRequest)(nil), "rpcpb.BatchSplitRequest")
	proto.RegisterType((*SplitRequest)(nil), "rpcpb.SplitRequest")
	proto.RegisterType((*BatchSplitResponse)(nil), "rpcpb.BatchSplitResponse")
	proto.RegisterType((*UpdateMetadataRequest)(nil), "rpcpb.UpdateMetadataRequest")
	proto.RegisterType((*UpdateMetadataResponse)(nil), "rpcpb.UpdateMetadataResponse")
	proto.RegisterType((*UpdateLabelsRequest)(nil), "rpcpb.UpdateLabelsRequest")
	proto.RegisterType((*UpdateLabelsResponse)(nil), "rpcpb.UpdateLabelsResponse")
}

func init() { proto.RegisterFile("rpcpb.proto", fileDescriptor_25e491924c678914) }

var fileDescriptor_25e491924c678914 = []byte{
	// 3264 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x5a, 0xcb, 0x72, 0xdc, 0xc6,
	0xd5, 0xd6, 0xdc, 0x67, 0xce, 0x5c, 0xd8, 0x6c, 0x0e, 0x49, 0x48, 0xf6, 0x4f, 0xe9, 0x87, 0x64,
	0x9b, 0xa6, 0xff, 0x9f, 0x8a, 0xa5, 0xa8, 0x64, 0x27, 0x8e, 0x1d, 0x8a, 0xa4, 0x25, 0xca, 0xb2,
	0xac, 0x02, 0x1d, 0x29, 0x5e, 0x82, 0x33, 0xad, 0x21, 0xa2, 0x21, 0xd0, 0x46, 0x63, 0x24, 0x71,
	0x93, 0xa4, 0x2a, 0x0f, 0x90, 0x6d, 0x9e, 0x20, 0x2f, 0x92, 0x2c, 0xbc, 0x49, 0x95, 0xb3, 0xc9,
	0xd2, 0x95, 0xe8, 0x49, 0x52, 0x7d, 0x03, 0xba, 0x31, 0xc0, 0x70, 0xb4, 0x22, 0xce, 0xb5, 0xbb,
	0x4f, 0x77, 0x7f, 0x7d, 0xce, 0x19, 0x42, 0x37, 0xa6, 0x23, 0x7a, 0xb2, 0x4b, 0xe3, 0x28, 0x89,
	0x70, 0x43, 0x10, 0x57, 0x7e, 0x39, 0x09, 0x92, 0xd3, 0xd9, 0xc9, 0xee, 0x28, 0x3a, 0xbb, 0x79,
	0xe6, 0x27, 0x71, 0xf0, 0x3a, 0x8a, 0x83, 0x49, 0x10, 0x2a, 0x62, 0x34, 0x3b, 0x21, 0x37, 0xe9,
	0xc9, 0x4d, 0x12, 0xc7, 0x51, 0x9c, 0xfd, 0x95, 0x3e, 0xae, 0x7c, 0xba, 0x9c, 0xf1, 0x19, 0x49,
	0xfc, 0xf4, 0x8f, 0x32, 0xfd, 0x7f, 0xc3, 0x74, 0x12, 0x4d, 0xa2, 0x9b, 0x82, 0x7d, 0x32, 0x7b,
	0x2e, 0x28, 0x41, 0x88, 0x2f, 0xa9, 0xee, 0xfe, 0xbd, 0x0b, 0x83, 0x27, 0x71, 0x44, 0x4f, 0x49,
	0xe2, 0x91, 0xef, 0x67, 0x84, 0x25, 0x78, 0x03, 0xaa, 0xc1, 0xd8, 0xa9, 0x5c, 0xab, 0x6c, 0xd7,
	0xef, 0x35, 0xdf, 0xfc, 0x74, 0xb5, 0x7a, 0x74, 0xe0, 0x55, 0x83, 0x31, 0x76, 0xa0, 0xc5, 0x92,
	0x28, 0x26, 0x47, 0x07, 0x4e, 0x95, 0x0b, 0x3d, 0x4d, 0xe2, 0xab, 0x50, 0x4f, 0xce, 0x29, 0x71,
	0x6a, 0xd7, 0x2a, 0xdb, 0x83, 0x5b, 0xdd, 0x5d, 0x19, 0x8e, 0x6f, 0xcf, 0x29, 0xf1, 0x84, 0x00,
	0x7f, 0x09, 0x03, 0x76, 0xea, 0xc7, 0xe3, 0x07, 0xc4, 0x8f, 0x93, 0x13, 0xe2, 0x27, 0x4e, 0xfd,
	0x5a, 0x65, 0xbb, 0x7b, 0xcb, 0x51, 0xaa, 0xc7, 0x96, 0xd0, 0x23, 0xdf, 0xdf, 0xab, 0xff, 0xf0,
	0xd3, 0xd5, 0x4b, 0x5e, 0xce, 0x4a, 0xf8, 0xe1, 0x63, 0x66, 0x7e, 0x1a, 0xb6, 0x1f, 0x4b, 0x68,
	0xfa, 0xb1, 0x04, 0xf8, 0xe7, 0xd0, 0xa6, 0xb3, 0x44, 0x68, 0x3b, 0x4d, 0xe1, 0x01, 0x2b, 0x0f,
	0x4f, 0x14, 0x3b, 0xb3, 0x4d, 0x35, 0xb9, 0xd5, 0x84, 0x28, 0xab, 0x96, 0x65, 0x75, 0x9f, 0xcc,
	0x59, 0x69, 0x4d, 0xfc, 0x31, 0xb4, 0xfc, 0xe9, 0x34, 0x1a, 0x1d, 0x1d, 0x38, 0x6d, 0x61, 0xb4,
	0xaa, 0x8c, 0xf6, 0x24, 0x37, 0xb3, 0xd1, 0x7a, 0x78, 0x1f, 0xfa, 0x3e, 0x7b, 0x71, 0xcf, 0x4f,
	0x46, 0xa7, 0xc7, 0x74, 0x1a, 0x24, 0x4e, 0x47, 0x18, 0x6e, 0x6a, 0x43, 0x53, 0x96, 0x99, 0xdb,
	0x36, 0xf8, 0x11, 0xa0, 0x51, 0x4c, 0xfc, 0x84, 0x1c, 0x10, 0x96, 0xc4, 0xd1, 0x79, 0x10, 0x4e,
	0x1c, 0x10, 0x7e, 0xae, 0x28, 0x3f, 0xfb, 0x39, 0x71, 0xe6, 0x6a, 0xce, 0x12, 0x1f, 0xc1, 0x8a,
	0x47, 0x68, 0x14, 0x27, 0x8a, 0x47, 0xc6, 0x4e, 0x57, 0x38, 0xbb, 0xac, 0x9c, 0xe5, 0xa4, 0x99,
	0xaf, 0xbc, 0x1d, 0x5f, 0xdd, 0x84, 0x24, 0xc6, 0xac, 0x7a, 0xd6, 0xea, 0xee, 0x9b, 0x32, 0x63,
	0x75, 0x96, 0x0d, 0x77, 0x22, 0xe7, 0xf8, 0x8c, 0xaf, 0x98, 0xc4, 0x4e, 0xdf, 0x72, 0xb2, 0x6f,
	0xca, 0x0c, 0x27, 0x96, 0x0d, 0xfe, 0x35, 0xf4, 0x24, 0x43, 0x9c, 0x3f, 0xe6, 0x0c, 0x84, 0x8f,
	0x0d, 0xcb, 0x87, 0x14, 0x65, 0x2e, 0x2c, 0x0b, 0xee, 0x21, 0x26, 0x67, 0xd1, 0x4b, 0xed, 0x61,
	0xc5, 0xf2, 0xe0, 0x19, 0x22, 0xc3, 0x83, 0x69, 0xc1, 0x03, 0x3b, 0x3a, 0x25, 0xa3, 0x17, 0x82,
	0x3c, 0x4e, 0xfc, 0x84, 0x38, 0xc8, 0x0a, 0xec, 0xbe, 0x2d, 0x35, 0x02, 0x9b, 0xb3, 0xe3, 0x3b,
	0x4e, 0x67, 0xc9, 0x93, 0xa9, 0x3f, 0x22, 0x67, 0x24, 0x4c, 0xbc, 0xd9, 0x94, 0x38, 0xab, 0xd6,
	0x8e, 0x3f, 0xc9, 0x89, 0x8d, 0x1d, 0xcf, 0x5b, 0xf2, 0x89, 0x4d, 0x48, 0xb2, 0x47, 0xe9, 0x34,
	0x20, 0x63, 0xce, 0x61, 0x0e, 0xb6, 0x26, 0x76, 0xdf, 0x96, 0x1a, 0x13, 0xcb, 0xd9, 0xe1, 0xbb,
	0xd0, 0x91, 0x51, 0x7b, 0x18, 0x9d, 0x38, 0x6b, 0xc2, 0xc9, 0x9a, 0x15, 0xe4, 0x87, 0xd1, 0x49,
	0x66, 0x9e, 0xe9, 0x72, 0x43, 0x19, 0x2c, 0x6e, 0x38, 0xb4, 0x0c, 0x3d, 0xcd, 0x37, 0x0c, 0x53,
	0x5d, 0xfc, 0x0b, 0x00, 0xf2, 0x9a, 0x8c, 0x66, 0x72, 0xc8, 0x75, 0x61, 0x39, 0x54, 0x96, 0x87,
	0xa9, 0x20, 0x33, 0x35, 0xb4, 0xf1, 0x6f, 0x61, 0xe8, 0x8f, 0xc7, 0xc7, 0xa3, 0x53, 0x32, 0x9e,
	0x4d, 0xc9, 0xfd, 0x38, 0x9a, 0x51, 0x11, 0xca, 0x0d, 0xe1, 0x65, 0x4b, 0x5f, 0xc2, 0x02, 0x95,
	0xcc, 0x5f, 0xa1, 0x07, 0xee, 0x99, 0xc3, 0xc2, 0x9c, 0xe7, 0x4d, 0xcb, 0xf3, 0xfd, 0x02, 0x15,
	0xc3, 0x73, 0x91, 0x07, 0x0e, 0xe3, 0x2b, 0x29, 0x8c, 0x33, 0x1a, 0x85, 0x8c, 0x94, 0xe2, 0xb8,
	0x46, 0xeb, 0x6a, 0x19, 0x5a, 0x0f, 0xa1, 0x21, 0x9e, 0x23, 0x81, 0xe7, 0x1d, 0x4f, 0x12, 0x78,
	0x03, 0x9a, 0x53, 0xe2, 0x8f, 0x49, 0x2c, 0xb0, 0xbb, 0xe3, 0x29, 0xaa, 0x00, 0xdb, 0x1b, 0x8b,
	0xb0, 0x9d, 0xd1, 0xa5, 0xb1, 0xbd, 0xb9, 0x08, 0xdb, 0x0d, 0x3f, 0xe5, 0xd8, 0xde, 0x2a, 0xc6,
	0xf6, 0xd4, 0xb6, 0x18, 0xdb, 0xdb, 0xc5, 0xd8, 0x9e, 0x59, 0x15, 0x61, 0x7b, 0xa7, 0x10, 0xdb,
	0x53, 0x9b, 0x72, 0x6c, 0x87, 0x05, 0xd8, 0x9e, 0x9a, 0x2f, 0x81, 0xed, 0xdd, 0xc5, 0xd8, 0x9e,
	0xba, 0x5a, 0x0a, 0xdb, 0x7b, 0x0b, 0xb1, 0x3d, 0xf5, 0x75, 0x31, 0xb6, 0xf7, 0x17, 0x60, 0x7b,
	0xb6, 0x3a, 0x1b, 0xdb, 0x77, 0xa1, 0x41, 0x5e, 0x92, 0x30, 0x51, 0x78, 0xac, 0x37, 0xe2, 0x90,
	0xf3, 0x1e, 0x47, 0x49, 0xf0, 0xfc, 0x5c, 0xd9, 0x49, 0xb5, 0x39, 0x18, 0x5f, 0x29, 0x87, 0xf1,
	0x74, 0xc8, 0xc5, 0x30, 0x8e, 0xca, 0x61, 0x3c, 0xf3, 0x70, 0x11, 0x8c, 0xaf, 0x2e, 0x84, 0xf1,
	0x2c, 0x86, 0xcb, 0xc0, 0x38, 0x5e, 0x0c, 0xe3, 0xd9, 0xe6, 0x2e, 0x03, 0xe3, 0x6b, 0x0b, 0x61,
	0x3c, 0x9b, 0xd8, 0x42, 0x18, 0x1f, 0x96, 0xc0, 0x78, 0x6a, 0x5e, 0x06, 0xe3, 0xeb, 0x25, 0x30,
	0x9e, 0x19, 0x96, 0xc1, 0xf8, 0x46, 0x19, 0x8c, 0xa7, 0xa6, 0xcb, 0xc0, 0xf8, 0xe6, 0xc5, 0x30,
	0x9e, 0xfa, 0x7b, 0x3b, 0x18, 0x77, 0x2e, 0x86, 0xf1, 0xcc, 0x73, 0x21, 0x8c, 0xff, 0xa3, 0x0a,
	0xab, 0x73, 0xb9, 0xb0, 0x99, 0x78, 0x57, 0xec, 0xc4, 0x7b, 0x08, 0x0d, 0x81, 0xa2, 0x02, 0xcb,
	0x7b, 0x9e, 0x24, 0x30, 0x86, 0x7a, 0x42, 0xe2, 0x33, 0x01, 0xdf, 0x75, 0x4f, 0x7c, 0xe3, 0x0f,
	0x2c, 0xf4, 0xee, 0xde, 0x5a, 0xd9, 0x55, 0x55, 0x83, 0x47, 0xe8, 0x34, 0x18, 0xf9, 0x29, 0x9c,
	0x7f, 0x0e, 0xbd, 0x71, 0xf4, 0x2a, 0x54, 0x6c, 0xe6, 0x34, 0xae, 0xd5, 0x44, 0xd0, 0x6d, 0x75,
	0x7e, 0x52, 0x99, 0xbe, 0x08, 0xa6, 0x3e, 0xfe, 0x02, 0x56, 0x28, 0x09, 0xc7, 0x22, 0x77, 0x53,
	0x2e, 0x9a, 0xc2, 0x45, 0x7e, 0x44, 0x7d, 0xca, 0x72, 0xda, 0xfc, 0xf6, 0x33, 0xee, 0x3d, 0x05,
	0x6f, 0x65, 0x96, 0xde, 0x10, 0x3d, 0xae, 0x54, 0xc3, 0x57, 0xa0, 0x3d, 0xe1, 0x01, 0xfc, 0x8a,
	0x9c, 0x0b, 0xe4, 0xee, 0x78, 0x29, 0xed, 0xfe, 0xab, 0x36, 0x17, 0x4f, 0x46, 0x45, 0x3c, 0x39,
	0xd3, 0x88, 0xa7, 0x24, 0xf1, 0x27, 0x00, 0xe2, 0xf3, 0x90, 0x46, 0xa3, 0x53, 0x11, 0xd4, 0xfc,
	0x04, 0x84, 0x44, 0x9f, 0xb6, 0x4c, 0x17, 0xdf, 0x81, 0x7e, 0xe2, 0xc7, 0x13, 0xfe, 0xfc, 0x8a,
	0x75, 0x88, 0xe0, 0x17, 0x84, 0xd9, 0xd6, 0xc2, 0x77, 0xa1, 0x37, 0x8a, 0xc2, 0xe7, 0xc1, 0x64,
	0xff, 0xd4, 0x0f, 0x27, 0x44, 0x6d, 0x4e, 0x7a, 0xab, 0x0c, 0x91, 0x67, 0x29, 0xe2, 0x5f, 0xc1,
	0x20, 0x89, 0xfd, 0x90, 0x3d, 0x27, 0xf1, 0x23, 0xb9, 0xaf, 0xf2, 0xd5, 0x5d, 0xd7, 0xcf, 0xb9,
	0x25, 0xf4, 0x72, 0xca, 0xd8, 0x85, 0xc6, 0x19, 0x89, 0x27, 0xba, 0xfa, 0xe9, 0x29, 0xab, 0xaf,
	0x39, 0xcf, 0x93, 0x22, 0xfc, 0x31, 0x00, 0xe3, 0xaf, 0x8d, 0x58, 0xb7, 0xda, 0x0d, 0xfd, 0xbe,
	0x1d, 0xa7, 0x02, 0xcf, 0x50, 0xe2, 0xb3, 0x32, 0x67, 0xf9, 0xf4, 0x96, 0x7a, 0x4b, 0xd7, 0x0b,
	0x16, 0xf4, 0xf4, 0x96, 0x97, 0x53, 0xc6, 0xdb, 0xb0, 0x32, 0x96, 0xcf, 0xc0, 0x41, 0x10, 0x93,
	0x51, 0x32, 0x3d, 0x17, 0xcf, 0x6a, 0xdb, 0xcb, 0xb3, 0xdd, 0xeb, 0xd0, 0x35, 0x2a, 0x35, 0x71,
	0x0f, 0xc4, 0xd3, 0x5d, 0x51, 0xf7, 0x80, 0x13, 0xee, 0x6d, 0x43, 0x89, 0x51, 0x7c, 0x03, 0xfa,
	0xca, 0x8d, 0x42, 0x79, 0xa9, 0x6c, 0x33, 0xdd, 0x67, 0xb0, 0x3a, 0x57, 0x45, 0x66, 0x67, 0xb2,
	0x92, 0x3b, 0x12, 0x5c, 0xb3, 0xe0, 0x4c, 0x62, 0xa8, 0x8f, 0xfd, 0xc4, 0x57, 0xd7, 0x52, 0x7c,
	0xbb, 0x1f, 0xcc, 0x39, 0x66, 0x34, 0x55, 0xac, 0x18, 0x8a, 0xef, 0x41, 0xd7, 0xa8, 0x27, 0xcb,
	0xd2, 0x38, 0xf7, 0x2b, 0x43, 0xad, 0xd8, 0x13, 0xde, 0xd6, 0xd3, 0xae, 0x96, 0x4d, 0x5b, 0x4d,
	0xd8, 0xed, 0x01, 0x64, 0xe5, 0xa8, 0x7b, 0x23, 0xa3, 0x18, 0x2d, 0x9d, 0xc0, 0x67, 0x80, 0xf2,
	0x95, 0x68, 0xe1, 0x2c, 0x86, 0xd0, 0x18, 0x45, 0xb3, 0x30, 0x11, 0xb3, 0xe8, 0x7b, 0x92, 0x70,
	0x0f, 0xf2, 0xd6, 0x8c, 0xe2, 0x9f, 0x41, 0x5b, 0x1c, 0xa6, 0xa3, 0x03, 0x1e, 0x69, 0x0e, 0x1a,
	0x03, 0xf3, 0xbc, 0x1d, 0x1d, 0xe8, 0x04, 0x4c, 0x6b, 0xb9, 0x7f, 0x80, 0xb5, 0x82, 0x2a, 0xb6,
	0x34, 0xf5, 0x1d, 0x42, 0x23, 0x08, 0xc7, 0xe4, 0xb5, 0x6a, 0x60, 0x48, 0x82, 0x23, 0x48, 0xac,
	0xb1, 0xaa, 0x76, 0xad, 0xb6, 0x5d, 0xf7, 0x52, 0x1a, 0x6f, 0x01, 0xc8, 0xe7, 0xe8, 0x80, 0x2f,
	0xab, 0x2e, 0x4e, 0xa3, 0xc1, 0x71, 0xbf, 0x28, 0x98, 0x00, 0xa3, 0x3a, 0xf2, 0xf2, 0x40, 0x0e,
	0x0a, 0x40, 0x8c, 0xc8, 0xc8, 0x13, 0x77, 0x07, 0x50, 0xbe, 0xe2, 0x2d, 0x8d, 0xf8, 0x41, 0x5e,
	0x57, 0xc4, 0xac, 0xc9, 0x1d, 0xcd, 0xf4, 0xd9, 0x74, 0xf4, 0x50, 0x99, 0xda, 0xb1, 0x90, 0x7b,
	0x4a, 0xcf, 0x7d, 0x08, 0x78, 0xbe, 0x58, 0x2f, 0x0d, 0xd9, 0xbb, 0xfc, 0xed, 0x16, 0xc1, 0x48,
	0xfb, 0x3e, 0x19, 0xc3, 0xfd, 0x7c, 0xde, 0xd7, 0x5b, 0xad, 0xfe, 0x10, 0x5a, 0x6a, 0x6b, 0xf9,
	0xde, 0x84, 0xe4, 0x55, 0x8a, 0xc9, 0x92, 0xe0, 0x97, 0x36, 0x24, 0xaf, 0x3c, 0x3d, 0x20, 0x3f,
	0xca, 0x7c, 0x83, 0x6c, 0xa6, 0xfb, 0x3e, 0xa0, 0x7c, 0xc5, 0xcf, 0x8f, 0xe2, 0xf3, 0xa9, 0x3f,
	0x11, 0xee, 0xfa, 0x9e, 0xf8, 0x76, 0xbf, 0x81, 0x95, 0x5c, 0x55, 0xcf, 0xcb, 0x1a, 0xa6, 0xe1,
	0xa0, 0xb6, 0xdd, 0xf3, 0x14, 0xc5, 0x07, 0x9e, 0x12, 0x9f, 0x25, 0xe9, 0x2b, 0xa6, 0x06, 0xb6,
	0x98, 0xee, 0x6a, 0xce, 0x21, 0xa3, 0xee, 0xff, 0xf1, 0x6c, 0xda, 0xaa, 0xfb, 0xf1, 0x65, 0xa8,
	0x05, 0x6a, 0x80, 0xfa, 0xbd, 0xd6, 0x9b, 0x9f, 0xae, 0xd6, 0x8e, 0x0e, 0x98, 0xc7, 0x79, 0xdc,
	0x41, 0x2e, 0xbd, 0x74, 0x6f, 0x02, 0x9e, 0xaf, 0xf9, 0x33, 0x1f, 0x95, 0xed, 0x5e, 0xce, 0x87,
	0x37, 0x6f, 0xc0, 0x28, 0xdf, 0xb8, 0x71, 0x9a, 0xcf, 0xcb, 0xfb, 0x98, 0x31, 0xf8, 0xb9, 0x1e,
	0x67, 0x59, 0xba, 0xc4, 0x29, 0x83, 0xe3, 0x1e, 0xc2, 0x5a, 0x41, 0xb3, 0x00, 0xef, 0x42, 0x3d,
	0xe6, 0xa9, 0x4e, 0xc5, 0x4a, 0xc5, 0x2c, 0x35, 0x75, 0x47, 0x85, 0x9e, 0xbb, 0x5e, 0xe0, 0x86,
	0x51, 0x77, 0x17, 0xf0, 0x7c, 0xf7, 0xa0, 0xfc, 0x5d, 0x76, 0xbf, 0x9c, 0xd7, 0x17, 0x47, 0xbf,
	0x11, 0x8b, 0x84, 0xb6, 0xa2, 0x72, 0x94, 0xf2, 0xd9, 0x48, 0x45, 0xf7, 0x36, 0xf4, 0xcc, 0x86,
	0x03, 0xbe, 0x0e, 0xb5, 0xdf, 0x45, 0x27, 0x6a, 0x35, 0x5d, 0x7d, 0x4c, 0x1f, 0x46, 0x27, 0xca,
	0x8c, 0x4b, 0xdd, 0x81, 0x69, 0xc4, 0x28, 0x77, 0x62, 0x36, 0x1f, 0x96, 0x76, 0x62, 0xa6, 0xba,
	0xee, 0x03, 0xe8, 0x5b, 0x7d, 0x88, 0xa5, 0xbc, 0x14, 0xbe, 0x2b, 0xd7, 0x2d, 0x4f, 0x25, 0x6f,
	0xca, 0x63, 0xd8, 0x2c, 0x69, 0x58, 0xe0, 0xdb, 0xd6, 0x96, 0x5e, 0x4e, 0xef, 0x6a, 0x5e, 0xd7,
	0xda, 0xd7, 0xcb, 0x25, 0xfe, 0x18, 0xe5, 0xa2, 0x92, 0x0e, 0x86, 0xfb, 0xa4, 0x44, 0xc4, 0x28,
	0xbe, 0x63, 0xef, 0xe5, 0x85, 0xd3, 0x50, 0x1b, 0xfa, 0xcf, 0x2a, 0x74, 0x8d, 0xba, 0x10, 0x23,
	0xa8, 0x31, 0xf2, 0xbd, 0x3a, 0x3e, 0xfc, 0x53, 0x24, 0xc3, 0xba, 0xdb, 0xd1, 0x57, 0x0d, 0x8e,
	0x5b, 0xd0, 0x09, 0xc2, 0x20, 0x11, 0x86, 0x2a, 0x51, 0xd3, 0x87, 0xe7, 0x48, 0xf3, 0x39, 0xba,
	0x7b, 0x99, 0x1a, 0xbe, 0xa3, 0x53, 0x43, 0x61, 0x54, 0xb7, 0xd2, 0x9a, 0xe3, 0x54, 0x20, 0xac,
	0x0c, 0x45, 0x61, 0xc6, 0x5f, 0x5b, 0x69, 0x66, 0xe7, 0x68, 0xc7, 0xa9, 0x40, 0x99, 0xa5, 0x34,
	0xfe, 0x0c, 0x56, 0x58, 0x9a, 0xef, 0x4a, 0xdb, 0x66, 0x59, 0x3a, 0xec, 0xe5, 0x55, 0x85, 0x75,
	0xfa, 0xc4, 0x4b, 0xeb, 0x56, 0x69, 0x06, 0x90, 0x57, 0x75, 0xbf, 0x83, 0xbe, 0x15, 0x85, 0x52,
	0x88, 0x74, 0xa0, 0x25, 0x8b, 0x06, 0x0d, 0x8e, 0x9a, 0x14, 0x16, 0xdc, 0xab, 0x7c, 0x4f, 0xb9,
	0x85, 0xa0, 0xdc, 0x10, 0x06, 0x76, 0xac, 0x0a, 0x13, 0x86, 0xac, 0xd3, 0x24, 0xdf, 0x1b, 0x5d,
	0x9a, 0x38, 0xd0, 0x92, 0x2f, 0xef, 0x58, 0x6c, 0x5a, 0xdb, 0xd3, 0x24, 0xb7, 0x90, 0xd5, 0xa6,
	0x7a, 0xa1, 0x15, 0xe5, 0xde, 0x80, 0x81, 0x1d, 0xe4, 0xc2, 0xcb, 0x71, 0x0e, 0x3d, 0x33, 0x31,
	0xc5, 0x37, 0xf9, 0x38, 0x32, 0x8b, 0xaf, 0x14, 0x66, 0xf1, 0xba, 0xa7, 0xa3, 0xb4, 0x78, 0xd9,
	0x30, 0x12, 0xa6, 0xdf, 0x66, 0x7d, 0xb5, 0xf4, 0x1d, 0x36, 0x5d, 0x8b, 0x26, 0x9b, 0xa1, 0xeb,
	0xee, 0xc1, 0xc0, 0xce, 0xd4, 0xdf, 0x7a, 0x70, 0xf7, 0x10, 0x06, 0x76, 0x5a, 0x8d, 0x6f, 0x43,
	0x4b, 0x0e, 0xa1, 0x6f, 0x53, 0x51, 0x3d, 0xa1, 0xdd, 0x28, 0x4d, 0xf7, 0x2a, 0x34, 0x44, 0xf6,
	0xcf, 0x63, 0x29, 0x6b, 0x14, 0x15, 0x23, 0x45, 0xb9, 0x5f, 0x03, 0x64, 0x59, 0x3f, 0xfe, 0x08,
	0x9a, 0x34, 0x9a, 0x06, 0xa3, 0x73, 0xf5, 0xc6, 0xaf, 0xa5, 0xcb, 0xe5, 0x2f, 0xd1, 0x13, 0x21,
	0xf2, 0x94, 0x0a, 0x0f, 0xfa, 0x0b, 0x72, 0x2e, 0x4f, 0x49, 0xcf, 0x13, 0xdf, 0x2e, 0x81, 0x95,
	0x47, 0xfe, 0x09, 0x99, 0xee, 0x47, 0x21, 0x4b, 0x62, 0x3f, 0x08, 0x13, 0x7e, 0x79, 0x5f, 0x10,
	0xe9, 0xb0, 0xe3, 0xf1, 0x4f, 0xbc, 0x0d, 0xd5, 0x88, 0xa6, 0x01, 0x95, 0x8b, 0xc8, 0x59, 0x7d,
	0x43, 0xbd, 0x6a, 0xc4, 0x93, 0xd4, 0xe6, 0x4b, 0x7f, 0x3a, 0x53, 0x27, 0xae, 0xe3, 0x29, 0xca,
	0xfd, 0x53, 0x0d, 0xfa, 0x76, 0x43, 0x24, 0x4b, 0x74, 0x3a, 0xf9, 0x9f, 0xb7, 0x44, 0xdd, 0xa8,
	0xd2, 0x9c, 0x8e, 0xa7, 0xc9, 0x2c, 0x6b, 0xac, 0xc9, 0x04, 0x36, 0xcd, 0x1a, 0xa3, 0x97, 0x24,
	0x8e, 0x83, 0xb1, 0x3e, 0x75, 0x29, 0xcd, 0x65, 0x2c, 0xf1, 0xe3, 0x84, 0xd7, 0xa4, 0x0d, 0x11,
	0xc5, 0x94, 0xe6, 0x33, 0x25, 0xe1, 0x98, 0x4b, 0x9a, 0x32, 0xbe, 0x92, 0xc2, 0x3b, 0x50, 0x8f,
	0xa3, 0xa9, 0xec, 0x59, 0x0e, 0x8c, 0xde, 0x93, 0xac, 0x1b, 0xa3, 0xa9, 0x3c, 0x3c, 0x42, 0x27,
	0x4b, 0xa9, 0xdb, 0x46, 0x4a, 0x8d, 0x1f, 0x00, 0x9a, 0xda, 0xc1, 0x61, 0x4e, 0x47, 0x1c, 0x80,
	0x8d, 0xe2, 0xd8, 0xe9, 0xa6, 0x51, 0xde, 0x0a, 0xbf, 0x0f, 0x83, 0x69, 0x34, 0xf2, 0x93, 0x20,
	0x0a, 0x85, 0x09, 0x73, 0x40, 0x44, 0x35, 0xc7, 0xe5, 0x7a, 0x01, 0x8b, 0xa6, 0x92, 0x45, 0x5e,
	0x92, 0xa9, 0xe8, 0x42, 0x76, 0xbc, 0x1c, 0xd7, 0x7d, 0xc5, 0xd3, 0x44, 0xf1, 0xeb, 0xa2, 0x48,
	0xf8, 0x1f, 0xc8, 0xa3, 0x9e, 0xed, 0x44, 0x6f, 0xee, 0x87, 0x46, 0x95, 0x07, 0x54, 0xed, 0xfa,
	0xdc, 0xb8, 0x1c, 0xb5, 0xa5, 0x2e, 0xc7, 0x77, 0xb0, 0xa6, 0xfb, 0xe1, 0xcb, 0x8c, 0xbc, 0xa3,
	0x3b, 0xdf, 0xb2, 0x60, 0x1a, 0xec, 0xea, 0x9f, 0x65, 0x0f, 0xf9, 0xdf, 0xb4, 0xeb, 0xc8, 0x09,
	0x8e, 0x1a, 0xe6, 0x9a, 0xf0, 0x5d, 0x68, 0x9e, 0x4a, 0xd4, 0xaa, 0xe4, 0x9a, 0xa7, 0xf9, 0x85,
	0x2b, 0x3f, 0x4a, 0x9d, 0x57, 0x3d, 0xb1, 0xd4, 0x91, 0x37, 0x24, 0xab, 0x7a, 0xb4, 0xa9, 0xaa,
	0x7a, 0xb4, 0x96, 0xfb, 0x7b, 0xe8, 0x5b, 0xab, 0xc2, 0x9f, 0xe4, 0xc6, 0xbe, 0x92, 0x3a, 0x98,
	0x5b, 0x7b, 0x6e, 0xf0, 0xdb, 0x3c, 0xbd, 0x97, 0x4a, 0x7a, 0xf4, 0x95, 0xbc, 0x71, 0xda, 0x96,
	0x53, 0x7a, 0xee, 0x0f, 0x55, 0x68, 0xcd, 0xff, 0x5a, 0xdc, 0xcb, 0x97, 0x5a, 0xe2, 0xfe, 0xe8,
	0x52, 0x4b, 0x10, 0xd8, 0xb5, 0x7e, 0x29, 0xd6, 0xeb, 0xdc, 0x3f, 0x1b, 0x1b, 0x3f, 0x3f, 0x6c,
	0x01, 0x8c, 0x66, 0x2c, 0x89, 0xce, 0x04, 0x9a, 0xd6, 0x85, 0xb9, 0xc1, 0xd1, 0x30, 0x21, 0xef,
	0x95, 0x80, 0x09, 0x04, 0xb5, 0xd1, 0xd9, 0x58, 0xdd, 0x27, 0xfe, 0xc9, 0xb3, 0x65, 0x1a, 0xc8,
	0xa6, 0x45, 0x4d, 0x66, 0xcb, 0x4f, 0x8e, 0x0e, 0x3c, 0xce, 0x53, 0x6f, 0x13, 0xdd, 0x93, 0x97,
	0xa7, 0xe6, 0x29, 0x8a, 0x9f, 0xba, 0x24, 0x92, 0xbd, 0x8e, 0x8e, 0x3c, 0x75, 0x8a, 0xc4, 0x3b,
	0x80, 0x82, 0x49, 0xc8, 0x9f, 0x11, 0x1a, 0x8d, 0x4e, 0x05, 0xc0, 0x89, 0xae, 0x7d, 0xdb, 0x9b,
	0xe3, 0x8b, 0xde, 0xb5, 0x68, 0x1e, 0x75, 0x2f, 0x68, 0x1e, 0x49, 0x35, 0xf7, 0x6f, 0x15, 0x68,
	0x17, 0xfc, 0x62, 0x63, 0xc7, 0xd2, 0xb5, 0x7e, 0xb1, 0x59, 0x26, 0x6a, 0xb5, 0xb9, 0xa8, 0x0d,
	0xa1, 0x21, 0x20, 0x51, 0x04, 0xb4, 0xe7, 0x49, 0x42, 0xc7, 0xa9, 0x51, 0x10, 0xa7, 0xf4, 0x2e,
	0x34, 0x2f, 0xbe, 0x0b, 0x7f, 0xac, 0xc0, 0x9a, 0xd5, 0xac, 0x52, 0x87, 0xc3, 0x7e, 0x18, 0x2b,
	0xcb, 0x3f, 0x8c, 0xe6, 0x4d, 0xaf, 0x2e, 0x75, 0xd3, 0xf7, 0x60, 0x68, 0xcf, 0x40, 0xc5, 0xf4,
	0x43, 0xdd, 0x22, 0x95, 0x37, 0xa3, 0x6f, 0x6d, 0x48, 0xda, 0xb5, 0xe1, 0x84, 0x7b, 0x17, 0x56,
	0xf7, 0xa3, 0x33, 0xea, 0x8f, 0x92, 0x47, 0xd1, 0x44, 0x2f, 0xc1, 0x85, 0xde, 0x48, 0x32, 0x8f,
	0xc4, 0x1b, 0x20, 0x53, 0x4b, 0x8b, 0xe7, 0x0e, 0x01, 0x9b, 0x86, 0x72, 0x64, 0xf7, 0x01, 0xac,
	0xe7, 0xba, 0x70, 0xca, 0xe5, 0x5b, 0x3f, 0xf1, 0x0e, 0x6c, 0xe4, 0x3d, 0xa9, 0x31, 0x9e, 0xc1,
	0xea, 0x53, 0x12, 0x07, 0xcf, 0xcf, 0x1f, 0xf8, 0xec, 0x54, 0xfb, 0x4f, 0xdf, 0xab, 0x8a, 0xd9,
	0xe5, 0xc0, 0x50, 0x3f, 0xf5, 0xd9, 0xa9, 0xae, 0x1d, 0xf8, 0x37, 0x3f, 0xf3, 0xa3, 0x28, 0x4c,
	0xc8, 0x6b, 0x99, 0x06, 0xf7, 0x3c, 0x4d, 0xf2, 0x25, 0x99, 0x8e, 0xd5, 0x70, 0x63, 0x58, 0xb5,
	0xfa, 0x3d, 0x62, 0xb8, 0x3b, 0x06, 0x7e, 0xd9, 0xf9, 0x86, 0xa9, 0x96, 0x07, 0x31, 0x73, 0xec,
	0xaa, 0x3d, 0xf6, 0x9f, 0x2b, 0xd0, 0xb3, 0x46, 0x10, 0xed, 0x3d, 0x3f, 0x4e, 0xb2, 0xf6, 0x9e,
	0x1f, 0x8b, 0x74, 0x81, 0x84, 0xba, 0xf5, 0xcd, 0x3f, 0xf9, 0x1d, 0x08, 0xc9, 0xab, 0x63, 0xf5,
	0x76, 0xa8, 0x3b, 0x90, 0x71, 0xf0, 0x5d, 0xe8, 0x66, 0x7d, 0x03, 0xe6, 0xd4, 0x17, 0xf5, 0xa5,
	0x4d, 0x4d, 0x77, 0x0f, 0xb0, 0xb9, 0x6e, 0x75, 0xb4, 0x3e, 0xb2, 0xf2, 0xe2, 0x92, 0xb3, 0xa5,
	0x54, 0x5c, 0x0f, 0xd6, 0x7f, 0x43, 0xc7, 0x7e, 0x42, 0xbe, 0x26, 0x89, 0xcf, 0xd3, 0x4e, 0xbd,
	0xb8, 0x4f, 0xa1, 0x7d, 0xa6, 0x58, 0xea, 0x38, 0x6c, 0x5a, 0x7e, 0x1e, 0x45, 0x23, 0x7f, 0x2a,
	0xaa, 0x7a, 0x1d, 0x42, 0xad, 0xce, 0xcf, 0x45, 0xde, 0xa7, 0xda, 0xa8, 0x08, 0xd6, 0xa4, 0x44,
	0x3e, 0xd4, 0x7a, 0xac, 0x8f, 0xa0, 0x39, 0x95, 0xef, 0x79, 0x6e, 0xc6, 0x42, 0x4d, 0xcf, 0x58,
	0xaa, 0x18, 0x29, 0x5e, 0x55, 0xa5, 0x78, 0x72, 0x57, 0xa5, 0x63, 0x3b, 0xc5, 0x73, 0x37, 0x60,
	0x68, 0x0f, 0x28, 0x27, 0xb2, 0xf3, 0xd7, 0x36, 0xd4, 0xc5, 0x85, 0x5e, 0x87, 0x55, 0x71, 0xc9,
	0xc9, 0x24, 0x60, 0x09, 0x89, 0x45, 0x5a, 0x8e, 0x2e, 0xe1, 0xcb, 0xb0, 0xce, 0xd9, 0x73, 0x3f,
	0x7a, 0xa0, 0x4a, 0x89, 0x88, 0x51, 0x54, 0x4d, 0x45, 0xf9, 0x46, 0x2d, 0xaa, 0x95, 0x88, 0x18,
	0x45, 0x75, 0xbc, 0x06, 0x2b, 0x5c, 0x64, 0x34, 0x8e, 0x51, 0x63, 0x8e, 0xc9, 0x28, 0x6a, 0x6a,
	0xa6, 0xd1, 0x86, 0x45, 0xad, 0x39, 0x26, 0xa3, 0xa8, 0x8d, 0x31, 0x0c, 0x38, 0x33, 0x6b, 0x9e,
	0xa2, 0x4e, 0x9e, 0xc7, 0x28, 0x02, 0xec, 0xc0, 0x50, 0xf0, 0x72, 0x0d, 0x53, 0xd4, 0x2d, 0x96,
	0x30, 0x8a, 0x7a, 0xf8, 0x1d, 0xd8, 0xe4, 0x92, 0x82, 0x06, 0x27, 0xea, 0x97, 0x0a, 0x19, 0x45,
	0x03, 0x7c, 0x05, 0x36, 0x64, 0xb0, 0xf3, 0x6d, 0x3e, 0xb4, 0x52, 0x26, 0x63, 0x14, 0x21, 0x3d,
	0x97, 0x7c, 0x43, 0x12, 0xad, 0x16, 0x4b, 0x18, 0x45, 0x58, 0x4b, 0xf2, 0xfd, 0x37, 0xb4, 0xa6,
	0x03, 0x66, 0xd4, 0xe7, 0x68, 0x88, 0x37, 0x61, 0x2d, 0x53, 0x4f, 0x5b, 0x64, 0x68, 0xbd, 0x50,
	0xc0, 0x28, 0xda, 0xd0, 0x82, 0x5c, 0x53, 0x0d, 0x6d, 0x16, 0x0a, 0x18, 0x45, 0x8e, 0x5e, 0xe2,
	0x7c, 0x17, 0x0d, 0x5d, 0x2e, 0x93, 0x31, 0x8a, 0xae, 0xe8, 0x98, 0x16, 0x34, 0xbe, 0xd0, 0x3b,
	0xa5, 0x42, 0x46, 0xd1, 0xbb, 0xda, 0xeb, 0x7c, 0x53, 0x0b, 0xfd, 0x4f, 0x99, 0x8c, 0x51, 0xb4,
	0x85, 0x87, 0x80, 0xb2, 0x45, 0xcb, 0x4e, 0x10, 0xba, 0x3a, 0xcf, 0x65, 0x14, 0x5d, 0xd3, 0x5c,
	0xb3, 0xf7, 0x84, 0xfe, 0x77, 0x9e, 0xcb, 0x28, 0x72, 0xf5, 0x6d, 0xb3, 0x5a, 0x4c, 0xe8, 0x7a,
	0x01, 0x9b, 0x51, 0x74, 0x03, 0x5f, 0x85, 0x77, 0xc4, 0x11, 0x2c, 0xee, 0x10, 0xa1, 0xf7, 0x16,
	0x2a, 0x30, 0x8a, 0xde, 0xd7, 0x0a, 0x25, 0x8d, 0x1f, 0xf4, 0xc1, 0x42, 0x05, 0x46, 0xd1, 0xf6,
	0xce, 0xbe, 0xf8, 0x27, 0x04, 0xb3, 0xd6, 0xc1, 0x1d, 0x68, 0x3c, 0x8d, 0x12, 0x12, 0xa3, 0x4b,
	0x18, 0xa0, 0x29, 0x5f, 0x3e, 0x54, 0xc1, 0x3d, 0x68, 0x7f, 0x19, 0x4d, 0xa7, 0xd1, 0x2b, 0x12,
	0xa3, 0x2a, 0xee, 0x42, 0xeb, 0x11, 0xf1, 0xe3, 0x90, 0xc4, 0xa8, 0xb6, 0xb3, 0x07, 0xab, 0x73,
	0xe5, 0x21, 0x6e, 0x42, 0xf5, 0x28, 0x44, 0x97, 0xb8, 0xbb, 0xc7, 0x51, 0x72, 0x14, 0xa2, 0x0a,
	0x77, 0x77, 0xf8, 0x3a, 0x60, 0x09, 0x43, 0x55, 0xdc, 0x87, 0xce, 0xe3, 0x28, 0x51, 0x64, 0x6d,
	0xe7, 0x43, 0x68, 0xa9, 0xc4, 0x8a, 0x1b, 0x3c, 0x8b, 0x83, 0x84, 0xc3, 0x54, 0x1b, 0xea, 0x1e,
	0xf1, 0xc7, 0xa8, 0xc2, 0x99, 0x7b, 0xe3, 0xb3, 0x20, 0x44, 0xd5, 0x9d, 0xbf, 0x54, 0xa0, 0x27,
	0xbe, 0xb5, 0xc1, 0x3a, 0xac, 0x4a, 0xda, 0x48, 0x44, 0xd0, 0x25, 0x7e, 0x0f, 0x14, 0x5b, 0xe7,
	0x08, 0xa8, 0xc2, 0x0f, 0xaf, 0x60, 0xda, 0x0f, 0x3b, 0xaa, 0xa6, 0xda, 0x19, 0x1a, 0xa0, 0x46,
	0xaa, 0x6d, 0xc3, 0x3d, 0x6a, 0xa6, 0x43, 0x9a, 0xe0, 0x8b, 0x5a, 0x3b, 0x9f, 0x42, 0xcf, 0x84,
	0x69, 0xdc, 0x82, 0xda, 0xde, 0x78, 0x2c, 0x03, 0x29, 0x8f, 0x8a, 0x5c, 0x8a, 0x47, 0x18, 0x49,
	0x50, 0x95, 0x7f, 0xee, 0x4f, 0x89, 0x1f, 0xa3, 0xda, 0x3d, 0xf4, 0xe3, 0x7f, 0xb6, 0x2e, 0xfd,
	0xf0, 0x66, 0xab, 0xf2, 0xe3, 0x9b, 0xad, 0xca, 0xbf, 0xdf, 0x6c, 0x55, 0x4e, 0x9a, 0xe2, 0x5f,
	0x45, 0x6f, 0xff, 0x37, 0x00, 0x00, 0xff, 0xff, 0x16, 0xeb, 0x4e, 0x1f, 0xe7, 0x2a, 0x00, 0x00,
}

func (m *ProphetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProphetRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProphetRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.GetScheduleGroupRule.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xba
	{
		size, err := m.AddScheduleGroupRule.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb2
	{
		size, err := m.ExecuteJob.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xaa
	{
		size, err := m.RemoveJob.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa2
	{
		size, err := m.CreateJob.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x9a
	{
		size, err := m.GetAppliedRules.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x92
	{
		size, err := m.PutPlacementRule.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	{
		size, err := m.CheckShardState.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	{
		size, err := m.RemoveShards.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	{
		size, err := m.CreateShards.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	{
		size, err := m.CreateWatcher.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size, err := m.GetDestroying.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size, err := m.ReportDestroyed.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size, err := m.CreateDestroying.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size, err := m.AskBatchSplit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.AllocID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.GetStore.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.PutStore.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.StoreHeartbeat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.ShardHeartbeat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.Type != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.StoreID != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.StoreID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProphetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProphetResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProphetResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.GetScheduleGroupRule.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xc2
	{
		size, err := m.AddScheduleGroupRule.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xba
	{
		size, err := m.ExecuteJob.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xb2
	{
		size, err := m.RemoveJob.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xaa
	{
		size, err := m.CreateJob.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0xa2
	{
		size, err := m.GetAppliedRules.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x9a
	{
		size, err := m.PutPlacementRule.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x92
	{
		size, err := m.CheckShardState.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x8a
	{
		size, err := m.RemoveShards.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1
	i--
	dAtA[i] = 0x82
	{
		size, err := m.CreateShards.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x7a
	{
		size, err := m.Event.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x72
	{
		size, err := m.GetDestroying.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x6a
	{
		size, err := m.ReportDestroyed.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x62
	{
		size, err := m.CreateDestroying.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	{
		size, err := m.AskBatchSplit.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x52
	{
		size, err := m.AllocID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x4a
	{
		size, err := m.GetStore.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	{
		size, err := m.PutStore.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	{
		size, err := m.StoreHeartbeat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	{
		size, err := m.ShardHeartbeat.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	if len(m.Leader) > 0 {
		i -= len(m.Leader)
		copy(dAtA[i:], m.Leader)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Leader)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Error) > 0 {
		i -= len(m.Error)
		copy(dAtA[i:], m.Error)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Error)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShardHeartbeatReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardHeartbeatReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardHeartbeatReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.GroupKey) > 0 {
		i -= len(m.GroupKey)
		copy(dAtA[i:], m.GroupKey)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.GroupKey)))
		i--
		dAtA[i] = 0x42
	}
	{
		size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x3a
	if len(m.PendingReplicas) > 0 {
		for iNdEx := len(m.PendingReplicas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PendingReplicas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpcpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.DownReplicas) > 0 {
		for iNdEx := len(m.DownReplicas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.DownReplicas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpcpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Leader != nil {
		{
			size, err := m.Leader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Term != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Shard) > 0 {
		i -= len(m.Shard)
		copy(dAtA[i:], m.Shard)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Shard)))
		i--
		dAtA[i] = 0x12
	}
	if m.StoreID != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.StoreID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ShardHeartbeatRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardHeartbeatRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardHeartbeatRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DestroyDirectly {
		i--
		if m.DestroyDirectly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.ConfigChangeV2 != nil {
		{
			size, err := m.ConfigChangeV2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.SplitShard != nil {
		{
			size, err := m.SplitShard.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Merge != nil {
		{
			size, err := m.Merge.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.TransferLeader != nil {
		{
			size, err := m.TransferLeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ConfigChange != nil {
		{
			size, err := m.ConfigChange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.TargetReplica != nil {
		{
			size, err := m.TargetReplica.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	{
		size, err := m.ShardEpoch.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.ShardID != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ShardID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PutStoreReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutStoreReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutStoreReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Store) > 0 {
		i -= len(m.Store)
		copy(dAtA[i:], m.Store)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Store)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PutStoreRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutStoreRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutStoreRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.DestroyShards) > 0 {
		i -= len(m.DestroyShards)
		copy(dAtA[i:], m.DestroyShards)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.DestroyShards)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StoreHeartbeatReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreHeartbeatReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreHeartbeatReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *StoreHeartbeatRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreHeartbeatRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreHeartbeatRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetStoreReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStoreReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetStoreReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetStoreRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStoreRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetStoreRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Stats != nil {
		{
			size, err := m.Stats.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AllocIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocIDReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllocIDReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *AllocIDRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocIDRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllocIDRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AskBatchSplitReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AskBatchSplitReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AskBatchSplitReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Count != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AskBatchSplitRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AskBatchSplitRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AskBatchSplitRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.SplitIDs) > 0 {
		for iNdEx := len(m.SplitIDs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SplitIDs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpcpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateDestroyingReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateDestroyingReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateDestroyingReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.RemoveData {
		i--
		if m.RemoveData {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Replicas) > 0 {
		dAtA53 := make([]byte, len(m.Replicas)*10)
		var j52 int
		for _, num := range m.Replicas {
			for num >= 1<<7 {
				dAtA53[j52] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j52++
			}
			dAtA53[j52] = uint8(num)
			j52++
		}
		i -= j52
		copy(dAtA[i:], dAtA53[:j52])
		i = encodeVarintRpcpb(dAtA, i, uint64(j52))
		i--
		dAtA[i] = 0x1a
	}
	if m.Index != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateDestroyingRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateDestroyingRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateDestroyingRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetDestroyingReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDestroyingReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetDestroyingReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ID != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetDestroyingRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDestroyingRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetDestroyingRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Status != nil {
		{
			size, err := m.Status.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ReportDestroyedReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportDestroyedReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportDestroyedReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ReplicaID != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ReplicaID))
		i--
		dAtA[i] = 0x10
	}
	if m.ID != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReportDestroyedRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportDestroyedRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReportDestroyedRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.State != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SplitID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitID) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SplitID) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NewReplicaIDs) > 0 {
		dAtA56 := make([]byte, len(m.NewReplicaIDs)*10)
		var j55 int
		for _, num := range m.NewReplicaIDs {
			for num >= 1<<7 {
				dAtA56[j55] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j55++
			}
			dAtA56[j55] = uint8(num)
			j55++
		}
		i -= j55
		copy(dAtA[i:], dAtA56[:j55])
		i = encodeVarintRpcpb(dAtA, i, uint64(j55))
		i--
		dAtA[i] = 0x12
	}
	if m.NewID != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.NewID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateWatcherReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateWatcherReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateWatcherReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Flag != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Flag))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CreateShardsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateShardsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateShardsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.LeastReplicas) > 0 {
		dAtA58 := make([]byte, len(m.LeastReplicas)*10)
		var j57 int
		for _, num := range m.LeastReplicas {
			for num >= 1<<7 {
				dAtA58[j57] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j57++
			}
			dAtA58[j57] = uint8(num)
			j57++
		}
		i -= j57
		copy(dAtA[i:], dAtA58[:j57])
		i = encodeVarintRpcpb(dAtA, i, uint64(j57))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Shards) > 0 {
		for iNdEx := len(m.Shards) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Shards[iNdEx])
			copy(dAtA[i:], m.Shards[iNdEx])
			i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Shards[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateShardsRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateShardsRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateShardsRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *RemoveShardsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveShardsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveShardsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IDs) > 0 {
		dAtA60 := make([]byte, len(m.IDs)*10)
		var j59 int
		for _, num := range m.IDs {
			for num >= 1<<7 {
				dAtA60[j59] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j59++
			}
			dAtA60[j59] = uint8(num)
			j59++
		}
		i -= j59
		copy(dAtA[i:], dAtA60[:j59])
		i = encodeVarintRpcpb(dAtA, i, uint64(j59))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RemoveShardsRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveShardsRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveShardsRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *CheckShardStateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckShardStateReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckShardStateReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IDs) > 0 {
		i -= len(m.IDs)
		copy(dAtA[i:], m.IDs)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.IDs)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CheckShardStateRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckShardStateRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckShardStateRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Destroying) > 0 {
		i -= len(m.Destroying)
		copy(dAtA[i:], m.Destroying)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Destroying)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Destroyed) > 0 {
		i -= len(m.Destroyed)
		copy(dAtA[i:], m.Destroyed)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Destroyed)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PutPlacementRuleReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutPlacementRuleReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutPlacementRuleReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Rule.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PutPlacementRuleRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutPlacementRuleRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutPlacementRuleRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *GetAppliedRulesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAppliedRulesReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAppliedRulesReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ShardID != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ShardID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetAppliedRulesRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAppliedRulesRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetAppliedRulesRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpcpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CreateJobReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateJobReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateJobReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Job.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CreateJobRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateJobRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateJobRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *RemoveJobReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveJobReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveJobReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Job.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *RemoveJobRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveJobRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RemoveJobRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ExecuteJobReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteJobReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecuteJobReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	{
		size, err := m.Job.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ExecuteJobRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteJobRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecuteJobRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AddScheduleGroupRuleReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddScheduleGroupRuleReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddScheduleGroupRuleReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Rule.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *AddScheduleGroupRuleRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddScheduleGroupRuleRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AddScheduleGroupRuleRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *GetScheduleGroupRuleReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetScheduleGroupRuleReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetScheduleGroupRuleReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *GetScheduleGroupRuleRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetScheduleGroupRuleRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetScheduleGroupRuleRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpcpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *EventNotify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventNotify) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventNotify) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.StoreStatsEvent != nil {
		{
			size, err := m.StoreStatsEvent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.ShardStatsEvent != nil {
		{
			size, err := m.ShardStatsEvent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.StoreEvent != nil {
		{
			size, err := m.StoreEvent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.ShardEvent != nil {
		{
			size, err := m.ShardEvent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.InitEvent != nil {
		{
			size, err := m.InitEvent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRpcpb(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Seq != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InitEventData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitEventData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InitEventData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Stores) > 0 {
		for iNdEx := len(m.Stores) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Stores[iNdEx])
			copy(dAtA[i:], m.Stores[iNdEx])
			i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Stores[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Leaders) > 0 {
		dAtA72 := make([]byte, len(m.Leaders)*10)
		var j71 int
		for _, num := range m.Leaders {
			for num >= 1<<7 {
				dAtA72[j71] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j71++
			}
			dAtA72[j71] = uint8(num)
			j71++
		}
		i -= j71
		copy(dAtA[i:], dAtA72[:j71])
		i = encodeVarintRpcpb(dAtA, i, uint64(j71))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Shards) > 0 {
		for iNdEx := len(m.Shards) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Shards[iNdEx])
			copy(dAtA[i:], m.Shards[iNdEx])
			i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Shards[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ShardEventData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardEventData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ShardEventData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Create {
		i--
		if m.Create {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Removed {
		i--
		if m.Removed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Leader != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Leader))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StoreEventData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreEventData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StoreEventData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConfigChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ChangeType != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ChangeType))
		i--
		dAtA[i] = 0x10
	}
	{
		size, err := m.Replica.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TransferLeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferLeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferLeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Replica.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ConfigChangeV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigChangeV2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigChangeV2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Changes) > 0 {
		for iNdEx := len(m.Changes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Changes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpcpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Merge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Merge) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Merge) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Target) > 0 {
		i -= len(m.Target)
		copy(dAtA[i:], m.Target)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Target)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SplitShard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitShard) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SplitShard) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Keys) > 0 {
		for iNdEx := len(m.Keys) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Keys[iNdEx])
			copy(dAtA[i:], m.Keys[iNdEx])
			i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Keys[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Policy != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Policy))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LabelConstraint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabelConstraint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LabelConstraint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Values) > 0 {
		for iNdEx := len(m.Values) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Values[iNdEx])
			copy(dAtA[i:], m.Values[iNdEx])
			i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Values[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Op != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PlacementRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlacementRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PlacementRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.IsolationLevel) > 0 {
		i -= len(m.IsolationLevel)
		copy(dAtA[i:], m.IsolationLevel)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.IsolationLevel)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.LocationLabels) > 0 {
		for iNdEx := len(m.LocationLabels) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.LocationLabels[iNdEx])
			copy(dAtA[i:], m.LocationLabels[iNdEx])
			i = encodeVarintRpcpb(dAtA, i, uint64(len(m.LocationLabels[iNdEx])))
			i--
			dAtA[i] = 0x52
		}
	}
	if len(m.LabelConstraints) > 0 {
		for iNdEx := len(m.LabelConstraints) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LabelConstraints[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpcpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x4a
		}
	}
	if m.Count != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Count))
		i--
		dAtA[i] = 0x40
	}
	if m.Role != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Role))
		i--
		dAtA[i] = 0x38
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.StartKey) > 0 {
		i -= len(m.StartKey)
		copy(dAtA[i:], m.StartKey)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.StartKey)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Override {
		i--
		if m.Override {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Index != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x18
	}
	if len(m.GroupID) > 0 {
		i -= len(m.GroupID)
		copy(dAtA[i:], m.GroupID)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.GroupID)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestBatchHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestBatchHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestBatchHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Replica.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.ShardID != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ShardID))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseBatchHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseBatchHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseBatchHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Requests) > 0 {
		for iNdEx := len(m.Requests) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Requests[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpcpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *ResponseBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseBatch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseBatch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Responses) > 0 {
		for iNdEx := len(m.Responses) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Responses[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpcpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	{
		size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Epoch.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x5a
	if m.IgnoreEpochCheck {
		i--
		if m.IgnoreEpochCheck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.ToShard != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ToShard))
		i--
		dAtA[i] = 0x48
	}
	if m.StopAt != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.StopAt))
		i--
		dAtA[i] = 0x40
	}
	if m.PID != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.PID))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Cmd) > 0 {
		i -= len(m.Cmd)
		copy(dAtA[i:], m.Cmd)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Cmd)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0x2a
	}
	if m.CustomType != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.CustomType))
		i--
		dAtA[i] = 0x20
	}
	if m.Type != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.Group != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Group))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Error.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x32
	if m.PID != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.PID))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x22
	}
	if m.CustomType != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.CustomType))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConfigChangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigChangeRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigChangeRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Replica.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x12
	if m.ChangeType != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ChangeType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConfigChangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigChangeResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigChangeResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Shard.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *CompactLogRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactLogRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactLogRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.CompactIndex != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.CompactIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CompactLogResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactLogResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactLogResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *TransferLeaderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferLeaderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferLeaderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Replica.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *TransferLeaderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferLeaderResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TransferLeaderResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *VerifyHashRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyHashRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyHashRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Context) > 0 {
		i -= len(m.Context)
		copy(dAtA[i:], m.Context)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Context)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x12
	}
	if m.Index != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VerifyHashResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VerifyHashResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VerifyHashResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *BatchSplitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSplitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSplitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Context) > 0 {
		i -= len(m.Context)
		copy(dAtA[i:], m.Context)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Context)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Requests) > 0 {
		for iNdEx := len(m.Requests) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Requests[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpcpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SplitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SplitRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.NewReplicas) > 0 {
		for iNdEx := len(m.NewReplicas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.NewReplicas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpcpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.NewShardID != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.NewShardID))
		i--
		dAtA[i] = 0x18
	}
	if len(m.End) > 0 {
		i -= len(m.End)
		copy(dAtA[i:], m.End)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.End)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Start) > 0 {
		i -= len(m.Start)
		copy(dAtA[i:], m.Start)
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Start)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BatchSplitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSplitResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchSplitResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Shards) > 0 {
		for iNdEx := len(m.Shards) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Shards[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpcpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UpdateMetadataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateMetadataRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateMetadataRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintRpcpb(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *UpdateMetadataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateMetadataResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateMetadataResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UpdateLabelsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateLabelsRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateLabelsRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Policy != 0 {
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Policy))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Labels) > 0 {
		for iNdEx := len(m.Labels) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Labels[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRpcpb(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UpdateLabelsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateLabelsResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateLabelsResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func encodeVarintRpcpb(dAtA []byte, offset int, v uint64) int {
	offset -= sovRpcpb(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ProphetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRpcpb(uint64(m.ID))
	}
	if m.StoreID != 0 {
		n += 1 + sovRpcpb(uint64(m.StoreID))
	}
	if m.Type != 0 {
		n += 1 + sovRpcpb(uint64(m.Type))
	}
	l = m.ShardHeartbeat.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.StoreHeartbeat.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.PutStore.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.GetStore.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.AllocID.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.AskBatchSplit.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.CreateDestroying.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.ReportDestroyed.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.GetDestroying.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.CreateWatcher.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.CreateShards.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.RemoveShards.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.CheckShardState.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.PutPlacementRule.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.GetAppliedRules.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.CreateJob.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.RemoveJob.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.ExecuteJob.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.AddScheduleGroupRule.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.GetScheduleGroupRule.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProphetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRpcpb(uint64(m.ID))
	}
	if m.Type != 0 {
		n += 1 + sovRpcpb(uint64(m.Type))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = m.ShardHeartbeat.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.StoreHeartbeat.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.PutStore.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.GetStore.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.AllocID.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.AskBatchSplit.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.CreateDestroying.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.ReportDestroyed.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.GetDestroying.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.Event.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.CreateShards.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.RemoveShards.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.CheckShardState.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.PutPlacementRule.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.GetAppliedRules.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.CreateJob.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.RemoveJob.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.ExecuteJob.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.AddScheduleGroupRule.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.GetScheduleGroupRule.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardHeartbeatReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StoreID != 0 {
		n += 1 + sovRpcpb(uint64(m.StoreID))
	}
	l = len(m.Shard)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Term != 0 {
		n += 1 + sovRpcpb(uint64(m.Term))
	}
	if m.Leader != nil {
		l = m.Leader.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if len(m.DownReplicas) > 0 {
		for _, e := range m.DownReplicas {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if len(m.PendingReplicas) > 0 {
		for _, e := range m.PendingReplicas {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	l = m.Stats.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = len(m.GroupKey)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardHeartbeatRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardID != 0 {
		n += 1 + sovRpcpb(uint64(m.ShardID))
	}
	l = m.ShardEpoch.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.TargetReplica != nil {
		l = m.TargetReplica.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.ConfigChange != nil {
		l = m.ConfigChange.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.TransferLeader != nil {
		l = m.TransferLeader.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Merge != nil {
		l = m.Merge.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.SplitShard != nil {
		l = m.SplitShard.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.ConfigChangeV2 != nil {
		l = m.ConfigChangeV2.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.DestroyDirectly {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutStoreReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Store)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutStoreRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DestroyShards)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StoreHeartbeatReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Stats.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StoreHeartbeatRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetStoreReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRpcpb(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetStoreRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllocIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllocIDRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRpcpb(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AskBatchSplitReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovRpcpb(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AskBatchSplitRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SplitIDs) > 0 {
		for _, e := range m.SplitIDs {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateDestroyingReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRpcpb(uint64(m.ID))
	}
	if m.Index != 0 {
		n += 1 + sovRpcpb(uint64(m.Index))
	}
	if len(m.Replicas) > 0 {
		l = 0
		for _, e := range m.Replicas {
			l += sovRpcpb(uint64(e))
		}
		n += 1 + sovRpcpb(uint64(l)) + l
	}
	if m.RemoveData {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateDestroyingRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovRpcpb(uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetDestroyingReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRpcpb(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetDestroyingRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportDestroyedReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRpcpb(uint64(m.ID))
	}
	if m.ReplicaID != 0 {
		n += 1 + sovRpcpb(uint64(m.ReplicaID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportDestroyedRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovRpcpb(uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SplitID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewID != 0 {
		n += 1 + sovRpcpb(uint64(m.NewID))
	}
	if len(m.NewReplicaIDs) > 0 {
		l = 0
		for _, e := range m.NewReplicaIDs {
			l += sovRpcpb(uint64(e))
		}
		n += 1 + sovRpcpb(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateWatcherReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flag != 0 {
		n += 1 + sovRpcpb(uint64(m.Flag))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateShardsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Shards) > 0 {
		for _, b := range m.Shards {
			l = len(b)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if len(m.LeastReplicas) > 0 {
		l = 0
		for _, e := range m.LeastReplicas {
			l += sovRpcpb(uint64(e))
		}
		n += 1 + sovRpcpb(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateShardsRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoveShardsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IDs) > 0 {
		l = 0
		for _, e := range m.IDs {
			l += sovRpcpb(uint64(e))
		}
		n += 1 + sovRpcpb(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoveShardsRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckShardStateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IDs)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckShardStateRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Destroyed)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = len(m.Destroying)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutPlacementRuleReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Rule.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutPlacementRuleRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAppliedRulesReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardID != 0 {
		n += 1 + sovRpcpb(uint64(m.ShardID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAppliedRulesRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateJobReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Job.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateJobRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoveJobReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Job.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoveJobRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteJobReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Job.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteJobRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddScheduleGroupRuleReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Rule.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddScheduleGroupRuleRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetScheduleGroupRuleReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetScheduleGroupRuleRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EventNotify) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seq != 0 {
		n += 1 + sovRpcpb(uint64(m.Seq))
	}
	if m.Type != 0 {
		n += 1 + sovRpcpb(uint64(m.Type))
	}
	if m.InitEvent != nil {
		l = m.InitEvent.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.ShardEvent != nil {
		l = m.ShardEvent.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.StoreEvent != nil {
		l = m.StoreEvent.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.ShardStatsEvent != nil {
		l = m.ShardStatsEvent.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.StoreStatsEvent != nil {
		l = m.StoreStatsEvent.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InitEventData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Shards) > 0 {
		for _, b := range m.Shards {
			l = len(b)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if len(m.Leaders) > 0 {
		l = 0
		for _, e := range m.Leaders {
			l += sovRpcpb(uint64(e))
		}
		n += 1 + sovRpcpb(uint64(l)) + l
	}
	if len(m.Stores) > 0 {
		for _, b := range m.Stores {
			l = len(b)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardEventData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Leader != 0 {
		n += 1 + sovRpcpb(uint64(m.Leader))
	}
	if m.Removed {
		n += 2
	}
	if m.Create {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StoreEventData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Replica.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.ChangeType != 0 {
		n += 1 + sovRpcpb(uint64(m.ChangeType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransferLeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Replica.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigChangeV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for _, e := range m.Changes {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Merge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SplitShard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Policy != 0 {
		n += 1 + sovRpcpb(uint64(m.Policy))
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LabelConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Op != 0 {
		n += 1 + sovRpcpb(uint64(m.Op))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlacementRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = len(m.GroupID)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovRpcpb(uint64(m.Index))
	}
	if m.Override {
		n += 2
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Role != 0 {
		n += 1 + sovRpcpb(uint64(m.Role))
	}
	if m.Count != 0 {
		n += 1 + sovRpcpb(uint64(m.Count))
	}
	if len(m.LabelConstraints) > 0 {
		for _, e := range m.LabelConstraints {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if len(m.LocationLabels) > 0 {
		for _, s := range m.LocationLabels {
			l = len(s)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	l = len(m.IsolationLevel)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RequestBatchHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.ShardID != 0 {
		n += 1 + sovRpcpb(uint64(m.ShardID))
	}
	l = m.Replica.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseBatchHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = m.Error.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RequestBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if len(m.Responses) > 0 {
		for _, e := range m.Responses {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Group != 0 {
		n += 1 + sovRpcpb(uint64(m.Group))
	}
	if m.Type != 0 {
		n += 1 + sovRpcpb(uint64(m.Type))
	}
	if m.CustomType != 0 {
		n += 1 + sovRpcpb(uint64(m.CustomType))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = len(m.Cmd)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.PID != 0 {
		n += 1 + sovRpcpb(uint64(m.PID))
	}
	if m.StopAt != 0 {
		n += 1 + sovRpcpb(uint64(m.StopAt))
	}
	if m.ToShard != 0 {
		n += 1 + sovRpcpb(uint64(m.ToShard))
	}
	if m.IgnoreEpochCheck {
		n += 2
	}
	l = m.Epoch.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovRpcpb(uint64(m.Type))
	}
	if m.CustomType != 0 {
		n += 1 + sovRpcpb(uint64(m.CustomType))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.PID != 0 {
		n += 1 + sovRpcpb(uint64(m.PID))
	}
	l = m.Error.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigChangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChangeType != 0 {
		n += 1 + sovRpcpb(uint64(m.ChangeType))
	}
	l = m.Replica.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigChangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Shard.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CompactLogRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompactIndex != 0 {
		n += 1 + sovRpcpb(uint64(m.CompactIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CompactLogResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransferLeaderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Replica.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransferLeaderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyHashRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovRpcpb(uint64(m.Index))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = len(m.Context)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VerifyHashResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BatchSplitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	l = len(m.Context)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SplitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Start)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = len(m.End)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.NewShardID != 0 {
		n += 1 + sovRpcpb(uint64(m.NewShardID))
	}
	if len(m.NewReplicas) > 0 {
		for _, e := range m.NewReplicas {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BatchSplitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Shards) > 0 {
		for _, e := range m.Shards {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateMetadataRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Metadata.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateMetadataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateLabelsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.Policy != 0 {
		n += 1 + sovRpcpb(uint64(m.Policy))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateLabelsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovRpcpb(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRpcpb(x uint64) (n int) {
	return sovRpcpb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ProphetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProphetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProphetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ShardHeartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StoreHeartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PutStore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PutStore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetStore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetStore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AllocID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskBatchSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AskBatchSplit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateDestroying", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreateDestroying.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportDestroyed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReportDestroyed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetDestroying", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetDestroying.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateWatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreateWatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreateShards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemoveShards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckShardState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CheckShardState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PutPlacementRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PutPlacementRule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetAppliedRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetAppliedRules.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreateJob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemoveJob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecuteJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExecuteJob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddScheduleGroupRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AddScheduleGroupRule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetScheduleGroupRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetScheduleGroupRule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProphetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProphetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProphetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ShardHeartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StoreHeartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PutStore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PutStore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetStore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetStore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AllocID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskBatchSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AskBatchSplit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateDestroying", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreateDestroying.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportDestroyed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReportDestroyed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetDestroying", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetDestroying.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Event.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreateShards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemoveShards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckShardState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CheckShardState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PutPlacementRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PutPlacementRule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetAppliedRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetAppliedRules.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreateJob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemoveJob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecuteJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExecuteJob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddScheduleGroupRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AddScheduleGroupRule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetScheduleGroupRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetScheduleGroupRule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardHeartbeatReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardHeartbeatReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardHeartbeatReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shard = append(m.Shard[:0], dAtA[iNdEx:postIndex]...)
			if m.Shard == nil {
				m.Shard = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Leader == nil {
				m.Leader = &metapb.Replica{}
			}
			if err := m.Leader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownReplicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownReplicas = append(m.DownReplicas, metapb.ReplicaStats{})
			if err := m.DownReplicas[len(m.DownReplicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingReplicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PendingReplicas = append(m.PendingReplicas, metapb.Replica{})
			if err := m.PendingReplicas[len(m.PendingReplicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardHeartbeatRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardHeartbeatRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardHeartbeatRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ShardEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetReplica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TargetReplica == nil {
				m.TargetReplica = &metapb.Replica{}
			}
			if err := m.TargetReplica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigChange == nil {
				m.ConfigChange = &ConfigChange{}
			}
			if err := m.ConfigChange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferLeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransferLeader == nil {
				m.TransferLeader = &TransferLeader{}
			}
			if err := m.TransferLeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Merge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Merge == nil {
				m.Merge = &Merge{}
			}
			if err := m.Merge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitShard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SplitShard == nil {
				m.SplitShard = &SplitShard{}
			}
			if err := m.SplitShard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigChangeV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigChangeV2 == nil {
				m.ConfigChangeV2 = &ConfigChangeV2{}
			}
			if err := m.ConfigChangeV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestroyDirectly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DestroyDirectly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutStoreReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutStoreReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutStoreReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Store", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Store = append(m.Store[:0], dAtA[iNdEx:postIndex]...)
			if m.Store == nil {
				m.Store = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutStoreRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutStoreRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutStoreRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestroyShards", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestroyShards = append(m.DestroyShards[:0], dAtA[iNdEx:postIndex]...)
			if m.DestroyShards == nil {
				m.DestroyShards = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreHeartbeatReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreHeartbeatReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreHeartbeatReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreHeartbeatRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreHeartbeatRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreHeartbeatRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStoreReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStoreReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStoreReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStoreRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStoreRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStoreRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &metapb.StoreStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocIDRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocIDRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocIDRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AskBatchSplitReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AskBatchSplitReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AskBatchSplitReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AskBatchSplitRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AskBatchSplitRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AskBatchSplitRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SplitIDs = append(m.SplitIDs, SplitID{})
			if err := m.SplitIDs[len(m.SplitIDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateDestroyingReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateDestroyingReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateDestroyingReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Replicas = append(m.Replicas, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRpcpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRpcpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Replicas) == 0 {
					m.Replicas = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Replicas = append(m.Replicas, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveData", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RemoveData = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateDestroyingRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateDestroyingRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateDestroyingRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= metapb.ShardState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDestroyingReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDestroyingReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDestroyingReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDestroyingRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDestroyingRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDestroyingRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &metapb.DestroyingStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportDestroyedReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportDestroyedReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportDestroyedReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaID", wireType)
			}
			m.ReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportDestroyedRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportDestroyedRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportDestroyedRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= metapb.ShardState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewID", wireType)
			}
			m.NewID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NewReplicaIDs = append(m.NewReplicaIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRpcpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRpcpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NewReplicaIDs) == 0 {
					m.NewReplicaIDs = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NewReplicaIDs = append(m.NewReplicaIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NewReplicaIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateWatcherReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateWatcherReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateWatcherReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateShardsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateShardsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateShardsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, make([]byte, postIndex-iNdEx))
			copy(m.Shards[len(m.Shards)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LeastReplicas = append(m.LeastReplicas, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRpcpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRpcpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LeastReplicas) == 0 {
					m.LeastReplicas = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LeastReplicas = append(m.LeastReplicas, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LeastReplicas", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateShardsRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateShardsRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateShardsRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveShardsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveShardsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveShardsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IDs = append(m.IDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRpcpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRpcpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IDs) == 0 {
					m.IDs = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IDs = append(m.IDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveShardsRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveShardsRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveShardsRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckShardStateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckShardStateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckShardStateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IDs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IDs = append(m.IDs[:0], dAtA[iNdEx:postIndex]...)
			if m.IDs == nil {
				m.IDs = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckShardStateRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckShardStateRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckShardStateRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destroyed", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destroyed = append(m.Destroyed[:0], dAtA[iNdEx:postIndex]...)
			if m.Destroyed == nil {
				m.Destroyed = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destroying", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destroying = append(m.Destroying[:0], dAtA[iNdEx:postIndex]...)
			if m.Destroying == nil {
				m.Destroying = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutPlacementRuleReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutPlacementRuleReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutPlacementRuleReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutPlacementRuleRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutPlacementRuleRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutPlacementRuleRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAppliedRulesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAppliedRulesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAppliedRulesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAppliedRulesRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAppliedRulesRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAppliedRulesRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, PlacementRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateJobReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateJobReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateJobReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateJobRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateJobRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateJobRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveJobReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveJobReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveJobReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveJobRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveJobRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveJobRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteJobReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteJobReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteJobReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteJobRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteJobRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteJobRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddScheduleGroupRuleReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddScheduleGroupRuleReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddScheduleGroupRuleReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddScheduleGroupRuleRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddScheduleGroupRuleRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddScheduleGroupRuleRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetScheduleGroupRuleReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetScheduleGroupRuleReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetScheduleGroupRuleReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetScheduleGroupRuleRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetScheduleGroupRuleRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetScheduleGroupRuleRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, metapb.ScheduleGroupRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventNotify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventNotify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventNotify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitEvent == nil {
				m.InitEvent = &InitEventData{}
			}
			if err := m.InitEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardEvent == nil {
				m.ShardEvent = &ShardEventData{}
			}
			if err := m.ShardEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StoreEvent == nil {
				m.StoreEvent = &StoreEventData{}
			}
			if err := m.StoreEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardStatsEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardStatsEvent == nil {
				m.ShardStatsEvent = &metapb.ShardStats{}
			}
			if err := m.ShardStatsEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreStatsEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StoreStatsEvent == nil {
				m.StoreStatsEvent = &metapb.StoreStats{}
			}
			if err := m.StoreStatsEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitEventData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitEventData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitEventData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, make([]byte, postIndex-iNdEx))
			copy(m.Shards[len(m.Shards)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Leaders = append(m.Leaders, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRpcpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRpcpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Leaders) == 0 {
					m.Leaders = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Leaders = append(m.Leaders, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Leaders", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stores", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stores = append(m.Stores, make([]byte, postIndex-iNdEx))
			copy(m.Stores[len(m.Stores)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardEventData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardEventData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardEventData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			m.Leader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leader |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Removed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Removed = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Create", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Create = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreEventData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreEventData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreEventData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Replica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeType", wireType)
			}
			m.ChangeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeType |= metapb.ConfigChangeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferLeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferLeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferLeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Replica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigChangeV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigChangeV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigChangeV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changes = append(m.Changes, ConfigChange{})
			if err := m.Changes[len(m.Changes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Merge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Merge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Merge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = append(m.Target[:0], dAtA[iNdEx:postIndex]...)
			if m.Target == nil {
				m.Target = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitShard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitShard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitShard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			m.Policy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Policy |= metapb.CheckPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabelConstraint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelConstraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelConstraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= LabelConstraintOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlacementRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlacementRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlacementRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Override", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Override = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= ReplicaRoleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelConstraints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LabelConstraints = append(m.LabelConstraints, LabelConstraint{})
			if err := m.LabelConstraints[len(m.LabelConstraints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocationLabels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocationLabels = append(m.LocationLabels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsolationLevel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IsolationLevel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestBatchHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestBatchHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestBatchHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Replica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseBatchHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseBatchHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseBatchHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, Request{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Responses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Responses = append(m.Responses, Response{})
			if err := m.Responses[len(m.Responses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= CmdType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomType", wireType)
			}
			m.CustomType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CustomType |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cmd = append(m.Cmd[:0], dAtA[iNdEx:postIndex]...)
			if m.Cmd == nil {
				m.Cmd = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PID", wireType)
			}
			m.PID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StopAt", wireType)
			}
			m.StopAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StopAt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToShard", wireType)
			}
			m.ToShard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToShard |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreEpochCheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreEpochCheck = bool(v != 0)
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Epoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= CmdType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomType", wireType)
			}
			m.CustomType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CustomType |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PID", wireType)
			}
			m.PID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigChangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigChangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigChangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeType", wireType)
			}
			m.ChangeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeType |= metapb.ConfigChangeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Replica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigChangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigChangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigChangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactLogRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactLogRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactLogRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactIndex", wireType)
			}
			m.CompactIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactLogResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactLogResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactLogResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferLeaderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferLeaderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferLeaderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Replica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferLeaderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferLeaderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferLeaderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyHashRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyHashRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyHashRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = append(m.Context[:0], dAtA[iNdEx:postIndex]...)
			if m.Context == nil {
				m.Context = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VerifyHashResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VerifyHashResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VerifyHashResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSplitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSplitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSplitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, SplitRequest{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = append(m.Context[:0], dAtA[iNdEx:postIndex]...)
			if m.Context == nil {
				m.Context = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Start = append(m.Start[:0], dAtA[iNdEx:postIndex]...)
			if m.Start == nil {
				m.Start = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.End = append(m.End[:0], dAtA[iNdEx:postIndex]...)
			if m.End == nil {
				m.End = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewShardID", wireType)
			}
			m.NewShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewShardID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewReplicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewReplicas = append(m.NewReplicas, metapb.Replica{})
			if err := m.NewReplicas[len(m.NewReplicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSplitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSplitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSplitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, metapb.Shard{})
			if err := m.Shards[len(m.Shards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateMetadataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateMetadataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateMetadataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateMetadataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateMetadataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateMetadataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateLabelsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateLabelsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateLabelsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, metapb.Label{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			m.Policy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Policy |= UpdatePolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateLabelsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateLabelsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateLabelsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRpcpb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRpcpb
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRpcpb
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRpcpb
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRpcpb        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRpcpb          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRpcpb = fmt.Errorf("proto: unexpected end of group")
)
