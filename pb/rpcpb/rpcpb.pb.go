// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: rpcpb.proto

package rpcpb

import (
	fmt "fmt"
	io "io"
	math "math"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	errorpb "github.com/matrixorigin/matrixcube/pb/errorpb"
	hlcpb "github.com/matrixorigin/matrixcube/pb/hlcpb"
	metapb "github.com/matrixorigin/matrixcube/pb/metapb"
	txnpb "github.com/matrixorigin/matrixcube/pb/txnpb"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

// Type rpc type
type Type int32

const (
	TypeRegisterStore           Type = 0
	TypeShardHeartbeatReq       Type = 1
	TypeShardHeartbeatRsp       Type = 2
	TypeStoreHeartbeatReq       Type = 3
	TypeStoreHeartbeatRsp       Type = 4
	TypePutStoreReq             Type = 5
	TypePutStoreRsp             Type = 6
	TypeGetStoreReq             Type = 7
	TypeGetStoreRsp             Type = 8
	TypeAllocIDReq              Type = 9
	TypeAllocIDRsp              Type = 10
	TypeAskBatchSplitReq        Type = 11
	TypeAskBatchSplitRsp        Type = 12
	TypeCreateDestroyingReq     Type = 13
	TypeCreateDestroyingRsp     Type = 14
	TypeReportDestroyedReq      Type = 15
	TypeReportDestroyedRsp      Type = 16
	TypeGetDestroyingReq        Type = 17
	TypeGetDestroyingRsp        Type = 18
	TypeCreateWatcherReq        Type = 19
	TypeEventNotify             Type = 20
	TypeCreateShardsReq         Type = 21
	TypeCreateShardsRsp         Type = 22
	TypeRemoveShardsReq         Type = 23
	TypeRemoveShardsRsp         Type = 24
	TypeCheckShardStateReq      Type = 25
	TypeCheckShardStateRsp      Type = 26
	TypePutPlacementRuleReq     Type = 27
	TypePutPlacementRuleRsp     Type = 28
	TypeGetAppliedRulesReq      Type = 29
	TypeGetAppliedRulesRsp      Type = 30
	TypeCreateJobReq            Type = 31
	TypeCreateJobRsp            Type = 32
	TypeRemoveJobReq            Type = 33
	TypeRemoveJobRsp            Type = 34
	TypeExecuteJobReq           Type = 35
	TypeExecuteJobRsp           Type = 36
	TypeAddScheduleGroupRuleReq Type = 37
	TypeAddScheduleGroupRuleRsp Type = 38
	TypeGetScheduleGroupRuleReq Type = 39
	TypeGetScheduleGroupRuleRsp Type = 40
)

var Type_name = map[int32]string{
	0:  "TypeRegisterStore",
	1:  "TypeShardHeartbeatReq",
	2:  "TypeShardHeartbeatRsp",
	3:  "TypeStoreHeartbeatReq",
	4:  "TypeStoreHeartbeatRsp",
	5:  "TypePutStoreReq",
	6:  "TypePutStoreRsp",
	7:  "TypeGetStoreReq",
	8:  "TypeGetStoreRsp",
	9:  "TypeAllocIDReq",
	10: "TypeAllocIDRsp",
	11: "TypeAskBatchSplitReq",
	12: "TypeAskBatchSplitRsp",
	13: "TypeCreateDestroyingReq",
	14: "TypeCreateDestroyingRsp",
	15: "TypeReportDestroyedReq",
	16: "TypeReportDestroyedRsp",
	17: "TypeGetDestroyingReq",
	18: "TypeGetDestroyingRsp",
	19: "TypeCreateWatcherReq",
	20: "TypeEventNotify",
	21: "TypeCreateShardsReq",
	22: "TypeCreateShardsRsp",
	23: "TypeRemoveShardsReq",
	24: "TypeRemoveShardsRsp",
	25: "TypeCheckShardStateReq",
	26: "TypeCheckShardStateRsp",
	27: "TypePutPlacementRuleReq",
	28: "TypePutPlacementRuleRsp",
	29: "TypeGetAppliedRulesReq",
	30: "TypeGetAppliedRulesRsp",
	31: "TypeCreateJobReq",
	32: "TypeCreateJobRsp",
	33: "TypeRemoveJobReq",
	34: "TypeRemoveJobRsp",
	35: "TypeExecuteJobReq",
	36: "TypeExecuteJobRsp",
	37: "TypeAddScheduleGroupRuleReq",
	38: "TypeAddScheduleGroupRuleRsp",
	39: "TypeGetScheduleGroupRuleReq",
	40: "TypeGetScheduleGroupRuleRsp",
}

var Type_value = map[string]int32{
	"TypeRegisterStore":           0,
	"TypeShardHeartbeatReq":       1,
	"TypeShardHeartbeatRsp":       2,
	"TypeStoreHeartbeatReq":       3,
	"TypeStoreHeartbeatRsp":       4,
	"TypePutStoreReq":             5,
	"TypePutStoreRsp":             6,
	"TypeGetStoreReq":             7,
	"TypeGetStoreRsp":             8,
	"TypeAllocIDReq":              9,
	"TypeAllocIDRsp":              10,
	"TypeAskBatchSplitReq":        11,
	"TypeAskBatchSplitRsp":        12,
	"TypeCreateDestroyingReq":     13,
	"TypeCreateDestroyingRsp":     14,
	"TypeReportDestroyedReq":      15,
	"TypeReportDestroyedRsp":      16,
	"TypeGetDestroyingReq":        17,
	"TypeGetDestroyingRsp":        18,
	"TypeCreateWatcherReq":        19,
	"TypeEventNotify":             20,
	"TypeCreateShardsReq":         21,
	"TypeCreateShardsRsp":         22,
	"TypeRemoveShardsReq":         23,
	"TypeRemoveShardsRsp":         24,
	"TypeCheckShardStateReq":      25,
	"TypeCheckShardStateRsp":      26,
	"TypePutPlacementRuleReq":     27,
	"TypePutPlacementRuleRsp":     28,
	"TypeGetAppliedRulesReq":      29,
	"TypeGetAppliedRulesRsp":      30,
	"TypeCreateJobReq":            31,
	"TypeCreateJobRsp":            32,
	"TypeRemoveJobReq":            33,
	"TypeRemoveJobRsp":            34,
	"TypeExecuteJobReq":           35,
	"TypeExecuteJobRsp":           36,
	"TypeAddScheduleGroupRuleReq": 37,
	"TypeAddScheduleGroupRuleRsp": 38,
	"TypeGetScheduleGroupRuleReq": 39,
	"TypeGetScheduleGroupRuleRsp": 40,
}

func (x Type) String() string {
	return proto.EnumName(Type_name, int32(x))
}

func (Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{0}
}

// PeerRoleType is the expected peer type of the placement rule
type ReplicaRoleType int32

const (
	// Voter can either match a leader peer or follower peer
	Voter ReplicaRoleType = 0
	// Leader matches a leader.
	Leader ReplicaRoleType = 1
	// Follower matches a follower.
	Follower ReplicaRoleType = 2
	// Learner matches a learner.
	Learner ReplicaRoleType = 3
)

var ReplicaRoleType_name = map[int32]string{
	0: "Voter",
	1: "Leader",
	2: "Follower",
	3: "Learner",
}

var ReplicaRoleType_value = map[string]int32{
	"Voter":    0,
	"Leader":   1,
	"Follower": 2,
	"Learner":  3,
}

func (x ReplicaRoleType) String() string {
	return proto.EnumName(ReplicaRoleType_name, int32(x))
}

func (ReplicaRoleType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{1}
}

// LabelConstraintOp defines how a LabelConstraint matches a store. It can be one of
// 'in', 'notIn', 'exists', or 'notExists'.
type LabelConstraintOp int32

const (
	// In If label does not exist, `in` is always false.
	In LabelConstraintOp = 0
	// NotIn restricts the store label value should not in the value list.
	NotIn LabelConstraintOp = 1
	// Exists restricts the store should have the label.
	Exists LabelConstraintOp = 2
	// NotExists restricts the store should not have the label.
	NotExists LabelConstraintOp = 3
)

var LabelConstraintOp_name = map[int32]string{
	0: "In",
	1: "NotIn",
	2: "Exists",
	3: "NotExists",
}

var LabelConstraintOp_value = map[string]int32{
	"In":        0,
	"NotIn":     1,
	"Exists":    2,
	"NotExists": 3,
}

func (x LabelConstraintOp) String() string {
	return proto.EnumName(LabelConstraintOp_name, int32(x))
}

func (LabelConstraintOp) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{2}
}

// CmdType command type
type CmdType int32

const (
	// Write write command, need raft consensus
	Write CmdType = 0
	// Read read command, need raft consensus(read index or lease read)
	Read CmdType = 1
	// Admin admin command, need raft consensus
	Admin CmdType = 2
	// Txn reuse ShardsDispatch to forward txn rpc messages
	Txn CmdType = 3
)

var CmdType_name = map[int32]string{
	0: "Write",
	1: "Read",
	2: "Admin",
	3: "Txn",
}

var CmdType_value = map[string]int32{
	"Write": 0,
	"Read":  1,
	"Admin": 2,
	"Txn":   3,
}

func (x CmdType) String() string {
	return proto.EnumName(CmdType_name, int32(x))
}

func (CmdType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{3}
}

// InternalCmd internal reserved commands
type InternalCmd int32

const (
	// CmdConfigChange config change command, admin type
	CmdConfigChange InternalCmd = 0
	// CmdCompactLog compact log command, admin type
	CmdCompactLog InternalCmd = 1
	// CmdTransferLeader transfer leader command, admin type
	CmdTransferLeader InternalCmd = 2
	// CmdBatchSplit batch split command, admin type
	CmdBatchSplit InternalCmd = 5
	// CmdUpdateMetadata update shard metadata command, admin type
	CmdUpdateMetadata InternalCmd = 6
	// CmdUpdateLabels update shard label command, admin type
	CmdUpdateLabels InternalCmd = 7
	// CmdUpdateTxnRecord update txn record command, write type
	CmdUpdateTxnRecord InternalCmd = 100
	// CmdDeleteTxnRecord delete txn record command, write type
	CmdDeleteTxnRecord InternalCmd = 101
	// CmdCommitTxnData commit txn write data, write type
	CmdCommitTxnData InternalCmd = 102
	// CmdRollbackTxnData rollback txn write data, write type
	CmdRollbackTxnData InternalCmd = 103
	// CmdCleanTxnMVCCData clean txn mvcc data, write type
	CmdCleanTxnMVCCData InternalCmd = 104
	// CmdKVSet  kv set command, write type
	CmdKVSet InternalCmd = 200
	// CmdKVBatchSet kv batch set command, write type
	CmdKVBatchSet InternalCmd = 201
	// CmdKVGet kv get command, read type
	CmdKVGet InternalCmd = 202
	// CmdKVBatchGet kv batch get command, read type
	CmdKVBatchGet InternalCmd = 203
	// CmdKVDelete kv delete command, write type
	CmdKVDelete InternalCmd = 204
	// CmdKVBatchDelete kv batch delete command, write type
	CmdKVBatchDelete InternalCmd = 205
	// CmdKVRangeDelete kv range delete command, write type
	CmdKVRangeDelete InternalCmd = 206
	// CmdKVScan kv scan command, read type
	CmdKVScan InternalCmd = 207
	// CmdReserved cube reserved cmd type value, all custom cmd type read and
	// write cmd type can not use the value below the reserved value.
	CmdReserved InternalCmd = 1000
)

var InternalCmd_name = map[int32]string{
	0:    "CmdConfigChange",
	1:    "CmdCompactLog",
	2:    "CmdTransferLeader",
	5:    "CmdBatchSplit",
	6:    "CmdUpdateMetadata",
	7:    "CmdUpdateLabels",
	100:  "CmdUpdateTxnRecord",
	101:  "CmdDeleteTxnRecord",
	102:  "CmdCommitTxnData",
	103:  "CmdRollbackTxnData",
	104:  "CmdCleanTxnMVCCData",
	200:  "CmdKVSet",
	201:  "CmdKVBatchSet",
	202:  "CmdKVGet",
	203:  "CmdKVBatchGet",
	204:  "CmdKVDelete",
	205:  "CmdKVBatchDelete",
	206:  "CmdKVRangeDelete",
	207:  "CmdKVScan",
	1000: "CmdReserved",
}

var InternalCmd_value = map[string]int32{
	"CmdConfigChange":     0,
	"CmdCompactLog":       1,
	"CmdTransferLeader":   2,
	"CmdBatchSplit":       5,
	"CmdUpdateMetadata":   6,
	"CmdUpdateLabels":     7,
	"CmdUpdateTxnRecord":  100,
	"CmdDeleteTxnRecord":  101,
	"CmdCommitTxnData":    102,
	"CmdRollbackTxnData":  103,
	"CmdCleanTxnMVCCData": 104,
	"CmdKVSet":            200,
	"CmdKVBatchSet":       201,
	"CmdKVGet":            202,
	"CmdKVBatchGet":       203,
	"CmdKVDelete":         204,
	"CmdKVBatchDelete":    205,
	"CmdKVRangeDelete":    206,
	"CmdKVScan":           207,
	"CmdReserved":         1000,
}

func (x InternalCmd) String() string {
	return proto.EnumName(InternalCmd_name, int32(x))
}

func (InternalCmd) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{4}
}

// UpdatePolicy update policy
type UpdatePolicy int32

const (
	// Add add or update
	Add UpdatePolicy = 0
	// Remove remove
	Remove UpdatePolicy = 1
	// Reset reset
	Reset UpdatePolicy = 2
	// Clear clear
	Clear UpdatePolicy = 3
)

var UpdatePolicy_name = map[int32]string{
	0: "Add",
	1: "Remove",
	2: "Reset",
	3: "Clear",
}

var UpdatePolicy_value = map[string]int32{
	"Add":    0,
	"Remove": 1,
	"Reset":  2,
	"Clear":  3,
}

func (x UpdatePolicy) String() string {
	return proto.EnumName(UpdatePolicy_name, int32(x))
}

func (UpdatePolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{5}
}

// ReplicaSelectPolicy strategies for selecting replica
type ReplicaSelectPolicy int32

const (
	// SelectLeader select leader replica store
	SelectLeader ReplicaSelectPolicy = 0
	// SelectRandom select random replica store
	SelectRandom ReplicaSelectPolicy = 1
	// SelectLeaseHolder select replica lease holder store
	SelectLeaseHolder ReplicaSelectPolicy = 2
)

var ReplicaSelectPolicy_name = map[int32]string{
	0: "SelectLeader",
	1: "SelectRandom",
	2: "SelectLeaseHolder",
}

var ReplicaSelectPolicy_value = map[string]int32{
	"SelectLeader":      0,
	"SelectRandom":      1,
	"SelectLeaseHolder": 2,
}

func (x ReplicaSelectPolicy) String() string {
	return proto.EnumName(ReplicaSelectPolicy_name, int32(x))
}

func (ReplicaSelectPolicy) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{6}
}

// ProphetRequest the prophet rpc request
type ProphetRequest struct {
	ID                   uint64                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	StoreID              uint64                  `protobuf:"varint,2,opt,name=storeID,proto3" json:"storeID,omitempty"`
	Type                 Type                    `protobuf:"varint,3,opt,name=type,proto3,enum=rpcpb.Type" json:"type,omitempty"`
	ShardHeartbeat       ShardHeartbeatReq       `protobuf:"bytes,4,opt,name=shardHeartbeat,proto3" json:"shardHeartbeat"`
	StoreHeartbeat       StoreHeartbeatReq       `protobuf:"bytes,5,opt,name=storeHeartbeat,proto3" json:"storeHeartbeat"`
	PutStore             PutStoreReq             `protobuf:"bytes,6,opt,name=putStore,proto3" json:"putStore"`
	GetStore             GetStoreReq             `protobuf:"bytes,7,opt,name=getStore,proto3" json:"getStore"`
	AllocID              AllocIDReq              `protobuf:"bytes,8,opt,name=allocID,proto3" json:"allocID"`
	AskBatchSplit        AskBatchSplitReq        `protobuf:"bytes,9,opt,name=askBatchSplit,proto3" json:"askBatchSplit"`
	CreateDestroying     CreateDestroyingReq     `protobuf:"bytes,10,opt,name=createDestroying,proto3" json:"createDestroying"`
	ReportDestroyed      ReportDestroyedReq      `protobuf:"bytes,11,opt,name=ReportDestroyed,proto3" json:"ReportDestroyed"`
	GetDestroying        GetDestroyingReq        `protobuf:"bytes,12,opt,name=getDestroying,proto3" json:"getDestroying"`
	CreateWatcher        CreateWatcherReq        `protobuf:"bytes,13,opt,name=createWatcher,proto3" json:"createWatcher"`
	CreateShards         CreateShardsReq         `protobuf:"bytes,14,opt,name=createShards,proto3" json:"createShards"`
	RemoveShards         RemoveShardsReq         `protobuf:"bytes,15,opt,name=removeShards,proto3" json:"removeShards"`
	CheckShardState      CheckShardStateReq      `protobuf:"bytes,16,opt,name=checkShardState,proto3" json:"checkShardState"`
	PutPlacementRule     PutPlacementRuleReq     `protobuf:"bytes,17,opt,name=putPlacementRule,proto3" json:"putPlacementRule"`
	GetAppliedRules      GetAppliedRulesReq      `protobuf:"bytes,18,opt,name=getAppliedRules,proto3" json:"getAppliedRules"`
	CreateJob            CreateJobReq            `protobuf:"bytes,19,opt,name=createJob,proto3" json:"createJob"`
	RemoveJob            RemoveJobReq            `protobuf:"bytes,20,opt,name=removeJob,proto3" json:"removeJob"`
	ExecuteJob           ExecuteJobReq           `protobuf:"bytes,21,opt,name=executeJob,proto3" json:"executeJob"`
	AddScheduleGroupRule AddScheduleGroupRuleReq `protobuf:"bytes,22,opt,name=addScheduleGroupRule,proto3" json:"addScheduleGroupRule"`
	GetScheduleGroupRule GetScheduleGroupRuleReq `protobuf:"bytes,23,opt,name=getScheduleGroupRule,proto3" json:"getScheduleGroupRule"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *ProphetRequest) Reset()         { *m = ProphetRequest{} }
func (m *ProphetRequest) String() string { return proto.CompactTextString(m) }
func (*ProphetRequest) ProtoMessage()    {}
func (*ProphetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{0}
}
func (m *ProphetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProphetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProphetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProphetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProphetRequest.Merge(m, src)
}
func (m *ProphetRequest) XXX_Size() int {
	return m.Size()
}
func (m *ProphetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ProphetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ProphetRequest proto.InternalMessageInfo

func (m *ProphetRequest) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ProphetRequest) GetStoreID() uint64 {
	if m != nil {
		return m.StoreID
	}
	return 0
}

func (m *ProphetRequest) GetType() Type {
	if m != nil {
		return m.Type
	}
	return TypeRegisterStore
}

func (m *ProphetRequest) GetShardHeartbeat() ShardHeartbeatReq {
	if m != nil {
		return m.ShardHeartbeat
	}
	return ShardHeartbeatReq{}
}

func (m *ProphetRequest) GetStoreHeartbeat() StoreHeartbeatReq {
	if m != nil {
		return m.StoreHeartbeat
	}
	return StoreHeartbeatReq{}
}

func (m *ProphetRequest) GetPutStore() PutStoreReq {
	if m != nil {
		return m.PutStore
	}
	return PutStoreReq{}
}

func (m *ProphetRequest) GetGetStore() GetStoreReq {
	if m != nil {
		return m.GetStore
	}
	return GetStoreReq{}
}

func (m *ProphetRequest) GetAllocID() AllocIDReq {
	if m != nil {
		return m.AllocID
	}
	return AllocIDReq{}
}

func (m *ProphetRequest) GetAskBatchSplit() AskBatchSplitReq {
	if m != nil {
		return m.AskBatchSplit
	}
	return AskBatchSplitReq{}
}

func (m *ProphetRequest) GetCreateDestroying() CreateDestroyingReq {
	if m != nil {
		return m.CreateDestroying
	}
	return CreateDestroyingReq{}
}

func (m *ProphetRequest) GetReportDestroyed() ReportDestroyedReq {
	if m != nil {
		return m.ReportDestroyed
	}
	return ReportDestroyedReq{}
}

func (m *ProphetRequest) GetGetDestroying() GetDestroyingReq {
	if m != nil {
		return m.GetDestroying
	}
	return GetDestroyingReq{}
}

func (m *ProphetRequest) GetCreateWatcher() CreateWatcherReq {
	if m != nil {
		return m.CreateWatcher
	}
	return CreateWatcherReq{}
}

func (m *ProphetRequest) GetCreateShards() CreateShardsReq {
	if m != nil {
		return m.CreateShards
	}
	return CreateShardsReq{}
}

func (m *ProphetRequest) GetRemoveShards() RemoveShardsReq {
	if m != nil {
		return m.RemoveShards
	}
	return RemoveShardsReq{}
}

func (m *ProphetRequest) GetCheckShardState() CheckShardStateReq {
	if m != nil {
		return m.CheckShardState
	}
	return CheckShardStateReq{}
}

func (m *ProphetRequest) GetPutPlacementRule() PutPlacementRuleReq {
	if m != nil {
		return m.PutPlacementRule
	}
	return PutPlacementRuleReq{}
}

func (m *ProphetRequest) GetGetAppliedRules() GetAppliedRulesReq {
	if m != nil {
		return m.GetAppliedRules
	}
	return GetAppliedRulesReq{}
}

func (m *ProphetRequest) GetCreateJob() CreateJobReq {
	if m != nil {
		return m.CreateJob
	}
	return CreateJobReq{}
}

func (m *ProphetRequest) GetRemoveJob() RemoveJobReq {
	if m != nil {
		return m.RemoveJob
	}
	return RemoveJobReq{}
}

func (m *ProphetRequest) GetExecuteJob() ExecuteJobReq {
	if m != nil {
		return m.ExecuteJob
	}
	return ExecuteJobReq{}
}

func (m *ProphetRequest) GetAddScheduleGroupRule() AddScheduleGroupRuleReq {
	if m != nil {
		return m.AddScheduleGroupRule
	}
	return AddScheduleGroupRuleReq{}
}

func (m *ProphetRequest) GetGetScheduleGroupRule() GetScheduleGroupRuleReq {
	if m != nil {
		return m.GetScheduleGroupRule
	}
	return GetScheduleGroupRuleReq{}
}

// ProphetResponse the prophet rpc response
type ProphetResponse struct {
	ID                   uint64                  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type                 Type                    `protobuf:"varint,2,opt,name=type,proto3,enum=rpcpb.Type" json:"type,omitempty"`
	Error                string                  `protobuf:"bytes,3,opt,name=error,proto3" json:"error,omitempty"`
	Leader               string                  `protobuf:"bytes,4,opt,name=leader,proto3" json:"leader,omitempty"`
	ShardHeartbeat       ShardHeartbeatRsp       `protobuf:"bytes,5,opt,name=shardHeartbeat,proto3" json:"shardHeartbeat"`
	StoreHeartbeat       StoreHeartbeatRsp       `protobuf:"bytes,6,opt,name=storeHeartbeat,proto3" json:"storeHeartbeat"`
	PutStore             PutStoreRsp             `protobuf:"bytes,7,opt,name=putStore,proto3" json:"putStore"`
	GetStore             GetStoreRsp             `protobuf:"bytes,8,opt,name=getStore,proto3" json:"getStore"`
	AllocID              AllocIDRsp              `protobuf:"bytes,9,opt,name=allocID,proto3" json:"allocID"`
	AskBatchSplit        AskBatchSplitRsp        `protobuf:"bytes,10,opt,name=askBatchSplit,proto3" json:"askBatchSplit"`
	CreateDestroying     CreateDestroyingRsp     `protobuf:"bytes,11,opt,name=createDestroying,proto3" json:"createDestroying"`
	ReportDestroyed      ReportDestroyedRsp      `protobuf:"bytes,12,opt,name=ReportDestroyed,proto3" json:"ReportDestroyed"`
	GetDestroying        GetDestroyingRsp        `protobuf:"bytes,13,opt,name=getDestroying,proto3" json:"getDestroying"`
	Event                EventNotify             `protobuf:"bytes,14,opt,name=event,proto3" json:"event"`
	CreateShards         CreateShardsRsp         `protobuf:"bytes,15,opt,name=createShards,proto3" json:"createShards"`
	RemoveShards         RemoveShardsRsp         `protobuf:"bytes,16,opt,name=removeShards,proto3" json:"removeShards"`
	CheckShardState      CheckShardStateRsp      `protobuf:"bytes,17,opt,name=checkShardState,proto3" json:"checkShardState"`
	PutPlacementRule     PutPlacementRuleRsp     `protobuf:"bytes,18,opt,name=putPlacementRule,proto3" json:"putPlacementRule"`
	GetAppliedRules      GetAppliedRulesRsp      `protobuf:"bytes,19,opt,name=getAppliedRules,proto3" json:"getAppliedRules"`
	CreateJob            CreateJobRsp            `protobuf:"bytes,20,opt,name=createJob,proto3" json:"createJob"`
	RemoveJob            RemoveJobRsp            `protobuf:"bytes,21,opt,name=removeJob,proto3" json:"removeJob"`
	ExecuteJob           ExecuteJobRsp           `protobuf:"bytes,22,opt,name=executeJob,proto3" json:"executeJob"`
	AddScheduleGroupRule AddScheduleGroupRuleRsp `protobuf:"bytes,23,opt,name=addScheduleGroupRule,proto3" json:"addScheduleGroupRule"`
	GetScheduleGroupRule GetScheduleGroupRuleRsp `protobuf:"bytes,24,opt,name=getScheduleGroupRule,proto3" json:"getScheduleGroupRule"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *ProphetResponse) Reset()         { *m = ProphetResponse{} }
func (m *ProphetResponse) String() string { return proto.CompactTextString(m) }
func (*ProphetResponse) ProtoMessage()    {}
func (*ProphetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{1}
}
func (m *ProphetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProphetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProphetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProphetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProphetResponse.Merge(m, src)
}
func (m *ProphetResponse) XXX_Size() int {
	return m.Size()
}
func (m *ProphetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ProphetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ProphetResponse proto.InternalMessageInfo

func (m *ProphetResponse) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ProphetResponse) GetType() Type {
	if m != nil {
		return m.Type
	}
	return TypeRegisterStore
}

func (m *ProphetResponse) GetError() string {
	if m != nil {
		return m.Error
	}
	return ""
}

func (m *ProphetResponse) GetLeader() string {
	if m != nil {
		return m.Leader
	}
	return ""
}

func (m *ProphetResponse) GetShardHeartbeat() ShardHeartbeatRsp {
	if m != nil {
		return m.ShardHeartbeat
	}
	return ShardHeartbeatRsp{}
}

func (m *ProphetResponse) GetStoreHeartbeat() StoreHeartbeatRsp {
	if m != nil {
		return m.StoreHeartbeat
	}
	return StoreHeartbeatRsp{}
}

func (m *ProphetResponse) GetPutStore() PutStoreRsp {
	if m != nil {
		return m.PutStore
	}
	return PutStoreRsp{}
}

func (m *ProphetResponse) GetGetStore() GetStoreRsp {
	if m != nil {
		return m.GetStore
	}
	return GetStoreRsp{}
}

func (m *ProphetResponse) GetAllocID() AllocIDRsp {
	if m != nil {
		return m.AllocID
	}
	return AllocIDRsp{}
}

func (m *ProphetResponse) GetAskBatchSplit() AskBatchSplitRsp {
	if m != nil {
		return m.AskBatchSplit
	}
	return AskBatchSplitRsp{}
}

func (m *ProphetResponse) GetCreateDestroying() CreateDestroyingRsp {
	if m != nil {
		return m.CreateDestroying
	}
	return CreateDestroyingRsp{}
}

func (m *ProphetResponse) GetReportDestroyed() ReportDestroyedRsp {
	if m != nil {
		return m.ReportDestroyed
	}
	return ReportDestroyedRsp{}
}

func (m *ProphetResponse) GetGetDestroying() GetDestroyingRsp {
	if m != nil {
		return m.GetDestroying
	}
	return GetDestroyingRsp{}
}

func (m *ProphetResponse) GetEvent() EventNotify {
	if m != nil {
		return m.Event
	}
	return EventNotify{}
}

func (m *ProphetResponse) GetCreateShards() CreateShardsRsp {
	if m != nil {
		return m.CreateShards
	}
	return CreateShardsRsp{}
}

func (m *ProphetResponse) GetRemoveShards() RemoveShardsRsp {
	if m != nil {
		return m.RemoveShards
	}
	return RemoveShardsRsp{}
}

func (m *ProphetResponse) GetCheckShardState() CheckShardStateRsp {
	if m != nil {
		return m.CheckShardState
	}
	return CheckShardStateRsp{}
}

func (m *ProphetResponse) GetPutPlacementRule() PutPlacementRuleRsp {
	if m != nil {
		return m.PutPlacementRule
	}
	return PutPlacementRuleRsp{}
}

func (m *ProphetResponse) GetGetAppliedRules() GetAppliedRulesRsp {
	if m != nil {
		return m.GetAppliedRules
	}
	return GetAppliedRulesRsp{}
}

func (m *ProphetResponse) GetCreateJob() CreateJobRsp {
	if m != nil {
		return m.CreateJob
	}
	return CreateJobRsp{}
}

func (m *ProphetResponse) GetRemoveJob() RemoveJobRsp {
	if m != nil {
		return m.RemoveJob
	}
	return RemoveJobRsp{}
}

func (m *ProphetResponse) GetExecuteJob() ExecuteJobRsp {
	if m != nil {
		return m.ExecuteJob
	}
	return ExecuteJobRsp{}
}

func (m *ProphetResponse) GetAddScheduleGroupRule() AddScheduleGroupRuleRsp {
	if m != nil {
		return m.AddScheduleGroupRule
	}
	return AddScheduleGroupRuleRsp{}
}

func (m *ProphetResponse) GetGetScheduleGroupRule() GetScheduleGroupRuleRsp {
	if m != nil {
		return m.GetScheduleGroupRule
	}
	return GetScheduleGroupRuleRsp{}
}

// ShardHeartbeatReq shard heartbeat request
type ShardHeartbeatReq struct {
	StoreID uint64 `protobuf:"varint,1,opt,name=storeID,proto3" json:"storeID,omitempty"`
	Shard   []byte `protobuf:"bytes,2,opt,name=shard,proto3" json:"shard,omitempty"`
	// Term is the term of raft group.
	Term                 uint64                `protobuf:"varint,3,opt,name=term,proto3" json:"term,omitempty"`
	Leader               *metapb.Replica       `protobuf:"bytes,4,opt,name=leader,proto3" json:"leader,omitempty"`
	DownReplicas         []metapb.ReplicaStats `protobuf:"bytes,5,rep,name=downReplicas,proto3" json:"downReplicas"`
	PendingReplicas      []metapb.Replica      `protobuf:"bytes,6,rep,name=pendingReplicas,proto3" json:"pendingReplicas"`
	Stats                metapb.ShardStats     `protobuf:"bytes,7,opt,name=stats,proto3" json:"stats"`
	GroupKey             string                `protobuf:"bytes,8,opt,name=groupKey,proto3" json:"groupKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *ShardHeartbeatReq) Reset()         { *m = ShardHeartbeatReq{} }
func (m *ShardHeartbeatReq) String() string { return proto.CompactTextString(m) }
func (*ShardHeartbeatReq) ProtoMessage()    {}
func (*ShardHeartbeatReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{2}
}
func (m *ShardHeartbeatReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardHeartbeatReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardHeartbeatReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardHeartbeatReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardHeartbeatReq.Merge(m, src)
}
func (m *ShardHeartbeatReq) XXX_Size() int {
	return m.Size()
}
func (m *ShardHeartbeatReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardHeartbeatReq.DiscardUnknown(m)
}

var xxx_messageInfo_ShardHeartbeatReq proto.InternalMessageInfo

func (m *ShardHeartbeatReq) GetStoreID() uint64 {
	if m != nil {
		return m.StoreID
	}
	return 0
}

func (m *ShardHeartbeatReq) GetShard() []byte {
	if m != nil {
		return m.Shard
	}
	return nil
}

func (m *ShardHeartbeatReq) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *ShardHeartbeatReq) GetLeader() *metapb.Replica {
	if m != nil {
		return m.Leader
	}
	return nil
}

func (m *ShardHeartbeatReq) GetDownReplicas() []metapb.ReplicaStats {
	if m != nil {
		return m.DownReplicas
	}
	return nil
}

func (m *ShardHeartbeatReq) GetPendingReplicas() []metapb.Replica {
	if m != nil {
		return m.PendingReplicas
	}
	return nil
}

func (m *ShardHeartbeatReq) GetStats() metapb.ShardStats {
	if m != nil {
		return m.Stats
	}
	return metapb.ShardStats{}
}

func (m *ShardHeartbeatReq) GetGroupKey() string {
	if m != nil {
		return m.GroupKey
	}
	return ""
}

// ShardHeartbeatRsp shard heartbeat response.
type ShardHeartbeatRsp struct {
	ShardID    uint64            `protobuf:"varint,1,opt,name=shardID,proto3" json:"shardID,omitempty"`
	ShardEpoch metapb.ShardEpoch `protobuf:"bytes,2,opt,name=shardEpoch,proto3" json:"shardEpoch"`
	// Leader of the shard at the moment of the corresponding request was made.
	TargetReplica *metapb.Replica `protobuf:"bytes,3,opt,name=targetReplica,proto3" json:"targetReplica,omitempty"`
	// Notice, prophet only allows handling reported epoch >= current prophet's.
	// Leader peer reports shard status with ShardHeartbeatReq
	// to prophet regularly, prophet will determine whether this shard
	// should do ChangePeer or not.
	// E,g, max peer number is 3, shard A, first only peer 1 in A.
	// 1. prophet shard state -> Peers (1), ConfVer (1).
	// 2. Leader peer 1 reports shard state to prophet, prophet finds the
	// peer number is < 3, so first changes its current shard
	// state -> Peers (1, 2), ConfVer (1), and returns ChangePeer Adding 2.
	// 3. Leader does ChangePeer, then reports Peers (1, 2), ConfVer (2),
	// prophet updates its state -> Peers (1, 2), ConfVer (2).
	// 4. Leader may report old Peers (1), ConfVer (1) to pd before ConfChange
	// finished, pd stills responses ChangePeer Adding 2, of course, we must
	// guarantee the second ChangePeer can't be applied in your application.
	ConfigChange   *ConfigChange   `protobuf:"bytes,4,opt,name=configChange,proto3" json:"configChange,omitempty"`
	TransferLeader *TransferLeader `protobuf:"bytes,5,opt,name=transferLeader,proto3" json:"transferLeader,omitempty"`
	Merge          *Merge          `protobuf:"bytes,6,opt,name=merge,proto3" json:"merge,omitempty"`
	SplitShard     *SplitShard     `protobuf:"bytes,7,opt,name=splitShard,proto3" json:"splitShard,omitempty"`
	ConfigChangeV2 *ConfigChangeV2 `protobuf:"bytes,8,opt,name=configChangeV2,proto3" json:"configChangeV2,omitempty"`
	// DestroyDirectly the shard has been removed, destroy directly without raft.
	DestroyDirectly      bool     `protobuf:"varint,9,opt,name=destroyDirectly,proto3" json:"destroyDirectly,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShardHeartbeatRsp) Reset()         { *m = ShardHeartbeatRsp{} }
func (m *ShardHeartbeatRsp) String() string { return proto.CompactTextString(m) }
func (*ShardHeartbeatRsp) ProtoMessage()    {}
func (*ShardHeartbeatRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{3}
}
func (m *ShardHeartbeatRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardHeartbeatRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardHeartbeatRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardHeartbeatRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardHeartbeatRsp.Merge(m, src)
}
func (m *ShardHeartbeatRsp) XXX_Size() int {
	return m.Size()
}
func (m *ShardHeartbeatRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardHeartbeatRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ShardHeartbeatRsp proto.InternalMessageInfo

func (m *ShardHeartbeatRsp) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *ShardHeartbeatRsp) GetShardEpoch() metapb.ShardEpoch {
	if m != nil {
		return m.ShardEpoch
	}
	return metapb.ShardEpoch{}
}

func (m *ShardHeartbeatRsp) GetTargetReplica() *metapb.Replica {
	if m != nil {
		return m.TargetReplica
	}
	return nil
}

func (m *ShardHeartbeatRsp) GetConfigChange() *ConfigChange {
	if m != nil {
		return m.ConfigChange
	}
	return nil
}

func (m *ShardHeartbeatRsp) GetTransferLeader() *TransferLeader {
	if m != nil {
		return m.TransferLeader
	}
	return nil
}

func (m *ShardHeartbeatRsp) GetMerge() *Merge {
	if m != nil {
		return m.Merge
	}
	return nil
}

func (m *ShardHeartbeatRsp) GetSplitShard() *SplitShard {
	if m != nil {
		return m.SplitShard
	}
	return nil
}

func (m *ShardHeartbeatRsp) GetConfigChangeV2() *ConfigChangeV2 {
	if m != nil {
		return m.ConfigChangeV2
	}
	return nil
}

func (m *ShardHeartbeatRsp) GetDestroyDirectly() bool {
	if m != nil {
		return m.DestroyDirectly
	}
	return false
}

// PutStoreReq put store request
type PutStoreReq struct {
	Store                []byte   `protobuf:"bytes,1,opt,name=store,proto3" json:"store,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PutStoreReq) Reset()         { *m = PutStoreReq{} }
func (m *PutStoreReq) String() string { return proto.CompactTextString(m) }
func (*PutStoreReq) ProtoMessage()    {}
func (*PutStoreReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{4}
}
func (m *PutStoreReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutStoreReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutStoreReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutStoreReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutStoreReq.Merge(m, src)
}
func (m *PutStoreReq) XXX_Size() int {
	return m.Size()
}
func (m *PutStoreReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PutStoreReq.DiscardUnknown(m)
}

var xxx_messageInfo_PutStoreReq proto.InternalMessageInfo

func (m *PutStoreReq) GetStore() []byte {
	if m != nil {
		return m.Store
	}
	return nil
}

// PutStoreRsp put store response
type PutStoreRsp struct {
	DestroyShards        []byte   `protobuf:"bytes,1,opt,name=destroyShards,proto3" json:"destroyShards,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PutStoreRsp) Reset()         { *m = PutStoreRsp{} }
func (m *PutStoreRsp) String() string { return proto.CompactTextString(m) }
func (*PutStoreRsp) ProtoMessage()    {}
func (*PutStoreRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{5}
}
func (m *PutStoreRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutStoreRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutStoreRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutStoreRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutStoreRsp.Merge(m, src)
}
func (m *PutStoreRsp) XXX_Size() int {
	return m.Size()
}
func (m *PutStoreRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_PutStoreRsp.DiscardUnknown(m)
}

var xxx_messageInfo_PutStoreRsp proto.InternalMessageInfo

func (m *PutStoreRsp) GetDestroyShards() []byte {
	if m != nil {
		return m.DestroyShards
	}
	return nil
}

// StoreHeartbeatReq store heartbeat request
type StoreHeartbeatReq struct {
	Stats                metapb.StoreStats `protobuf:"bytes,1,opt,name=stats,proto3" json:"stats"`
	Data                 []byte            `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *StoreHeartbeatReq) Reset()         { *m = StoreHeartbeatReq{} }
func (m *StoreHeartbeatReq) String() string { return proto.CompactTextString(m) }
func (*StoreHeartbeatReq) ProtoMessage()    {}
func (*StoreHeartbeatReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{6}
}
func (m *StoreHeartbeatReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreHeartbeatReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreHeartbeatReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreHeartbeatReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreHeartbeatReq.Merge(m, src)
}
func (m *StoreHeartbeatReq) XXX_Size() int {
	return m.Size()
}
func (m *StoreHeartbeatReq) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreHeartbeatReq.DiscardUnknown(m)
}

var xxx_messageInfo_StoreHeartbeatReq proto.InternalMessageInfo

func (m *StoreHeartbeatReq) GetStats() metapb.StoreStats {
	if m != nil {
		return m.Stats
	}
	return metapb.StoreStats{}
}

func (m *StoreHeartbeatReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// StoreHeartbeatRsp store heartbeat response
type StoreHeartbeatRsp struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StoreHeartbeatRsp) Reset()         { *m = StoreHeartbeatRsp{} }
func (m *StoreHeartbeatRsp) String() string { return proto.CompactTextString(m) }
func (*StoreHeartbeatRsp) ProtoMessage()    {}
func (*StoreHeartbeatRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{7}
}
func (m *StoreHeartbeatRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreHeartbeatRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreHeartbeatRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreHeartbeatRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreHeartbeatRsp.Merge(m, src)
}
func (m *StoreHeartbeatRsp) XXX_Size() int {
	return m.Size()
}
func (m *StoreHeartbeatRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreHeartbeatRsp.DiscardUnknown(m)
}

var xxx_messageInfo_StoreHeartbeatRsp proto.InternalMessageInfo

func (m *StoreHeartbeatRsp) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// GetStoreReq get store request
type GetStoreReq struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetStoreReq) Reset()         { *m = GetStoreReq{} }
func (m *GetStoreReq) String() string { return proto.CompactTextString(m) }
func (*GetStoreReq) ProtoMessage()    {}
func (*GetStoreReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{8}
}
func (m *GetStoreReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStoreReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetStoreReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetStoreReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStoreReq.Merge(m, src)
}
func (m *GetStoreReq) XXX_Size() int {
	return m.Size()
}
func (m *GetStoreReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStoreReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetStoreReq proto.InternalMessageInfo

func (m *GetStoreReq) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

// GetStoreRsp get store response
type GetStoreRsp struct {
	Data                 []byte             `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Stats                *metapb.StoreStats `protobuf:"bytes,2,opt,name=stats,proto3" json:"stats,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *GetStoreRsp) Reset()         { *m = GetStoreRsp{} }
func (m *GetStoreRsp) String() string { return proto.CompactTextString(m) }
func (*GetStoreRsp) ProtoMessage()    {}
func (*GetStoreRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{9}
}
func (m *GetStoreRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStoreRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetStoreRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetStoreRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStoreRsp.Merge(m, src)
}
func (m *GetStoreRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetStoreRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStoreRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetStoreRsp proto.InternalMessageInfo

func (m *GetStoreRsp) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *GetStoreRsp) GetStats() *metapb.StoreStats {
	if m != nil {
		return m.Stats
	}
	return nil
}

// AllocIDReq alloc id request
type AllocIDReq struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AllocIDReq) Reset()         { *m = AllocIDReq{} }
func (m *AllocIDReq) String() string { return proto.CompactTextString(m) }
func (*AllocIDReq) ProtoMessage()    {}
func (*AllocIDReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{10}
}
func (m *AllocIDReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocIDReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllocIDReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllocIDReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocIDReq.Merge(m, src)
}
func (m *AllocIDReq) XXX_Size() int {
	return m.Size()
}
func (m *AllocIDReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocIDReq.DiscardUnknown(m)
}

var xxx_messageInfo_AllocIDReq proto.InternalMessageInfo

// AllocIDRsp alloc id response
type AllocIDRsp struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AllocIDRsp) Reset()         { *m = AllocIDRsp{} }
func (m *AllocIDRsp) String() string { return proto.CompactTextString(m) }
func (*AllocIDRsp) ProtoMessage()    {}
func (*AllocIDRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{11}
}
func (m *AllocIDRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllocIDRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllocIDRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllocIDRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllocIDRsp.Merge(m, src)
}
func (m *AllocIDRsp) XXX_Size() int {
	return m.Size()
}
func (m *AllocIDRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_AllocIDRsp.DiscardUnknown(m)
}

var xxx_messageInfo_AllocIDRsp proto.InternalMessageInfo

func (m *AllocIDRsp) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

// AskBatchSplitReq ask batch split request
type AskBatchSplitReq struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Count                uint32   `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AskBatchSplitReq) Reset()         { *m = AskBatchSplitReq{} }
func (m *AskBatchSplitReq) String() string { return proto.CompactTextString(m) }
func (*AskBatchSplitReq) ProtoMessage()    {}
func (*AskBatchSplitReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{12}
}
func (m *AskBatchSplitReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AskBatchSplitReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AskBatchSplitReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AskBatchSplitReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AskBatchSplitReq.Merge(m, src)
}
func (m *AskBatchSplitReq) XXX_Size() int {
	return m.Size()
}
func (m *AskBatchSplitReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AskBatchSplitReq.DiscardUnknown(m)
}

var xxx_messageInfo_AskBatchSplitReq proto.InternalMessageInfo

func (m *AskBatchSplitReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *AskBatchSplitReq) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

// AskBatchSplitRsp ask batch split response
type AskBatchSplitRsp struct {
	SplitIDs             []SplitID `protobuf:"bytes,1,rep,name=splitIDs,proto3" json:"splitIDs"`
	XXX_NoUnkeyedLiteral struct{}  `json:"-"`
	XXX_unrecognized     []byte    `json:"-"`
	XXX_sizecache        int32     `json:"-"`
}

func (m *AskBatchSplitRsp) Reset()         { *m = AskBatchSplitRsp{} }
func (m *AskBatchSplitRsp) String() string { return proto.CompactTextString(m) }
func (*AskBatchSplitRsp) ProtoMessage()    {}
func (*AskBatchSplitRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{13}
}
func (m *AskBatchSplitRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AskBatchSplitRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AskBatchSplitRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AskBatchSplitRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AskBatchSplitRsp.Merge(m, src)
}
func (m *AskBatchSplitRsp) XXX_Size() int {
	return m.Size()
}
func (m *AskBatchSplitRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_AskBatchSplitRsp.DiscardUnknown(m)
}

var xxx_messageInfo_AskBatchSplitRsp proto.InternalMessageInfo

func (m *AskBatchSplitRsp) GetSplitIDs() []SplitID {
	if m != nil {
		return m.SplitIDs
	}
	return nil
}

// CreateDestroyingReq create destroying status request
type CreateDestroyingReq struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Index                uint64   `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	Replicas             []uint64 `protobuf:"varint,3,rep,packed,name=replicas,proto3" json:"replicas,omitempty"`
	RemoveData           bool     `protobuf:"varint,4,opt,name=removeData,proto3" json:"removeData,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateDestroyingReq) Reset()         { *m = CreateDestroyingReq{} }
func (m *CreateDestroyingReq) String() string { return proto.CompactTextString(m) }
func (*CreateDestroyingReq) ProtoMessage()    {}
func (*CreateDestroyingReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{14}
}
func (m *CreateDestroyingReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateDestroyingReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateDestroyingReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateDestroyingReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateDestroyingReq.Merge(m, src)
}
func (m *CreateDestroyingReq) XXX_Size() int {
	return m.Size()
}
func (m *CreateDestroyingReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateDestroyingReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreateDestroyingReq proto.InternalMessageInfo

func (m *CreateDestroyingReq) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *CreateDestroyingReq) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *CreateDestroyingReq) GetReplicas() []uint64 {
	if m != nil {
		return m.Replicas
	}
	return nil
}

func (m *CreateDestroyingReq) GetRemoveData() bool {
	if m != nil {
		return m.RemoveData
	}
	return false
}

// CreateDestroyingRsp create destroying status response
type CreateDestroyingRsp struct {
	State                metapb.ShardState `protobuf:"varint,1,opt,name=state,proto3,enum=metapb.ShardState" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *CreateDestroyingRsp) Reset()         { *m = CreateDestroyingRsp{} }
func (m *CreateDestroyingRsp) String() string { return proto.CompactTextString(m) }
func (*CreateDestroyingRsp) ProtoMessage()    {}
func (*CreateDestroyingRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{15}
}
func (m *CreateDestroyingRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateDestroyingRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateDestroyingRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateDestroyingRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateDestroyingRsp.Merge(m, src)
}
func (m *CreateDestroyingRsp) XXX_Size() int {
	return m.Size()
}
func (m *CreateDestroyingRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateDestroyingRsp.DiscardUnknown(m)
}

var xxx_messageInfo_CreateDestroyingRsp proto.InternalMessageInfo

func (m *CreateDestroyingRsp) GetState() metapb.ShardState {
	if m != nil {
		return m.State
	}
	return metapb.ShardState_Running
}

// GetDestroyingReq get destroying status request
type GetDestroyingReq struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetDestroyingReq) Reset()         { *m = GetDestroyingReq{} }
func (m *GetDestroyingReq) String() string { return proto.CompactTextString(m) }
func (*GetDestroyingReq) ProtoMessage()    {}
func (*GetDestroyingReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{16}
}
func (m *GetDestroyingReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetDestroyingReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetDestroyingReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetDestroyingReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDestroyingReq.Merge(m, src)
}
func (m *GetDestroyingReq) XXX_Size() int {
	return m.Size()
}
func (m *GetDestroyingReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDestroyingReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetDestroyingReq proto.InternalMessageInfo

func (m *GetDestroyingReq) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

// GetDestroyingRsp get destroying status response
type GetDestroyingRsp struct {
	Status               *metapb.DestroyingStatus `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *GetDestroyingRsp) Reset()         { *m = GetDestroyingRsp{} }
func (m *GetDestroyingRsp) String() string { return proto.CompactTextString(m) }
func (*GetDestroyingRsp) ProtoMessage()    {}
func (*GetDestroyingRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{17}
}
func (m *GetDestroyingRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetDestroyingRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetDestroyingRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetDestroyingRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetDestroyingRsp.Merge(m, src)
}
func (m *GetDestroyingRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetDestroyingRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetDestroyingRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetDestroyingRsp proto.InternalMessageInfo

func (m *GetDestroyingRsp) GetStatus() *metapb.DestroyingStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

// ReportDestroyedReq report destroying request
type ReportDestroyedReq struct {
	ID                   uint64   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	ReplicaID            uint64   `protobuf:"varint,2,opt,name=replicaID,proto3" json:"replicaID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReportDestroyedReq) Reset()         { *m = ReportDestroyedReq{} }
func (m *ReportDestroyedReq) String() string { return proto.CompactTextString(m) }
func (*ReportDestroyedReq) ProtoMessage()    {}
func (*ReportDestroyedReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{18}
}
func (m *ReportDestroyedReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportDestroyedReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportDestroyedReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportDestroyedReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportDestroyedReq.Merge(m, src)
}
func (m *ReportDestroyedReq) XXX_Size() int {
	return m.Size()
}
func (m *ReportDestroyedReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportDestroyedReq.DiscardUnknown(m)
}

var xxx_messageInfo_ReportDestroyedReq proto.InternalMessageInfo

func (m *ReportDestroyedReq) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ReportDestroyedReq) GetReplicaID() uint64 {
	if m != nil {
		return m.ReplicaID
	}
	return 0
}

// ReportDestroyedRsp report destroying rsp
type ReportDestroyedRsp struct {
	State                metapb.ShardState `protobuf:"varint,1,opt,name=state,proto3,enum=metapb.ShardState" json:"state,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *ReportDestroyedRsp) Reset()         { *m = ReportDestroyedRsp{} }
func (m *ReportDestroyedRsp) String() string { return proto.CompactTextString(m) }
func (*ReportDestroyedRsp) ProtoMessage()    {}
func (*ReportDestroyedRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{19}
}
func (m *ReportDestroyedRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReportDestroyedRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReportDestroyedRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReportDestroyedRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReportDestroyedRsp.Merge(m, src)
}
func (m *ReportDestroyedRsp) XXX_Size() int {
	return m.Size()
}
func (m *ReportDestroyedRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ReportDestroyedRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ReportDestroyedRsp proto.InternalMessageInfo

func (m *ReportDestroyedRsp) GetState() metapb.ShardState {
	if m != nil {
		return m.State
	}
	return metapb.ShardState_Running
}

// SplitID split id
type SplitID struct {
	NewID                uint64   `protobuf:"varint,1,opt,name=newID,proto3" json:"newID,omitempty"`
	NewReplicaIDs        []uint64 `protobuf:"varint,2,rep,packed,name=newReplicaIDs,proto3" json:"newReplicaIDs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SplitID) Reset()         { *m = SplitID{} }
func (m *SplitID) String() string { return proto.CompactTextString(m) }
func (*SplitID) ProtoMessage()    {}
func (*SplitID) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{20}
}
func (m *SplitID) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitID) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitID.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitID) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitID.Merge(m, src)
}
func (m *SplitID) XXX_Size() int {
	return m.Size()
}
func (m *SplitID) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitID.DiscardUnknown(m)
}

var xxx_messageInfo_SplitID proto.InternalMessageInfo

func (m *SplitID) GetNewID() uint64 {
	if m != nil {
		return m.NewID
	}
	return 0
}

func (m *SplitID) GetNewReplicaIDs() []uint64 {
	if m != nil {
		return m.NewReplicaIDs
	}
	return nil
}

// CreateWatcherReq create watcher req
type CreateWatcherReq struct {
	Flag                 uint32   `protobuf:"varint,1,opt,name=flag,proto3" json:"flag,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateWatcherReq) Reset()         { *m = CreateWatcherReq{} }
func (m *CreateWatcherReq) String() string { return proto.CompactTextString(m) }
func (*CreateWatcherReq) ProtoMessage()    {}
func (*CreateWatcherReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{21}
}
func (m *CreateWatcherReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateWatcherReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateWatcherReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateWatcherReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateWatcherReq.Merge(m, src)
}
func (m *CreateWatcherReq) XXX_Size() int {
	return m.Size()
}
func (m *CreateWatcherReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateWatcherReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreateWatcherReq proto.InternalMessageInfo

func (m *CreateWatcherReq) GetFlag() uint32 {
	if m != nil {
		return m.Flag
	}
	return 0
}

// CreateShardsReq create shards req
type CreateShardsReq struct {
	Shards               [][]byte `protobuf:"bytes,1,rep,name=shards,proto3" json:"shards,omitempty"`
	LeastReplicas        []uint64 `protobuf:"varint,2,rep,packed,name=leastReplicas,proto3" json:"leastReplicas,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateShardsReq) Reset()         { *m = CreateShardsReq{} }
func (m *CreateShardsReq) String() string { return proto.CompactTextString(m) }
func (*CreateShardsReq) ProtoMessage()    {}
func (*CreateShardsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{22}
}
func (m *CreateShardsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateShardsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateShardsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateShardsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateShardsReq.Merge(m, src)
}
func (m *CreateShardsReq) XXX_Size() int {
	return m.Size()
}
func (m *CreateShardsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateShardsReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreateShardsReq proto.InternalMessageInfo

func (m *CreateShardsReq) GetShards() [][]byte {
	if m != nil {
		return m.Shards
	}
	return nil
}

func (m *CreateShardsReq) GetLeastReplicas() []uint64 {
	if m != nil {
		return m.LeastReplicas
	}
	return nil
}

// CreateShardsRsp create shards rsp
type CreateShardsRsp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateShardsRsp) Reset()         { *m = CreateShardsRsp{} }
func (m *CreateShardsRsp) String() string { return proto.CompactTextString(m) }
func (*CreateShardsRsp) ProtoMessage()    {}
func (*CreateShardsRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{23}
}
func (m *CreateShardsRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateShardsRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateShardsRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateShardsRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateShardsRsp.Merge(m, src)
}
func (m *CreateShardsRsp) XXX_Size() int {
	return m.Size()
}
func (m *CreateShardsRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateShardsRsp.DiscardUnknown(m)
}

var xxx_messageInfo_CreateShardsRsp proto.InternalMessageInfo

// RemoveShardsReq remove shards req
type RemoveShardsReq struct {
	IDs                  []uint64 `protobuf:"varint,1,rep,packed,name=ids,proto3" json:"ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoveShardsReq) Reset()         { *m = RemoveShardsReq{} }
func (m *RemoveShardsReq) String() string { return proto.CompactTextString(m) }
func (*RemoveShardsReq) ProtoMessage()    {}
func (*RemoveShardsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{24}
}
func (m *RemoveShardsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveShardsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveShardsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveShardsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveShardsReq.Merge(m, src)
}
func (m *RemoveShardsReq) XXX_Size() int {
	return m.Size()
}
func (m *RemoveShardsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveShardsReq.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveShardsReq proto.InternalMessageInfo

func (m *RemoveShardsReq) GetIDs() []uint64 {
	if m != nil {
		return m.IDs
	}
	return nil
}

// RemoveShardsRsp remove shards rsp
type RemoveShardsRsp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoveShardsRsp) Reset()         { *m = RemoveShardsRsp{} }
func (m *RemoveShardsRsp) String() string { return proto.CompactTextString(m) }
func (*RemoveShardsRsp) ProtoMessage()    {}
func (*RemoveShardsRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{25}
}
func (m *RemoveShardsRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveShardsRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveShardsRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveShardsRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveShardsRsp.Merge(m, src)
}
func (m *RemoveShardsRsp) XXX_Size() int {
	return m.Size()
}
func (m *RemoveShardsRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveShardsRsp.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveShardsRsp proto.InternalMessageInfo

// CheckShardStateReq check shard state req
type CheckShardStateReq struct {
	IDs                  []byte   `protobuf:"bytes,1,opt,name=ids,proto3" json:"ids,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckShardStateReq) Reset()         { *m = CheckShardStateReq{} }
func (m *CheckShardStateReq) String() string { return proto.CompactTextString(m) }
func (*CheckShardStateReq) ProtoMessage()    {}
func (*CheckShardStateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{26}
}
func (m *CheckShardStateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckShardStateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckShardStateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckShardStateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckShardStateReq.Merge(m, src)
}
func (m *CheckShardStateReq) XXX_Size() int {
	return m.Size()
}
func (m *CheckShardStateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckShardStateReq.DiscardUnknown(m)
}

var xxx_messageInfo_CheckShardStateReq proto.InternalMessageInfo

func (m *CheckShardStateReq) GetIDs() []byte {
	if m != nil {
		return m.IDs
	}
	return nil
}

// CheckShardStateReq check shard state rsp
type CheckShardStateRsp struct {
	Destroyed            []byte   `protobuf:"bytes,1,opt,name=destroyed,proto3" json:"destroyed,omitempty"`
	Destroying           []byte   `protobuf:"bytes,2,opt,name=destroying,proto3" json:"destroying,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CheckShardStateRsp) Reset()         { *m = CheckShardStateRsp{} }
func (m *CheckShardStateRsp) String() string { return proto.CompactTextString(m) }
func (*CheckShardStateRsp) ProtoMessage()    {}
func (*CheckShardStateRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{27}
}
func (m *CheckShardStateRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckShardStateRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckShardStateRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckShardStateRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckShardStateRsp.Merge(m, src)
}
func (m *CheckShardStateRsp) XXX_Size() int {
	return m.Size()
}
func (m *CheckShardStateRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckShardStateRsp.DiscardUnknown(m)
}

var xxx_messageInfo_CheckShardStateRsp proto.InternalMessageInfo

func (m *CheckShardStateRsp) GetDestroyed() []byte {
	if m != nil {
		return m.Destroyed
	}
	return nil
}

func (m *CheckShardStateRsp) GetDestroying() []byte {
	if m != nil {
		return m.Destroying
	}
	return nil
}

// PutPlacementRuleReq put placement rule req
type PutPlacementRuleReq struct {
	Rule                 PlacementRule `protobuf:"bytes,1,opt,name=rule,proto3" json:"rule"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *PutPlacementRuleReq) Reset()         { *m = PutPlacementRuleReq{} }
func (m *PutPlacementRuleReq) String() string { return proto.CompactTextString(m) }
func (*PutPlacementRuleReq) ProtoMessage()    {}
func (*PutPlacementRuleReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{28}
}
func (m *PutPlacementRuleReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutPlacementRuleReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutPlacementRuleReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutPlacementRuleReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutPlacementRuleReq.Merge(m, src)
}
func (m *PutPlacementRuleReq) XXX_Size() int {
	return m.Size()
}
func (m *PutPlacementRuleReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PutPlacementRuleReq.DiscardUnknown(m)
}

var xxx_messageInfo_PutPlacementRuleReq proto.InternalMessageInfo

func (m *PutPlacementRuleReq) GetRule() PlacementRule {
	if m != nil {
		return m.Rule
	}
	return PlacementRule{}
}

// PutPlacementRuleRsp put placement rule rsp
type PutPlacementRuleRsp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PutPlacementRuleRsp) Reset()         { *m = PutPlacementRuleRsp{} }
func (m *PutPlacementRuleRsp) String() string { return proto.CompactTextString(m) }
func (*PutPlacementRuleRsp) ProtoMessage()    {}
func (*PutPlacementRuleRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{29}
}
func (m *PutPlacementRuleRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutPlacementRuleRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutPlacementRuleRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutPlacementRuleRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutPlacementRuleRsp.Merge(m, src)
}
func (m *PutPlacementRuleRsp) XXX_Size() int {
	return m.Size()
}
func (m *PutPlacementRuleRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_PutPlacementRuleRsp.DiscardUnknown(m)
}

var xxx_messageInfo_PutPlacementRuleRsp proto.InternalMessageInfo

// GetAppliedRulesReq get applied rules req
type GetAppliedRulesReq struct {
	ShardID              uint64   `protobuf:"varint,1,opt,name=shardID,proto3" json:"shardID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetAppliedRulesReq) Reset()         { *m = GetAppliedRulesReq{} }
func (m *GetAppliedRulesReq) String() string { return proto.CompactTextString(m) }
func (*GetAppliedRulesReq) ProtoMessage()    {}
func (*GetAppliedRulesReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{30}
}
func (m *GetAppliedRulesReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAppliedRulesReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAppliedRulesReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAppliedRulesReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAppliedRulesReq.Merge(m, src)
}
func (m *GetAppliedRulesReq) XXX_Size() int {
	return m.Size()
}
func (m *GetAppliedRulesReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAppliedRulesReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetAppliedRulesReq proto.InternalMessageInfo

func (m *GetAppliedRulesReq) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

// GetAppliedRulesRsp get applied rules rsp
type GetAppliedRulesRsp struct {
	Rules                []PlacementRule `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *GetAppliedRulesRsp) Reset()         { *m = GetAppliedRulesRsp{} }
func (m *GetAppliedRulesRsp) String() string { return proto.CompactTextString(m) }
func (*GetAppliedRulesRsp) ProtoMessage()    {}
func (*GetAppliedRulesRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{31}
}
func (m *GetAppliedRulesRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetAppliedRulesRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetAppliedRulesRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetAppliedRulesRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetAppliedRulesRsp.Merge(m, src)
}
func (m *GetAppliedRulesRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetAppliedRulesRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetAppliedRulesRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetAppliedRulesRsp proto.InternalMessageInfo

func (m *GetAppliedRulesRsp) GetRules() []PlacementRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// CreateJobReq create job req
type CreateJobReq struct {
	Job                  metapb.Job `protobuf:"bytes,1,opt,name=job,proto3" json:"job"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *CreateJobReq) Reset()         { *m = CreateJobReq{} }
func (m *CreateJobReq) String() string { return proto.CompactTextString(m) }
func (*CreateJobReq) ProtoMessage()    {}
func (*CreateJobReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{32}
}
func (m *CreateJobReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateJobReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateJobReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateJobReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateJobReq.Merge(m, src)
}
func (m *CreateJobReq) XXX_Size() int {
	return m.Size()
}
func (m *CreateJobReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateJobReq.DiscardUnknown(m)
}

var xxx_messageInfo_CreateJobReq proto.InternalMessageInfo

func (m *CreateJobReq) GetJob() metapb.Job {
	if m != nil {
		return m.Job
	}
	return metapb.Job{}
}

// CreateJobRsp create job rsp
type CreateJobRsp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateJobRsp) Reset()         { *m = CreateJobRsp{} }
func (m *CreateJobRsp) String() string { return proto.CompactTextString(m) }
func (*CreateJobRsp) ProtoMessage()    {}
func (*CreateJobRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{33}
}
func (m *CreateJobRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateJobRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateJobRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateJobRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateJobRsp.Merge(m, src)
}
func (m *CreateJobRsp) XXX_Size() int {
	return m.Size()
}
func (m *CreateJobRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateJobRsp.DiscardUnknown(m)
}

var xxx_messageInfo_CreateJobRsp proto.InternalMessageInfo

// RemoveJobReq Remove job req
type RemoveJobReq struct {
	Job                  metapb.Job `protobuf:"bytes,1,opt,name=job,proto3" json:"job"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RemoveJobReq) Reset()         { *m = RemoveJobReq{} }
func (m *RemoveJobReq) String() string { return proto.CompactTextString(m) }
func (*RemoveJobReq) ProtoMessage()    {}
func (*RemoveJobReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{34}
}
func (m *RemoveJobReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveJobReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveJobReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveJobReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveJobReq.Merge(m, src)
}
func (m *RemoveJobReq) XXX_Size() int {
	return m.Size()
}
func (m *RemoveJobReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveJobReq.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveJobReq proto.InternalMessageInfo

func (m *RemoveJobReq) GetJob() metapb.Job {
	if m != nil {
		return m.Job
	}
	return metapb.Job{}
}

// RemoveJobRsp Remove job rsp
type RemoveJobRsp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RemoveJobRsp) Reset()         { *m = RemoveJobRsp{} }
func (m *RemoveJobRsp) String() string { return proto.CompactTextString(m) }
func (*RemoveJobRsp) ProtoMessage()    {}
func (*RemoveJobRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{35}
}
func (m *RemoveJobRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RemoveJobRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RemoveJobRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RemoveJobRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RemoveJobRsp.Merge(m, src)
}
func (m *RemoveJobRsp) XXX_Size() int {
	return m.Size()
}
func (m *RemoveJobRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_RemoveJobRsp.DiscardUnknown(m)
}

var xxx_messageInfo_RemoveJobRsp proto.InternalMessageInfo

// ExecuteJobReq execute on job request
type ExecuteJobReq struct {
	Job                  metapb.Job `protobuf:"bytes,1,opt,name=job,proto3" json:"job"`
	Data                 []byte     `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ExecuteJobReq) Reset()         { *m = ExecuteJobReq{} }
func (m *ExecuteJobReq) String() string { return proto.CompactTextString(m) }
func (*ExecuteJobReq) ProtoMessage()    {}
func (*ExecuteJobReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{36}
}
func (m *ExecuteJobReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteJobReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteJobReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteJobReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteJobReq.Merge(m, src)
}
func (m *ExecuteJobReq) XXX_Size() int {
	return m.Size()
}
func (m *ExecuteJobReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteJobReq.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteJobReq proto.InternalMessageInfo

func (m *ExecuteJobReq) GetJob() metapb.Job {
	if m != nil {
		return m.Job
	}
	return metapb.Job{}
}

func (m *ExecuteJobReq) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// ExecuteJobRsp execute on job response
type ExecuteJobRsp struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExecuteJobRsp) Reset()         { *m = ExecuteJobRsp{} }
func (m *ExecuteJobRsp) String() string { return proto.CompactTextString(m) }
func (*ExecuteJobRsp) ProtoMessage()    {}
func (*ExecuteJobRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{37}
}
func (m *ExecuteJobRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecuteJobRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecuteJobRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecuteJobRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecuteJobRsp.Merge(m, src)
}
func (m *ExecuteJobRsp) XXX_Size() int {
	return m.Size()
}
func (m *ExecuteJobRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecuteJobRsp.DiscardUnknown(m)
}

var xxx_messageInfo_ExecuteJobRsp proto.InternalMessageInfo

func (m *ExecuteJobRsp) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type AddScheduleGroupRuleReq struct {
	Rule                 metapb.ScheduleGroupRule `protobuf:"bytes,1,opt,name=rule,proto3" json:"rule"`
	XXX_NoUnkeyedLiteral struct{}                 `json:"-"`
	XXX_unrecognized     []byte                   `json:"-"`
	XXX_sizecache        int32                    `json:"-"`
}

func (m *AddScheduleGroupRuleReq) Reset()         { *m = AddScheduleGroupRuleReq{} }
func (m *AddScheduleGroupRuleReq) String() string { return proto.CompactTextString(m) }
func (*AddScheduleGroupRuleReq) ProtoMessage()    {}
func (*AddScheduleGroupRuleReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{38}
}
func (m *AddScheduleGroupRuleReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddScheduleGroupRuleReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddScheduleGroupRuleReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddScheduleGroupRuleReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddScheduleGroupRuleReq.Merge(m, src)
}
func (m *AddScheduleGroupRuleReq) XXX_Size() int {
	return m.Size()
}
func (m *AddScheduleGroupRuleReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AddScheduleGroupRuleReq.DiscardUnknown(m)
}

var xxx_messageInfo_AddScheduleGroupRuleReq proto.InternalMessageInfo

func (m *AddScheduleGroupRuleReq) GetRule() metapb.ScheduleGroupRule {
	if m != nil {
		return m.Rule
	}
	return metapb.ScheduleGroupRule{}
}

type AddScheduleGroupRuleRsp struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AddScheduleGroupRuleRsp) Reset()         { *m = AddScheduleGroupRuleRsp{} }
func (m *AddScheduleGroupRuleRsp) String() string { return proto.CompactTextString(m) }
func (*AddScheduleGroupRuleRsp) ProtoMessage()    {}
func (*AddScheduleGroupRuleRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{39}
}
func (m *AddScheduleGroupRuleRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AddScheduleGroupRuleRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AddScheduleGroupRuleRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AddScheduleGroupRuleRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AddScheduleGroupRuleRsp.Merge(m, src)
}
func (m *AddScheduleGroupRuleRsp) XXX_Size() int {
	return m.Size()
}
func (m *AddScheduleGroupRuleRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_AddScheduleGroupRuleRsp.DiscardUnknown(m)
}

var xxx_messageInfo_AddScheduleGroupRuleRsp proto.InternalMessageInfo

type GetScheduleGroupRuleReq struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GetScheduleGroupRuleReq) Reset()         { *m = GetScheduleGroupRuleReq{} }
func (m *GetScheduleGroupRuleReq) String() string { return proto.CompactTextString(m) }
func (*GetScheduleGroupRuleReq) ProtoMessage()    {}
func (*GetScheduleGroupRuleReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{40}
}
func (m *GetScheduleGroupRuleReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetScheduleGroupRuleReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetScheduleGroupRuleReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetScheduleGroupRuleReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetScheduleGroupRuleReq.Merge(m, src)
}
func (m *GetScheduleGroupRuleReq) XXX_Size() int {
	return m.Size()
}
func (m *GetScheduleGroupRuleReq) XXX_DiscardUnknown() {
	xxx_messageInfo_GetScheduleGroupRuleReq.DiscardUnknown(m)
}

var xxx_messageInfo_GetScheduleGroupRuleReq proto.InternalMessageInfo

type GetScheduleGroupRuleRsp struct {
	Rules                []metapb.ScheduleGroupRule `protobuf:"bytes,1,rep,name=rules,proto3" json:"rules"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *GetScheduleGroupRuleRsp) Reset()         { *m = GetScheduleGroupRuleRsp{} }
func (m *GetScheduleGroupRuleRsp) String() string { return proto.CompactTextString(m) }
func (*GetScheduleGroupRuleRsp) ProtoMessage()    {}
func (*GetScheduleGroupRuleRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{41}
}
func (m *GetScheduleGroupRuleRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetScheduleGroupRuleRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetScheduleGroupRuleRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetScheduleGroupRuleRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetScheduleGroupRuleRsp.Merge(m, src)
}
func (m *GetScheduleGroupRuleRsp) XXX_Size() int {
	return m.Size()
}
func (m *GetScheduleGroupRuleRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_GetScheduleGroupRuleRsp.DiscardUnknown(m)
}

var xxx_messageInfo_GetScheduleGroupRuleRsp proto.InternalMessageInfo

func (m *GetScheduleGroupRuleRsp) GetRules() []metapb.ScheduleGroupRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

// EventNotify event notify
type EventNotify struct {
	Seq                  uint64             `protobuf:"varint,1,opt,name=seq,proto3" json:"seq,omitempty"`
	Type                 uint32             `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	InitEvent            *InitEventData     `protobuf:"bytes,3,opt,name=initEvent,proto3" json:"initEvent,omitempty"`
	ShardEvent           *ShardEventData    `protobuf:"bytes,4,opt,name=shardEvent,proto3" json:"shardEvent,omitempty"`
	StoreEvent           *StoreEventData    `protobuf:"bytes,5,opt,name=storeEvent,proto3" json:"storeEvent,omitempty"`
	ShardStatsEvent      *metapb.ShardStats `protobuf:"bytes,6,opt,name=shardStatsEvent,proto3" json:"shardStatsEvent,omitempty"`
	StoreStatsEvent      *metapb.StoreStats `protobuf:"bytes,7,opt,name=storeStatsEvent,proto3" json:"storeStatsEvent,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *EventNotify) Reset()         { *m = EventNotify{} }
func (m *EventNotify) String() string { return proto.CompactTextString(m) }
func (*EventNotify) ProtoMessage()    {}
func (*EventNotify) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{42}
}
func (m *EventNotify) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventNotify) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventNotify.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventNotify) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventNotify.Merge(m, src)
}
func (m *EventNotify) XXX_Size() int {
	return m.Size()
}
func (m *EventNotify) XXX_DiscardUnknown() {
	xxx_messageInfo_EventNotify.DiscardUnknown(m)
}

var xxx_messageInfo_EventNotify proto.InternalMessageInfo

func (m *EventNotify) GetSeq() uint64 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *EventNotify) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *EventNotify) GetInitEvent() *InitEventData {
	if m != nil {
		return m.InitEvent
	}
	return nil
}

func (m *EventNotify) GetShardEvent() *ShardEventData {
	if m != nil {
		return m.ShardEvent
	}
	return nil
}

func (m *EventNotify) GetStoreEvent() *StoreEventData {
	if m != nil {
		return m.StoreEvent
	}
	return nil
}

func (m *EventNotify) GetShardStatsEvent() *metapb.ShardStats {
	if m != nil {
		return m.ShardStatsEvent
	}
	return nil
}

func (m *EventNotify) GetStoreStatsEvent() *metapb.StoreStats {
	if m != nil {
		return m.StoreStatsEvent
	}
	return nil
}

// InitEventData init event data
type InitEventData struct {
	Shards               [][]byte `protobuf:"bytes,1,rep,name=shards,proto3" json:"shards,omitempty"`
	Leaders              []uint64 `protobuf:"varint,2,rep,packed,name=leaders,proto3" json:"leaders,omitempty"`
	Stores               [][]byte `protobuf:"bytes,3,rep,name=stores,proto3" json:"stores,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InitEventData) Reset()         { *m = InitEventData{} }
func (m *InitEventData) String() string { return proto.CompactTextString(m) }
func (*InitEventData) ProtoMessage()    {}
func (*InitEventData) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{43}
}
func (m *InitEventData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InitEventData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InitEventData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InitEventData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitEventData.Merge(m, src)
}
func (m *InitEventData) XXX_Size() int {
	return m.Size()
}
func (m *InitEventData) XXX_DiscardUnknown() {
	xxx_messageInfo_InitEventData.DiscardUnknown(m)
}

var xxx_messageInfo_InitEventData proto.InternalMessageInfo

func (m *InitEventData) GetShards() [][]byte {
	if m != nil {
		return m.Shards
	}
	return nil
}

func (m *InitEventData) GetLeaders() []uint64 {
	if m != nil {
		return m.Leaders
	}
	return nil
}

func (m *InitEventData) GetStores() [][]byte {
	if m != nil {
		return m.Stores
	}
	return nil
}

// ShardEventData shard created or updated
type ShardEventData struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Leader               uint64   `protobuf:"varint,2,opt,name=leader,proto3" json:"leader,omitempty"`
	Removed              bool     `protobuf:"varint,3,opt,name=removed,proto3" json:"removed,omitempty"`
	Create               bool     `protobuf:"varint,4,opt,name=create,proto3" json:"create,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ShardEventData) Reset()         { *m = ShardEventData{} }
func (m *ShardEventData) String() string { return proto.CompactTextString(m) }
func (*ShardEventData) ProtoMessage()    {}
func (*ShardEventData) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{44}
}
func (m *ShardEventData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ShardEventData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ShardEventData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ShardEventData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ShardEventData.Merge(m, src)
}
func (m *ShardEventData) XXX_Size() int {
	return m.Size()
}
func (m *ShardEventData) XXX_DiscardUnknown() {
	xxx_messageInfo_ShardEventData.DiscardUnknown(m)
}

var xxx_messageInfo_ShardEventData proto.InternalMessageInfo

func (m *ShardEventData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ShardEventData) GetLeader() uint64 {
	if m != nil {
		return m.Leader
	}
	return 0
}

func (m *ShardEventData) GetRemoved() bool {
	if m != nil {
		return m.Removed
	}
	return false
}

func (m *ShardEventData) GetCreate() bool {
	if m != nil {
		return m.Create
	}
	return false
}

// StoreEventData store created or updated
type StoreEventData struct {
	Data                 []byte   `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StoreEventData) Reset()         { *m = StoreEventData{} }
func (m *StoreEventData) String() string { return proto.CompactTextString(m) }
func (*StoreEventData) ProtoMessage()    {}
func (*StoreEventData) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{45}
}
func (m *StoreEventData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StoreEventData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StoreEventData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StoreEventData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StoreEventData.Merge(m, src)
}
func (m *StoreEventData) XXX_Size() int {
	return m.Size()
}
func (m *StoreEventData) XXX_DiscardUnknown() {
	xxx_messageInfo_StoreEventData.DiscardUnknown(m)
}

var xxx_messageInfo_StoreEventData proto.InternalMessageInfo

func (m *StoreEventData) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// ChangePeer change peer
type ConfigChange struct {
	Replica              metapb.Replica          `protobuf:"bytes,1,opt,name=replica,proto3" json:"replica"`
	ChangeType           metapb.ConfigChangeType `protobuf:"varint,2,opt,name=changeType,proto3,enum=metapb.ConfigChangeType" json:"changeType,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *ConfigChange) Reset()         { *m = ConfigChange{} }
func (m *ConfigChange) String() string { return proto.CompactTextString(m) }
func (*ConfigChange) ProtoMessage()    {}
func (*ConfigChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{46}
}
func (m *ConfigChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigChange.Merge(m, src)
}
func (m *ConfigChange) XXX_Size() int {
	return m.Size()
}
func (m *ConfigChange) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigChange.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigChange proto.InternalMessageInfo

func (m *ConfigChange) GetReplica() metapb.Replica {
	if m != nil {
		return m.Replica
	}
	return metapb.Replica{}
}

func (m *ConfigChange) GetChangeType() metapb.ConfigChangeType {
	if m != nil {
		return m.ChangeType
	}
	return metapb.ConfigChangeType_AddNode
}

// TransferLeader transfer leader
type TransferLeader struct {
	Replica              metapb.Replica `protobuf:"bytes,1,opt,name=replica,proto3" json:"replica"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TransferLeader) Reset()         { *m = TransferLeader{} }
func (m *TransferLeader) String() string { return proto.CompactTextString(m) }
func (*TransferLeader) ProtoMessage()    {}
func (*TransferLeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{47}
}
func (m *TransferLeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferLeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferLeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferLeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferLeader.Merge(m, src)
}
func (m *TransferLeader) XXX_Size() int {
	return m.Size()
}
func (m *TransferLeader) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferLeader.DiscardUnknown(m)
}

var xxx_messageInfo_TransferLeader proto.InternalMessageInfo

func (m *TransferLeader) GetReplica() metapb.Replica {
	if m != nil {
		return m.Replica
	}
	return metapb.Replica{}
}

// ConfigChangeV2 change peer v2
type ConfigChangeV2 struct {
	// If changes is empty, it means that to exit joint state.
	Changes              []ConfigChange `protobuf:"bytes,1,rep,name=changes,proto3" json:"changes"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *ConfigChangeV2) Reset()         { *m = ConfigChangeV2{} }
func (m *ConfigChangeV2) String() string { return proto.CompactTextString(m) }
func (*ConfigChangeV2) ProtoMessage()    {}
func (*ConfigChangeV2) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{48}
}
func (m *ConfigChangeV2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigChangeV2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigChangeV2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigChangeV2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigChangeV2.Merge(m, src)
}
func (m *ConfigChangeV2) XXX_Size() int {
	return m.Size()
}
func (m *ConfigChangeV2) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigChangeV2.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigChangeV2 proto.InternalMessageInfo

func (m *ConfigChangeV2) GetChanges() []ConfigChange {
	if m != nil {
		return m.Changes
	}
	return nil
}

// Merge merge
type Merge struct {
	// target shard
	Target               []byte   `protobuf:"bytes,1,opt,name=target,proto3" json:"target,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Merge) Reset()         { *m = Merge{} }
func (m *Merge) String() string { return proto.CompactTextString(m) }
func (*Merge) ProtoMessage()    {}
func (*Merge) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{49}
}
func (m *Merge) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Merge) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Merge.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Merge) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Merge.Merge(m, src)
}
func (m *Merge) XXX_Size() int {
	return m.Size()
}
func (m *Merge) XXX_DiscardUnknown() {
	xxx_messageInfo_Merge.DiscardUnknown(m)
}

var xxx_messageInfo_Merge proto.InternalMessageInfo

func (m *Merge) GetTarget() []byte {
	if m != nil {
		return m.Target
	}
	return nil
}

// SplitShard split shard
type SplitShard struct {
	Policy               metapb.CheckPolicy `protobuf:"varint,1,opt,name=policy,proto3,enum=metapb.CheckPolicy" json:"policy,omitempty"`
	Keys                 [][]byte           `protobuf:"bytes,2,rep,name=keys,proto3" json:"keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *SplitShard) Reset()         { *m = SplitShard{} }
func (m *SplitShard) String() string { return proto.CompactTextString(m) }
func (*SplitShard) ProtoMessage()    {}
func (*SplitShard) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{50}
}
func (m *SplitShard) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitShard) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitShard.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitShard) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitShard.Merge(m, src)
}
func (m *SplitShard) XXX_Size() int {
	return m.Size()
}
func (m *SplitShard) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitShard.DiscardUnknown(m)
}

var xxx_messageInfo_SplitShard proto.InternalMessageInfo

func (m *SplitShard) GetPolicy() metapb.CheckPolicy {
	if m != nil {
		return m.Policy
	}
	return metapb.CheckPolicy_SCAN
}

func (m *SplitShard) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

// LabelConstraint is used to filter store when trying to place peer of a shard.
type LabelConstraint struct {
	Key                  string            `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Op                   LabelConstraintOp `protobuf:"varint,2,opt,name=op,proto3,enum=rpcpb.LabelConstraintOp" json:"op,omitempty"`
	Values               []string          `protobuf:"bytes,3,rep,name=values,proto3" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *LabelConstraint) Reset()         { *m = LabelConstraint{} }
func (m *LabelConstraint) String() string { return proto.CompactTextString(m) }
func (*LabelConstraint) ProtoMessage()    {}
func (*LabelConstraint) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{51}
}
func (m *LabelConstraint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LabelConstraint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LabelConstraint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LabelConstraint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LabelConstraint.Merge(m, src)
}
func (m *LabelConstraint) XXX_Size() int {
	return m.Size()
}
func (m *LabelConstraint) XXX_DiscardUnknown() {
	xxx_messageInfo_LabelConstraint.DiscardUnknown(m)
}

var xxx_messageInfo_LabelConstraint proto.InternalMessageInfo

func (m *LabelConstraint) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *LabelConstraint) GetOp() LabelConstraintOp {
	if m != nil {
		return m.Op
	}
	return In
}

func (m *LabelConstraint) GetValues() []string {
	if m != nil {
		return m.Values
	}
	return nil
}

// PlacementRule place rule
type PlacementRule struct {
	// ID unique ID within a group
	ID string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	// GroupID mark the source that add the rule
	GroupID string `protobuf:"bytes,2,opt,name=groupID,proto3" json:"groupID,omitempty"`
	// Index rule apply order in a group, rule with less ID is applied first when indexes are equal
	Index uint32 `protobuf:"varint,3,opt,name=index,proto3" json:"index,omitempty"`
	// Override when it is true, all rules with less indexes are disabled
	Override bool   `protobuf:"varint,4,opt,name=override,proto3" json:"override,omitempty"`
	StartKey []byte `protobuf:"bytes,5,opt,name=startKey,proto3" json:"startKey,omitempty"`
	EndKey   []byte `protobuf:"bytes,6,opt,name=endKey,proto3" json:"endKey,omitempty"`
	// Role expected role of the peers
	Role ReplicaRoleType `protobuf:"varint,7,opt,name=role,proto3,enum=rpcpb.ReplicaRoleType" json:"role,omitempty"`
	// Count expected count of the peers
	Count uint32 `protobuf:"varint,8,opt,name=count,proto3" json:"count,omitempty"`
	// LabelConstraints used to select stores to place peers
	LabelConstraints []LabelConstraint `protobuf:"bytes,9,rep,name=labelConstraints,proto3" json:"labelConstraints"`
	// LocationLabels used to make peers isolated physically
	LocationLabels []string `protobuf:"bytes,10,rep,name=locationLabels,proto3" json:"locationLabels,omitempty"`
	// IsolationLevelused to isolate replicas explicitly and forcibly
	IsolationLevel       string   `protobuf:"bytes,11,opt,name=isolationLevel,proto3" json:"isolationLevel,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *PlacementRule) Reset()         { *m = PlacementRule{} }
func (m *PlacementRule) String() string { return proto.CompactTextString(m) }
func (*PlacementRule) ProtoMessage()    {}
func (*PlacementRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{52}
}
func (m *PlacementRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PlacementRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PlacementRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PlacementRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PlacementRule.Merge(m, src)
}
func (m *PlacementRule) XXX_Size() int {
	return m.Size()
}
func (m *PlacementRule) XXX_DiscardUnknown() {
	xxx_messageInfo_PlacementRule.DiscardUnknown(m)
}

var xxx_messageInfo_PlacementRule proto.InternalMessageInfo

func (m *PlacementRule) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *PlacementRule) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

func (m *PlacementRule) GetIndex() uint32 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *PlacementRule) GetOverride() bool {
	if m != nil {
		return m.Override
	}
	return false
}

func (m *PlacementRule) GetStartKey() []byte {
	if m != nil {
		return m.StartKey
	}
	return nil
}

func (m *PlacementRule) GetEndKey() []byte {
	if m != nil {
		return m.EndKey
	}
	return nil
}

func (m *PlacementRule) GetRole() ReplicaRoleType {
	if m != nil {
		return m.Role
	}
	return Voter
}

func (m *PlacementRule) GetCount() uint32 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *PlacementRule) GetLabelConstraints() []LabelConstraint {
	if m != nil {
		return m.LabelConstraints
	}
	return nil
}

func (m *PlacementRule) GetLocationLabels() []string {
	if m != nil {
		return m.LocationLabels
	}
	return nil
}

func (m *PlacementRule) GetIsolationLevel() string {
	if m != nil {
		return m.IsolationLevel
	}
	return ""
}

// RequestHeader raft request header, it contains the shard's metadata
type RequestBatchHeader struct {
	ID                   []byte         `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	ShardID              uint64         `protobuf:"varint,2,opt,name=shardID,proto3" json:"shardID,omitempty"`
	Replica              metapb.Replica `protobuf:"bytes,3,opt,name=replica,proto3" json:"replica"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *RequestBatchHeader) Reset()         { *m = RequestBatchHeader{} }
func (m *RequestBatchHeader) String() string { return proto.CompactTextString(m) }
func (*RequestBatchHeader) ProtoMessage()    {}
func (*RequestBatchHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{53}
}
func (m *RequestBatchHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestBatchHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestBatchHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestBatchHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestBatchHeader.Merge(m, src)
}
func (m *RequestBatchHeader) XXX_Size() int {
	return m.Size()
}
func (m *RequestBatchHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestBatchHeader.DiscardUnknown(m)
}

var xxx_messageInfo_RequestBatchHeader proto.InternalMessageInfo

func (m *RequestBatchHeader) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *RequestBatchHeader) GetShardID() uint64 {
	if m != nil {
		return m.ShardID
	}
	return 0
}

func (m *RequestBatchHeader) GetReplica() metapb.Replica {
	if m != nil {
		return m.Replica
	}
	return metapb.Replica{}
}

type ResponseBatchHeader struct {
	ID                   []byte        `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Error                errorpb.Error `protobuf:"bytes,2,opt,name=error,proto3" json:"error"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ResponseBatchHeader) Reset()         { *m = ResponseBatchHeader{} }
func (m *ResponseBatchHeader) String() string { return proto.CompactTextString(m) }
func (*ResponseBatchHeader) ProtoMessage()    {}
func (*ResponseBatchHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{54}
}
func (m *ResponseBatchHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseBatchHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseBatchHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseBatchHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseBatchHeader.Merge(m, src)
}
func (m *ResponseBatchHeader) XXX_Size() int {
	return m.Size()
}
func (m *ResponseBatchHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseBatchHeader.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseBatchHeader proto.InternalMessageInfo

func (m *ResponseBatchHeader) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *ResponseBatchHeader) GetError() errorpb.Error {
	if m != nil {
		return m.Error
	}
	return errorpb.Error{}
}

// RequestBatch we can't include both normal requests and administrator request
// at same time.
type RequestBatch struct {
	Header               RequestBatchHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Requests             []Request          `protobuf:"bytes,2,rep,name=requests,proto3" json:"requests"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *RequestBatch) Reset()         { *m = RequestBatch{} }
func (m *RequestBatch) String() string { return proto.CompactTextString(m) }
func (*RequestBatch) ProtoMessage()    {}
func (*RequestBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{55}
}
func (m *RequestBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestBatch.Merge(m, src)
}
func (m *RequestBatch) XXX_Size() int {
	return m.Size()
}
func (m *RequestBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestBatch.DiscardUnknown(m)
}

var xxx_messageInfo_RequestBatch proto.InternalMessageInfo

func (m *RequestBatch) GetHeader() RequestBatchHeader {
	if m != nil {
		return m.Header
	}
	return RequestBatchHeader{}
}

func (m *RequestBatch) GetRequests() []Request {
	if m != nil {
		return m.Requests
	}
	return nil
}

// ResponseBatch response batch
type ResponseBatch struct {
	Header               ResponseBatchHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Responses            []Response          `protobuf:"bytes,2,rep,name=responses,proto3" json:"responses"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *ResponseBatch) Reset()         { *m = ResponseBatch{} }
func (m *ResponseBatch) String() string { return proto.CompactTextString(m) }
func (*ResponseBatch) ProtoMessage()    {}
func (*ResponseBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{56}
}
func (m *ResponseBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseBatch.Merge(m, src)
}
func (m *ResponseBatch) XXX_Size() int {
	return m.Size()
}
func (m *ResponseBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseBatch.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseBatch proto.InternalMessageInfo

func (m *ResponseBatch) GetHeader() ResponseBatchHeader {
	if m != nil {
		return m.Header
	}
	return ResponseBatchHeader{}
}

func (m *ResponseBatch) GetResponses() []Response {
	if m != nil {
		return m.Responses
	}
	return nil
}

// Request request
type Request struct {
	ID               []byte            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Group            uint64            `protobuf:"varint,2,opt,name=group,proto3" json:"group,omitempty"`
	Type             CmdType           `protobuf:"varint,3,opt,name=type,proto3,enum=rpcpb.CmdType" json:"type,omitempty"`
	CustomType       uint64            `protobuf:"varint,4,opt,name=customType,proto3" json:"customType,omitempty"`
	Key              []byte            `protobuf:"bytes,5,opt,name=key,proto3" json:"key,omitempty"`
	Cmd              []byte            `protobuf:"bytes,6,opt,name=cmd,proto3" json:"cmd,omitempty"`
	PID              int64             `protobuf:"varint,7,opt,name=pid,proto3" json:"pid,omitempty"`
	ToShard          uint64            `protobuf:"varint,8,opt,name=toShard,proto3" json:"toShard,omitempty"`
	IgnoreEpochCheck bool              `protobuf:"varint,9,opt,name=ignoreEpochCheck,proto3" json:"ignoreEpochCheck,omitempty"`
	Epoch            metapb.ShardEpoch `protobuf:"bytes,10,opt,name=epoch,proto3" json:"epoch"`
	// KeysRange If the current request operates on multiple Keys, then KeysRange needs
	// to be filled in, and the client needs to split the request again if it wants to
	// re-route according to KeysRange after the data management scope of the Shard has changed,
	// or if it returns the specified error.
	KeysRange           *Range              `protobuf:"bytes,11,opt,name=keysRange,proto3" json:"keysRange,omitempty"`
	ReplicaSelectPolicy ReplicaSelectPolicy `protobuf:"varint,12,opt,name=replicaSelectPolicy,proto3,enum=rpcpb.ReplicaSelectPolicy" json:"replicaSelectPolicy,omitempty"`
	// TxnBatchRequest tranasction request if type == Txn
	TxnBatchRequest      *txnpb.TxnBatchRequest      `protobuf:"bytes,13,opt,name=txnBatchRequest,proto3" json:"txnBatchRequest,omitempty"`
	UpdateTxnRecord      UpdateTxnRecordRequest      `protobuf:"bytes,14,opt,name=updateTxnRecord,proto3" json:"updateTxnRecord"`
	DeleteTxnRecord      DeleteTxnRecordRequest      `protobuf:"bytes,15,opt,name=deleteTxnRecord,proto3" json:"deleteTxnRecord"`
	CommitTxnWriteData   CommitTxnWriteDataRequest   `protobuf:"bytes,16,opt,name=commitTxnWriteData,proto3" json:"commitTxnWriteData"`
	RollbackTxnRecord    RollbackTxnWriteDataRequest `protobuf:"bytes,17,opt,name=rollbackTxnRecord,proto3" json:"rollbackTxnRecord"`
	CleanTxnMVCCData     CleanTxnMVCCDataRequest     `protobuf:"bytes,18,opt,name=cleanTxnMVCCData,proto3" json:"cleanTxnMVCCData"`
	XXX_NoUnkeyedLiteral struct{}                    `json:"-"`
	XXX_unrecognized     []byte                      `json:"-"`
	XXX_sizecache        int32                       `json:"-"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{57}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

func (m *Request) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *Request) GetGroup() uint64 {
	if m != nil {
		return m.Group
	}
	return 0
}

func (m *Request) GetType() CmdType {
	if m != nil {
		return m.Type
	}
	return Write
}

func (m *Request) GetCustomType() uint64 {
	if m != nil {
		return m.CustomType
	}
	return 0
}

func (m *Request) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *Request) GetCmd() []byte {
	if m != nil {
		return m.Cmd
	}
	return nil
}

func (m *Request) GetPID() int64 {
	if m != nil {
		return m.PID
	}
	return 0
}

func (m *Request) GetToShard() uint64 {
	if m != nil {
		return m.ToShard
	}
	return 0
}

func (m *Request) GetIgnoreEpochCheck() bool {
	if m != nil {
		return m.IgnoreEpochCheck
	}
	return false
}

func (m *Request) GetEpoch() metapb.ShardEpoch {
	if m != nil {
		return m.Epoch
	}
	return metapb.ShardEpoch{}
}

func (m *Request) GetKeysRange() *Range {
	if m != nil {
		return m.KeysRange
	}
	return nil
}

func (m *Request) GetReplicaSelectPolicy() ReplicaSelectPolicy {
	if m != nil {
		return m.ReplicaSelectPolicy
	}
	return SelectLeader
}

func (m *Request) GetTxnBatchRequest() *txnpb.TxnBatchRequest {
	if m != nil {
		return m.TxnBatchRequest
	}
	return nil
}

func (m *Request) GetUpdateTxnRecord() UpdateTxnRecordRequest {
	if m != nil {
		return m.UpdateTxnRecord
	}
	return UpdateTxnRecordRequest{}
}

func (m *Request) GetDeleteTxnRecord() DeleteTxnRecordRequest {
	if m != nil {
		return m.DeleteTxnRecord
	}
	return DeleteTxnRecordRequest{}
}

func (m *Request) GetCommitTxnWriteData() CommitTxnWriteDataRequest {
	if m != nil {
		return m.CommitTxnWriteData
	}
	return CommitTxnWriteDataRequest{}
}

func (m *Request) GetRollbackTxnRecord() RollbackTxnWriteDataRequest {
	if m != nil {
		return m.RollbackTxnRecord
	}
	return RollbackTxnWriteDataRequest{}
}

func (m *Request) GetCleanTxnMVCCData() CleanTxnMVCCDataRequest {
	if m != nil {
		return m.CleanTxnMVCCData
	}
	return CleanTxnMVCCDataRequest{}
}

// Range key range [from, to)
type Range struct {
	// From include
	From []byte `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	// To exclude
	To                   []byte   `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Range) Reset()         { *m = Range{} }
func (m *Range) String() string { return proto.CompactTextString(m) }
func (*Range) ProtoMessage()    {}
func (*Range) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{58}
}
func (m *Range) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Range) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Range.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Range) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Range.Merge(m, src)
}
func (m *Range) XXX_Size() int {
	return m.Size()
}
func (m *Range) XXX_DiscardUnknown() {
	xxx_messageInfo_Range.DiscardUnknown(m)
}

var xxx_messageInfo_Range proto.InternalMessageInfo

func (m *Range) GetFrom() []byte {
	if m != nil {
		return m.From
	}
	return nil
}

func (m *Range) GetTo() []byte {
	if m != nil {
		return m.To
	}
	return nil
}

// Response response
type Response struct {
	ID         []byte        `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Type       CmdType       `protobuf:"varint,2,opt,name=type,proto3,enum=rpcpb.CmdType" json:"type,omitempty"`
	CustomType uint64        `protobuf:"varint,3,opt,name=customType,proto3" json:"customType,omitempty"`
	Value      []byte        `protobuf:"bytes,4,opt,name=value,proto3" json:"value,omitempty"`
	PID        int64         `protobuf:"varint,5,opt,name=pid,proto3" json:"pid,omitempty"`
	Error      errorpb.Error `protobuf:"bytes,6,opt,name=error,proto3" json:"error"`
	// TxnBatchRequest tranasction request if type == Txn
	TxnBatchResponse     *txnpb.TxnBatchResponse      `protobuf:"bytes,7,opt,name=txnBatchResponse,proto3" json:"txnBatchResponse,omitempty"`
	UpdateTxnRecord      *UpdateTxnRecordRequest      `protobuf:"bytes,8,opt,name=updateTxnRecord,proto3" json:"updateTxnRecord,omitempty"`
	DeleteTxnRecord      *DeleteTxnRecordRequest      `protobuf:"bytes,9,opt,name=deleteTxnRecord,proto3" json:"deleteTxnRecord,omitempty"`
	CommitTxnWriteData   *CommitTxnWriteDataRequest   `protobuf:"bytes,10,opt,name=commitTxnWriteData,proto3" json:"commitTxnWriteData,omitempty"`
	RollbackTxnRecord    *RollbackTxnWriteDataRequest `protobuf:"bytes,11,opt,name=rollbackTxnRecord,proto3" json:"rollbackTxnRecord,omitempty"`
	CleanTxnMVCCData     *CleanTxnMVCCDataRequest     `protobuf:"bytes,12,opt,name=cleanTxnMVCCData,proto3" json:"cleanTxnMVCCData,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{59}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetID() []byte {
	if m != nil {
		return m.ID
	}
	return nil
}

func (m *Response) GetType() CmdType {
	if m != nil {
		return m.Type
	}
	return Write
}

func (m *Response) GetCustomType() uint64 {
	if m != nil {
		return m.CustomType
	}
	return 0
}

func (m *Response) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Response) GetPID() int64 {
	if m != nil {
		return m.PID
	}
	return 0
}

func (m *Response) GetError() errorpb.Error {
	if m != nil {
		return m.Error
	}
	return errorpb.Error{}
}

func (m *Response) GetTxnBatchResponse() *txnpb.TxnBatchResponse {
	if m != nil {
		return m.TxnBatchResponse
	}
	return nil
}

func (m *Response) GetUpdateTxnRecord() *UpdateTxnRecordRequest {
	if m != nil {
		return m.UpdateTxnRecord
	}
	return nil
}

func (m *Response) GetDeleteTxnRecord() *DeleteTxnRecordRequest {
	if m != nil {
		return m.DeleteTxnRecord
	}
	return nil
}

func (m *Response) GetCommitTxnWriteData() *CommitTxnWriteDataRequest {
	if m != nil {
		return m.CommitTxnWriteData
	}
	return nil
}

func (m *Response) GetRollbackTxnRecord() *RollbackTxnWriteDataRequest {
	if m != nil {
		return m.RollbackTxnRecord
	}
	return nil
}

func (m *Response) GetCleanTxnMVCCData() *CleanTxnMVCCDataRequest {
	if m != nil {
		return m.CleanTxnMVCCData
	}
	return nil
}

type ConfigChangeRequest struct {
	// This can be only called in internal RaftStore now.
	ChangeType           metapb.ConfigChangeType `protobuf:"varint,1,opt,name=changeType,proto3,enum=metapb.ConfigChangeType" json:"changeType,omitempty"`
	Replica              metapb.Replica          `protobuf:"bytes,2,opt,name=replica,proto3" json:"replica"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *ConfigChangeRequest) Reset()         { *m = ConfigChangeRequest{} }
func (m *ConfigChangeRequest) String() string { return proto.CompactTextString(m) }
func (*ConfigChangeRequest) ProtoMessage()    {}
func (*ConfigChangeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{60}
}
func (m *ConfigChangeRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigChangeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigChangeRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigChangeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigChangeRequest.Merge(m, src)
}
func (m *ConfigChangeRequest) XXX_Size() int {
	return m.Size()
}
func (m *ConfigChangeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigChangeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigChangeRequest proto.InternalMessageInfo

func (m *ConfigChangeRequest) GetChangeType() metapb.ConfigChangeType {
	if m != nil {
		return m.ChangeType
	}
	return metapb.ConfigChangeType_AddNode
}

func (m *ConfigChangeRequest) GetReplica() metapb.Replica {
	if m != nil {
		return m.Replica
	}
	return metapb.Replica{}
}

// ConfigChangeResponse change peer response
type ConfigChangeResponse struct {
	Shard                metapb.Shard `protobuf:"bytes,1,opt,name=shard,proto3" json:"shard"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ConfigChangeResponse) Reset()         { *m = ConfigChangeResponse{} }
func (m *ConfigChangeResponse) String() string { return proto.CompactTextString(m) }
func (*ConfigChangeResponse) ProtoMessage()    {}
func (*ConfigChangeResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{61}
}
func (m *ConfigChangeResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigChangeResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigChangeResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigChangeResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigChangeResponse.Merge(m, src)
}
func (m *ConfigChangeResponse) XXX_Size() int {
	return m.Size()
}
func (m *ConfigChangeResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigChangeResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigChangeResponse proto.InternalMessageInfo

func (m *ConfigChangeResponse) GetShard() metapb.Shard {
	if m != nil {
		return m.Shard
	}
	return metapb.Shard{}
}

// CompactLogRequest compact raft log
type CompactLogRequest struct {
	CompactIndex         uint64   `protobuf:"varint,1,opt,name=compactIndex,proto3" json:"compactIndex,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CompactLogRequest) Reset()         { *m = CompactLogRequest{} }
func (m *CompactLogRequest) String() string { return proto.CompactTextString(m) }
func (*CompactLogRequest) ProtoMessage()    {}
func (*CompactLogRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{62}
}
func (m *CompactLogRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactLogRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactLogRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompactLogRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactLogRequest.Merge(m, src)
}
func (m *CompactLogRequest) XXX_Size() int {
	return m.Size()
}
func (m *CompactLogRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactLogRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CompactLogRequest proto.InternalMessageInfo

func (m *CompactLogRequest) GetCompactIndex() uint64 {
	if m != nil {
		return m.CompactIndex
	}
	return 0
}

// CompactLogResponse compact raft log
type CompactLogResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CompactLogResponse) Reset()         { *m = CompactLogResponse{} }
func (m *CompactLogResponse) String() string { return proto.CompactTextString(m) }
func (*CompactLogResponse) ProtoMessage()    {}
func (*CompactLogResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{63}
}
func (m *CompactLogResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactLogResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactLogResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompactLogResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactLogResponse.Merge(m, src)
}
func (m *CompactLogResponse) XXX_Size() int {
	return m.Size()
}
func (m *CompactLogResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactLogResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CompactLogResponse proto.InternalMessageInfo

// TransferLeaderRequest transfer leader
type TransferLeaderRequest struct {
	Replica              metapb.Replica `protobuf:"bytes,1,opt,name=replica,proto3" json:"replica"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TransferLeaderRequest) Reset()         { *m = TransferLeaderRequest{} }
func (m *TransferLeaderRequest) String() string { return proto.CompactTextString(m) }
func (*TransferLeaderRequest) ProtoMessage()    {}
func (*TransferLeaderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{64}
}
func (m *TransferLeaderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferLeaderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferLeaderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferLeaderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferLeaderRequest.Merge(m, src)
}
func (m *TransferLeaderRequest) XXX_Size() int {
	return m.Size()
}
func (m *TransferLeaderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferLeaderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TransferLeaderRequest proto.InternalMessageInfo

func (m *TransferLeaderRequest) GetReplica() metapb.Replica {
	if m != nil {
		return m.Replica
	}
	return metapb.Replica{}
}

type TransferLeaderResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TransferLeaderResponse) Reset()         { *m = TransferLeaderResponse{} }
func (m *TransferLeaderResponse) String() string { return proto.CompactTextString(m) }
func (*TransferLeaderResponse) ProtoMessage()    {}
func (*TransferLeaderResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{65}
}
func (m *TransferLeaderResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TransferLeaderResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TransferLeaderResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TransferLeaderResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TransferLeaderResponse.Merge(m, src)
}
func (m *TransferLeaderResponse) XXX_Size() int {
	return m.Size()
}
func (m *TransferLeaderResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TransferLeaderResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TransferLeaderResponse proto.InternalMessageInfo

// BatchSplitRequest batch split requests.
type BatchSplitRequest struct {
	// The requests for splitting a shard into multiple shards.
	// We split Shard A [0, 10) into B [0, 5) and C [5, 10), the len(requests) = 2, and
	// Shard A will not used after split completed.
	Requests             []SplitRequest `protobuf:"bytes,1,rep,name=requests,proto3" json:"requests"`
	Context              []byte         `protobuf:"bytes,2,opt,name=context,proto3" json:"context,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *BatchSplitRequest) Reset()         { *m = BatchSplitRequest{} }
func (m *BatchSplitRequest) String() string { return proto.CompactTextString(m) }
func (*BatchSplitRequest) ProtoMessage()    {}
func (*BatchSplitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{66}
}
func (m *BatchSplitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSplitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSplitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSplitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSplitRequest.Merge(m, src)
}
func (m *BatchSplitRequest) XXX_Size() int {
	return m.Size()
}
func (m *BatchSplitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSplitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSplitRequest proto.InternalMessageInfo

func (m *BatchSplitRequest) GetRequests() []SplitRequest {
	if m != nil {
		return m.Requests
	}
	return nil
}

func (m *BatchSplitRequest) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

type SplitRequest struct {
	// The start of the sub shard range
	Start []byte `protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"`
	// The end of the sub shard range
	End []byte `protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`
	// The new shard id
	NewShardID uint64 `protobuf:"varint,3,opt,name=newShardID,proto3" json:"newShardID,omitempty"`
	// The new replicas of the new shard
	NewReplicas          []metapb.Replica `protobuf:"bytes,4,rep,name=newReplicas,proto3" json:"newReplicas"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *SplitRequest) Reset()         { *m = SplitRequest{} }
func (m *SplitRequest) String() string { return proto.CompactTextString(m) }
func (*SplitRequest) ProtoMessage()    {}
func (*SplitRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{67}
}
func (m *SplitRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SplitRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SplitRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SplitRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SplitRequest.Merge(m, src)
}
func (m *SplitRequest) XXX_Size() int {
	return m.Size()
}
func (m *SplitRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SplitRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SplitRequest proto.InternalMessageInfo

func (m *SplitRequest) GetStart() []byte {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *SplitRequest) GetEnd() []byte {
	if m != nil {
		return m.End
	}
	return nil
}

func (m *SplitRequest) GetNewShardID() uint64 {
	if m != nil {
		return m.NewShardID
	}
	return 0
}

func (m *SplitRequest) GetNewReplicas() []metapb.Replica {
	if m != nil {
		return m.NewReplicas
	}
	return nil
}

type BatchSplitResponse struct {
	Shards               []metapb.Shard `protobuf:"bytes,1,rep,name=shards,proto3" json:"shards"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *BatchSplitResponse) Reset()         { *m = BatchSplitResponse{} }
func (m *BatchSplitResponse) String() string { return proto.CompactTextString(m) }
func (*BatchSplitResponse) ProtoMessage()    {}
func (*BatchSplitResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{68}
}
func (m *BatchSplitResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchSplitResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchSplitResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchSplitResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSplitResponse.Merge(m, src)
}
func (m *BatchSplitResponse) XXX_Size() int {
	return m.Size()
}
func (m *BatchSplitResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSplitResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSplitResponse proto.InternalMessageInfo

func (m *BatchSplitResponse) GetShards() []metapb.Shard {
	if m != nil {
		return m.Shards
	}
	return nil
}

type UpdateMetadataRequest struct {
	Metadata             metapb.ShardLocalState `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *UpdateMetadataRequest) Reset()         { *m = UpdateMetadataRequest{} }
func (m *UpdateMetadataRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateMetadataRequest) ProtoMessage()    {}
func (*UpdateMetadataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{69}
}
func (m *UpdateMetadataRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateMetadataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateMetadataRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateMetadataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateMetadataRequest.Merge(m, src)
}
func (m *UpdateMetadataRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateMetadataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateMetadataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateMetadataRequest proto.InternalMessageInfo

func (m *UpdateMetadataRequest) GetMetadata() metapb.ShardLocalState {
	if m != nil {
		return m.Metadata
	}
	return metapb.ShardLocalState{}
}

type UpdateMetadataResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateMetadataResponse) Reset()         { *m = UpdateMetadataResponse{} }
func (m *UpdateMetadataResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateMetadataResponse) ProtoMessage()    {}
func (*UpdateMetadataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{70}
}
func (m *UpdateMetadataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateMetadataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateMetadataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateMetadataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateMetadataResponse.Merge(m, src)
}
func (m *UpdateMetadataResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateMetadataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateMetadataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateMetadataResponse proto.InternalMessageInfo

type UpdateLabelsRequest struct {
	Labels               []metapb.Label `protobuf:"bytes,1,rep,name=labels,proto3" json:"labels"`
	Policy               UpdatePolicy   `protobuf:"varint,2,opt,name=policy,proto3,enum=rpcpb.UpdatePolicy" json:"policy,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *UpdateLabelsRequest) Reset()         { *m = UpdateLabelsRequest{} }
func (m *UpdateLabelsRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateLabelsRequest) ProtoMessage()    {}
func (*UpdateLabelsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{71}
}
func (m *UpdateLabelsRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateLabelsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateLabelsRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateLabelsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateLabelsRequest.Merge(m, src)
}
func (m *UpdateLabelsRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateLabelsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateLabelsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateLabelsRequest proto.InternalMessageInfo

func (m *UpdateLabelsRequest) GetLabels() []metapb.Label {
	if m != nil {
		return m.Labels
	}
	return nil
}

func (m *UpdateLabelsRequest) GetPolicy() UpdatePolicy {
	if m != nil {
		return m.Policy
	}
	return Add
}

type UpdateLabelsResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateLabelsResponse) Reset()         { *m = UpdateLabelsResponse{} }
func (m *UpdateLabelsResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateLabelsResponse) ProtoMessage()    {}
func (*UpdateLabelsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{72}
}
func (m *UpdateLabelsResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateLabelsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateLabelsResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateLabelsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateLabelsResponse.Merge(m, src)
}
func (m *UpdateLabelsResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateLabelsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateLabelsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateLabelsResponse proto.InternalMessageInfo

// UpdateTxnRecordRequest update txn record request
type UpdateTxnRecordRequest struct {
	TxnRecord            txnpb.TxnRecord `protobuf:"bytes,1,opt,name=txnRecord,proto3" json:"txnRecord"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *UpdateTxnRecordRequest) Reset()         { *m = UpdateTxnRecordRequest{} }
func (m *UpdateTxnRecordRequest) String() string { return proto.CompactTextString(m) }
func (*UpdateTxnRecordRequest) ProtoMessage()    {}
func (*UpdateTxnRecordRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{73}
}
func (m *UpdateTxnRecordRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTxnRecordRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTxnRecordRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateTxnRecordRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTxnRecordRequest.Merge(m, src)
}
func (m *UpdateTxnRecordRequest) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTxnRecordRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTxnRecordRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTxnRecordRequest proto.InternalMessageInfo

func (m *UpdateTxnRecordRequest) GetTxnRecord() txnpb.TxnRecord {
	if m != nil {
		return m.TxnRecord
	}
	return txnpb.TxnRecord{}
}

// UpdateTxnRecordResponse update txn record response
type UpdateTxnRecordResponse struct {
	TxnRecord            txnpb.TxnRecord `protobuf:"bytes,1,opt,name=txnRecord,proto3" json:"txnRecord"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *UpdateTxnRecordResponse) Reset()         { *m = UpdateTxnRecordResponse{} }
func (m *UpdateTxnRecordResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateTxnRecordResponse) ProtoMessage()    {}
func (*UpdateTxnRecordResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{74}
}
func (m *UpdateTxnRecordResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateTxnRecordResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateTxnRecordResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateTxnRecordResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateTxnRecordResponse.Merge(m, src)
}
func (m *UpdateTxnRecordResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateTxnRecordResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateTxnRecordResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateTxnRecordResponse proto.InternalMessageInfo

func (m *UpdateTxnRecordResponse) GetTxnRecord() txnpb.TxnRecord {
	if m != nil {
		return m.TxnRecord
	}
	return txnpb.TxnRecord{}
}

// DeleteTxnRecordRequest delete txn record request
type DeleteTxnRecordRequest struct {
	TxnRecordRouteKey    []byte   `protobuf:"bytes,1,opt,name=txnRecordRouteKey,proto3" json:"txnRecordRouteKey,omitempty"`
	TxnID                []byte   `protobuf:"bytes,2,opt,name=txnID,proto3" json:"txnID,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteTxnRecordRequest) Reset()         { *m = DeleteTxnRecordRequest{} }
func (m *DeleteTxnRecordRequest) String() string { return proto.CompactTextString(m) }
func (*DeleteTxnRecordRequest) ProtoMessage()    {}
func (*DeleteTxnRecordRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{75}
}
func (m *DeleteTxnRecordRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteTxnRecordRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteTxnRecordRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteTxnRecordRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteTxnRecordRequest.Merge(m, src)
}
func (m *DeleteTxnRecordRequest) XXX_Size() int {
	return m.Size()
}
func (m *DeleteTxnRecordRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteTxnRecordRequest.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteTxnRecordRequest proto.InternalMessageInfo

func (m *DeleteTxnRecordRequest) GetTxnRecordRouteKey() []byte {
	if m != nil {
		return m.TxnRecordRouteKey
	}
	return nil
}

func (m *DeleteTxnRecordRequest) GetTxnID() []byte {
	if m != nil {
		return m.TxnID
	}
	return nil
}

// DeleteTxnRecordResponse delete txn record response
type DeleteTxnRecordResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteTxnRecordResponse) Reset()         { *m = DeleteTxnRecordResponse{} }
func (m *DeleteTxnRecordResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteTxnRecordResponse) ProtoMessage()    {}
func (*DeleteTxnRecordResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{76}
}
func (m *DeleteTxnRecordResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteTxnRecordResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteTxnRecordResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteTxnRecordResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteTxnRecordResponse.Merge(m, src)
}
func (m *DeleteTxnRecordResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteTxnRecordResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteTxnRecordResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteTxnRecordResponse proto.InternalMessageInfo

// CommitTxnWriteDataRequest commit txn write data request
type CommitTxnWriteDataRequest struct {
	OriginKey            []byte          `protobuf:"bytes,1,opt,name=originKey,proto3" json:"originKey,omitempty"`
	CommitTS             hlcpb.Timestamp `protobuf:"bytes,2,opt,name=commitTS,proto3" json:"commitTS"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *CommitTxnWriteDataRequest) Reset()         { *m = CommitTxnWriteDataRequest{} }
func (m *CommitTxnWriteDataRequest) String() string { return proto.CompactTextString(m) }
func (*CommitTxnWriteDataRequest) ProtoMessage()    {}
func (*CommitTxnWriteDataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{77}
}
func (m *CommitTxnWriteDataRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitTxnWriteDataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitTxnWriteDataRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommitTxnWriteDataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitTxnWriteDataRequest.Merge(m, src)
}
func (m *CommitTxnWriteDataRequest) XXX_Size() int {
	return m.Size()
}
func (m *CommitTxnWriteDataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitTxnWriteDataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CommitTxnWriteDataRequest proto.InternalMessageInfo

func (m *CommitTxnWriteDataRequest) GetOriginKey() []byte {
	if m != nil {
		return m.OriginKey
	}
	return nil
}

func (m *CommitTxnWriteDataRequest) GetCommitTS() hlcpb.Timestamp {
	if m != nil {
		return m.CommitTS
	}
	return hlcpb.Timestamp{}
}

// CommitTxnWriteDataResponse commit txn write data response
type CommitTxnWriteDataResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CommitTxnWriteDataResponse) Reset()         { *m = CommitTxnWriteDataResponse{} }
func (m *CommitTxnWriteDataResponse) String() string { return proto.CompactTextString(m) }
func (*CommitTxnWriteDataResponse) ProtoMessage()    {}
func (*CommitTxnWriteDataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{78}
}
func (m *CommitTxnWriteDataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitTxnWriteDataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitTxnWriteDataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommitTxnWriteDataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitTxnWriteDataResponse.Merge(m, src)
}
func (m *CommitTxnWriteDataResponse) XXX_Size() int {
	return m.Size()
}
func (m *CommitTxnWriteDataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitTxnWriteDataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CommitTxnWriteDataResponse proto.InternalMessageInfo

// RollbackTxnWriteDataRequest rollback txn write data request
type RollbackTxnWriteDataRequest struct {
	OriginKey            []byte          `protobuf:"bytes,1,opt,name=originKey,proto3" json:"originKey,omitempty"`
	Timestamp            hlcpb.Timestamp `protobuf:"bytes,2,opt,name=timestamp,proto3" json:"timestamp"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *RollbackTxnWriteDataRequest) Reset()         { *m = RollbackTxnWriteDataRequest{} }
func (m *RollbackTxnWriteDataRequest) String() string { return proto.CompactTextString(m) }
func (*RollbackTxnWriteDataRequest) ProtoMessage()    {}
func (*RollbackTxnWriteDataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{79}
}
func (m *RollbackTxnWriteDataRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RollbackTxnWriteDataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RollbackTxnWriteDataRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RollbackTxnWriteDataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RollbackTxnWriteDataRequest.Merge(m, src)
}
func (m *RollbackTxnWriteDataRequest) XXX_Size() int {
	return m.Size()
}
func (m *RollbackTxnWriteDataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RollbackTxnWriteDataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RollbackTxnWriteDataRequest proto.InternalMessageInfo

func (m *RollbackTxnWriteDataRequest) GetOriginKey() []byte {
	if m != nil {
		return m.OriginKey
	}
	return nil
}

func (m *RollbackTxnWriteDataRequest) GetTimestamp() hlcpb.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return hlcpb.Timestamp{}
}

// RollbackTxnWriteDataResponse rollback txn write data response
type RollbackTxnWriteDataResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *RollbackTxnWriteDataResponse) Reset()         { *m = RollbackTxnWriteDataResponse{} }
func (m *RollbackTxnWriteDataResponse) String() string { return proto.CompactTextString(m) }
func (*RollbackTxnWriteDataResponse) ProtoMessage()    {}
func (*RollbackTxnWriteDataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{80}
}
func (m *RollbackTxnWriteDataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RollbackTxnWriteDataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RollbackTxnWriteDataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RollbackTxnWriteDataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RollbackTxnWriteDataResponse.Merge(m, src)
}
func (m *RollbackTxnWriteDataResponse) XXX_Size() int {
	return m.Size()
}
func (m *RollbackTxnWriteDataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RollbackTxnWriteDataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RollbackTxnWriteDataResponse proto.InternalMessageInfo

// CleanTxnMVCCDataRequest clean txn mvcc data request
type CleanTxnMVCCDataRequest struct {
	Timestamp            hlcpb.Timestamp `protobuf:"bytes,1,opt,name=timestamp,proto3" json:"timestamp"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *CleanTxnMVCCDataRequest) Reset()         { *m = CleanTxnMVCCDataRequest{} }
func (m *CleanTxnMVCCDataRequest) String() string { return proto.CompactTextString(m) }
func (*CleanTxnMVCCDataRequest) ProtoMessage()    {}
func (*CleanTxnMVCCDataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{81}
}
func (m *CleanTxnMVCCDataRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CleanTxnMVCCDataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CleanTxnMVCCDataRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CleanTxnMVCCDataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CleanTxnMVCCDataRequest.Merge(m, src)
}
func (m *CleanTxnMVCCDataRequest) XXX_Size() int {
	return m.Size()
}
func (m *CleanTxnMVCCDataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CleanTxnMVCCDataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CleanTxnMVCCDataRequest proto.InternalMessageInfo

func (m *CleanTxnMVCCDataRequest) GetTimestamp() hlcpb.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return hlcpb.Timestamp{}
}

// CleanTxnMVCCDataResponse clean txn mvcc data response
type CleanTxnMVCCDataResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CleanTxnMVCCDataResponse) Reset()         { *m = CleanTxnMVCCDataResponse{} }
func (m *CleanTxnMVCCDataResponse) String() string { return proto.CompactTextString(m) }
func (*CleanTxnMVCCDataResponse) ProtoMessage()    {}
func (*CleanTxnMVCCDataResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{82}
}
func (m *CleanTxnMVCCDataResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CleanTxnMVCCDataResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CleanTxnMVCCDataResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CleanTxnMVCCDataResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CleanTxnMVCCDataResponse.Merge(m, src)
}
func (m *CleanTxnMVCCDataResponse) XXX_Size() int {
	return m.Size()
}
func (m *CleanTxnMVCCDataResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CleanTxnMVCCDataResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CleanTxnMVCCDataResponse proto.InternalMessageInfo

// KVSetRequest kv set request
type KVSetRequest struct {
	Key                  []byte   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                []byte   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KVSetRequest) Reset()         { *m = KVSetRequest{} }
func (m *KVSetRequest) String() string { return proto.CompactTextString(m) }
func (*KVSetRequest) ProtoMessage()    {}
func (*KVSetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{83}
}
func (m *KVSetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVSetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVSetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVSetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVSetRequest.Merge(m, src)
}
func (m *KVSetRequest) XXX_Size() int {
	return m.Size()
}
func (m *KVSetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_KVSetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_KVSetRequest proto.InternalMessageInfo

func (m *KVSetRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *KVSetRequest) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// KVSetResponse kv set response
type KVSetResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KVSetResponse) Reset()         { *m = KVSetResponse{} }
func (m *KVSetResponse) String() string { return proto.CompactTextString(m) }
func (*KVSetResponse) ProtoMessage()    {}
func (*KVSetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{84}
}
func (m *KVSetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVSetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVSetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVSetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVSetResponse.Merge(m, src)
}
func (m *KVSetResponse) XXX_Size() int {
	return m.Size()
}
func (m *KVSetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_KVSetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_KVSetResponse proto.InternalMessageInfo

// KVBatchSetRequest kv batch set request
type KVBatchSetRequest struct {
	Requests             []KVSetRequest `protobuf:"bytes,1,rep,name=requests,proto3" json:"requests"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *KVBatchSetRequest) Reset()         { *m = KVBatchSetRequest{} }
func (m *KVBatchSetRequest) String() string { return proto.CompactTextString(m) }
func (*KVBatchSetRequest) ProtoMessage()    {}
func (*KVBatchSetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{85}
}
func (m *KVBatchSetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVBatchSetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVBatchSetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVBatchSetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVBatchSetRequest.Merge(m, src)
}
func (m *KVBatchSetRequest) XXX_Size() int {
	return m.Size()
}
func (m *KVBatchSetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_KVBatchSetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_KVBatchSetRequest proto.InternalMessageInfo

func (m *KVBatchSetRequest) GetRequests() []KVSetRequest {
	if m != nil {
		return m.Requests
	}
	return nil
}

// KVBatchSetResponse kv batch set response
type KVBatchSetResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KVBatchSetResponse) Reset()         { *m = KVBatchSetResponse{} }
func (m *KVBatchSetResponse) String() string { return proto.CompactTextString(m) }
func (*KVBatchSetResponse) ProtoMessage()    {}
func (*KVBatchSetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{86}
}
func (m *KVBatchSetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVBatchSetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVBatchSetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVBatchSetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVBatchSetResponse.Merge(m, src)
}
func (m *KVBatchSetResponse) XXX_Size() int {
	return m.Size()
}
func (m *KVBatchSetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_KVBatchSetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_KVBatchSetResponse proto.InternalMessageInfo

// KVGetRequest kv get request
type KVGetRequest struct {
	Key                  []byte   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KVGetRequest) Reset()         { *m = KVGetRequest{} }
func (m *KVGetRequest) String() string { return proto.CompactTextString(m) }
func (*KVGetRequest) ProtoMessage()    {}
func (*KVGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{87}
}
func (m *KVGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVGetRequest.Merge(m, src)
}
func (m *KVGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *KVGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_KVGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_KVGetRequest proto.InternalMessageInfo

func (m *KVGetRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

// KVGetResponse kv get response
type KVGetResponse struct {
	Value                []byte   `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KVGetResponse) Reset()         { *m = KVGetResponse{} }
func (m *KVGetResponse) String() string { return proto.CompactTextString(m) }
func (*KVGetResponse) ProtoMessage()    {}
func (*KVGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{88}
}
func (m *KVGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVGetResponse.Merge(m, src)
}
func (m *KVGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *KVGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_KVGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_KVGetResponse proto.InternalMessageInfo

func (m *KVGetResponse) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// KVBatchGetRequest kv batch get request
type KVBatchGetRequest struct {
	Keys                 [][]byte `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KVBatchGetRequest) Reset()         { *m = KVBatchGetRequest{} }
func (m *KVBatchGetRequest) String() string { return proto.CompactTextString(m) }
func (*KVBatchGetRequest) ProtoMessage()    {}
func (*KVBatchGetRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{89}
}
func (m *KVBatchGetRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVBatchGetRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVBatchGetRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVBatchGetRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVBatchGetRequest.Merge(m, src)
}
func (m *KVBatchGetRequest) XXX_Size() int {
	return m.Size()
}
func (m *KVBatchGetRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_KVBatchGetRequest.DiscardUnknown(m)
}

var xxx_messageInfo_KVBatchGetRequest proto.InternalMessageInfo

func (m *KVBatchGetRequest) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

// KVBatchGetResponse kv batch get response
type KVBatchGetResponse struct {
	Values               [][]byte `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KVBatchGetResponse) Reset()         { *m = KVBatchGetResponse{} }
func (m *KVBatchGetResponse) String() string { return proto.CompactTextString(m) }
func (*KVBatchGetResponse) ProtoMessage()    {}
func (*KVBatchGetResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{90}
}
func (m *KVBatchGetResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVBatchGetResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVBatchGetResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVBatchGetResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVBatchGetResponse.Merge(m, src)
}
func (m *KVBatchGetResponse) XXX_Size() int {
	return m.Size()
}
func (m *KVBatchGetResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_KVBatchGetResponse.DiscardUnknown(m)
}

var xxx_messageInfo_KVBatchGetResponse proto.InternalMessageInfo

func (m *KVBatchGetResponse) GetValues() [][]byte {
	if m != nil {
		return m.Values
	}
	return nil
}

// KVDeleteRequest kv Delete request
type KVDeleteRequest struct {
	Key                  []byte   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KVDeleteRequest) Reset()         { *m = KVDeleteRequest{} }
func (m *KVDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*KVDeleteRequest) ProtoMessage()    {}
func (*KVDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{91}
}
func (m *KVDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVDeleteRequest.Merge(m, src)
}
func (m *KVDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *KVDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_KVDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_KVDeleteRequest proto.InternalMessageInfo

func (m *KVDeleteRequest) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

// KVDeleteResponse kv Delete response
type KVDeleteResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KVDeleteResponse) Reset()         { *m = KVDeleteResponse{} }
func (m *KVDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*KVDeleteResponse) ProtoMessage()    {}
func (*KVDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{92}
}
func (m *KVDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVDeleteResponse.Merge(m, src)
}
func (m *KVDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *KVDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_KVDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_KVDeleteResponse proto.InternalMessageInfo

// KVBatchDeleteRequest kv BatchDelete request
type KVBatchDeleteRequest struct {
	Keys                 [][]byte `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KVBatchDeleteRequest) Reset()         { *m = KVBatchDeleteRequest{} }
func (m *KVBatchDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*KVBatchDeleteRequest) ProtoMessage()    {}
func (*KVBatchDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{93}
}
func (m *KVBatchDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVBatchDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVBatchDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVBatchDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVBatchDeleteRequest.Merge(m, src)
}
func (m *KVBatchDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *KVBatchDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_KVBatchDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_KVBatchDeleteRequest proto.InternalMessageInfo

func (m *KVBatchDeleteRequest) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

// KVBatchDeleteResponse kv BatchDelete response
type KVBatchDeleteResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KVBatchDeleteResponse) Reset()         { *m = KVBatchDeleteResponse{} }
func (m *KVBatchDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*KVBatchDeleteResponse) ProtoMessage()    {}
func (*KVBatchDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{94}
}
func (m *KVBatchDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVBatchDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVBatchDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVBatchDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVBatchDeleteResponse.Merge(m, src)
}
func (m *KVBatchDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *KVBatchDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_KVBatchDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_KVBatchDeleteResponse proto.InternalMessageInfo

// KVRangeDeleteRequest kv RangeDelete request
type KVRangeDeleteRequest struct {
	// Start include
	Start []byte `protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"`
	// End exclude
	End                  []byte   `protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KVRangeDeleteRequest) Reset()         { *m = KVRangeDeleteRequest{} }
func (m *KVRangeDeleteRequest) String() string { return proto.CompactTextString(m) }
func (*KVRangeDeleteRequest) ProtoMessage()    {}
func (*KVRangeDeleteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{95}
}
func (m *KVRangeDeleteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVRangeDeleteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVRangeDeleteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVRangeDeleteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVRangeDeleteRequest.Merge(m, src)
}
func (m *KVRangeDeleteRequest) XXX_Size() int {
	return m.Size()
}
func (m *KVRangeDeleteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_KVRangeDeleteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_KVRangeDeleteRequest proto.InternalMessageInfo

func (m *KVRangeDeleteRequest) GetStart() []byte {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *KVRangeDeleteRequest) GetEnd() []byte {
	if m != nil {
		return m.End
	}
	return nil
}

// KVRangeDeleteResponse kv RangeDelete response
type KVRangeDeleteResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KVRangeDeleteResponse) Reset()         { *m = KVRangeDeleteResponse{} }
func (m *KVRangeDeleteResponse) String() string { return proto.CompactTextString(m) }
func (*KVRangeDeleteResponse) ProtoMessage()    {}
func (*KVRangeDeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{96}
}
func (m *KVRangeDeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVRangeDeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVRangeDeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVRangeDeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVRangeDeleteResponse.Merge(m, src)
}
func (m *KVRangeDeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *KVRangeDeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_KVRangeDeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_KVRangeDeleteResponse proto.InternalMessageInfo

// KVScanRequest kv scan request
type KVScanRequest struct {
	// Start include, not set means min key
	Start []byte `protobuf:"bytes,1,opt,name=start,proto3" json:"start,omitempty"`
	// End exclude, not set means max key
	End []byte `protobuf:"bytes,2,opt,name=end,proto3" json:"end,omitempty"`
	// Limit maximum count of scanned data
	Limit uint64 `protobuf:"varint,3,opt,name=limit,proto3" json:"limit,omitempty"`
	// LimitBytes maximum count of scanned data
	LimitBytes uint64 `protobuf:"varint,4,opt,name=limitBytes,proto3" json:"limitBytes,omitempty"`
	// WithValue return the value
	WithValue bool `protobuf:"varint,5,opt,name=withValue,proto3" json:"withValue,omitempty"`
	// OnlyCount only returns count
	OnlyCount            bool     `protobuf:"varint,6,opt,name=onlyCount,proto3" json:"onlyCount,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KVScanRequest) Reset()         { *m = KVScanRequest{} }
func (m *KVScanRequest) String() string { return proto.CompactTextString(m) }
func (*KVScanRequest) ProtoMessage()    {}
func (*KVScanRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{97}
}
func (m *KVScanRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVScanRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVScanRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVScanRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVScanRequest.Merge(m, src)
}
func (m *KVScanRequest) XXX_Size() int {
	return m.Size()
}
func (m *KVScanRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_KVScanRequest.DiscardUnknown(m)
}

var xxx_messageInfo_KVScanRequest proto.InternalMessageInfo

func (m *KVScanRequest) GetStart() []byte {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *KVScanRequest) GetEnd() []byte {
	if m != nil {
		return m.End
	}
	return nil
}

func (m *KVScanRequest) GetLimit() uint64 {
	if m != nil {
		return m.Limit
	}
	return 0
}

func (m *KVScanRequest) GetLimitBytes() uint64 {
	if m != nil {
		return m.LimitBytes
	}
	return 0
}

func (m *KVScanRequest) GetWithValue() bool {
	if m != nil {
		return m.WithValue
	}
	return false
}

func (m *KVScanRequest) GetOnlyCount() bool {
	if m != nil {
		return m.OnlyCount
	}
	return false
}

// KVScanResponse kv scan response
type KVScanResponse struct {
	// Keys scan keys result
	Keys [][]byte `protobuf:"bytes,1,rep,name=keys,proto3" json:"keys,omitempty"`
	// Values scan values result
	Values [][]byte `protobuf:"bytes,2,rep,name=values,proto3" json:"values,omitempty"`
	// Count scan count result
	Count uint64 `protobuf:"varint,3,opt,name=count,proto3" json:"count,omitempty"`
	// Completed true if no data in current shard
	Completed bool `protobuf:"varint,4,opt,name=completed,proto3" json:"completed,omitempty"`
	// ShardEnd shard end key
	ShardEnd             []byte   `protobuf:"bytes,5,opt,name=shardEnd,proto3" json:"shardEnd,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KVScanResponse) Reset()         { *m = KVScanResponse{} }
func (m *KVScanResponse) String() string { return proto.CompactTextString(m) }
func (*KVScanResponse) ProtoMessage()    {}
func (*KVScanResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_25e491924c678914, []int{98}
}
func (m *KVScanResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVScanResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVScanResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVScanResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVScanResponse.Merge(m, src)
}
func (m *KVScanResponse) XXX_Size() int {
	return m.Size()
}
func (m *KVScanResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_KVScanResponse.DiscardUnknown(m)
}

var xxx_messageInfo_KVScanResponse proto.InternalMessageInfo

func (m *KVScanResponse) GetKeys() [][]byte {
	if m != nil {
		return m.Keys
	}
	return nil
}

func (m *KVScanResponse) GetValues() [][]byte {
	if m != nil {
		return m.Values
	}
	return nil
}

func (m *KVScanResponse) GetCount() uint64 {
	if m != nil {
		return m.Count
	}
	return 0
}

func (m *KVScanResponse) GetCompleted() bool {
	if m != nil {
		return m.Completed
	}
	return false
}

func (m *KVScanResponse) GetShardEnd() []byte {
	if m != nil {
		return m.ShardEnd
	}
	return nil
}

func init() {
	proto.RegisterEnum("rpcpb.Type", Type_name, Type_value)
	proto.RegisterEnum("rpcpb.ReplicaRoleType", ReplicaRoleType_name, ReplicaRoleType_value)
	proto.RegisterEnum("rpcpb.LabelConstraintOp", LabelConstraintOp_name, LabelConstraintOp_value)
	proto.RegisterEnum("rpcpb.CmdType", CmdType_name, CmdType_value)
	proto.RegisterEnum("rpcpb.InternalCmd", InternalCmd_name, InternalCmd_value)
	proto.RegisterEnum("rpcpb.UpdatePolicy", UpdatePolicy_name, UpdatePolicy_value)
	proto.RegisterEnum("rpcpb.ReplicaSelectPolicy", ReplicaSelectPolicy_name, ReplicaSelectPolicy_value)
	proto.RegisterType((*ProphetRequest)(nil), "rpcpb.ProphetRequest")
	proto.RegisterType((*ProphetResponse)(nil), "rpcpb.ProphetResponse")
	proto.RegisterType((*ShardHeartbeatReq)(nil), "rpcpb.ShardHeartbeatReq")
	proto.RegisterType((*ShardHeartbeatRsp)(nil), "rpcpb.ShardHeartbeatRsp")
	proto.RegisterType((*PutStoreReq)(nil), "rpcpb.PutStoreReq")
	proto.RegisterType((*PutStoreRsp)(nil), "rpcpb.PutStoreRsp")
	proto.RegisterType((*StoreHeartbeatReq)(nil), "rpcpb.StoreHeartbeatReq")
	proto.RegisterType((*StoreHeartbeatRsp)(nil), "rpcpb.StoreHeartbeatRsp")
	proto.RegisterType((*GetStoreReq)(nil), "rpcpb.GetStoreReq")
	proto.RegisterType((*GetStoreRsp)(nil), "rpcpb.GetStoreRsp")
	proto.RegisterType((*AllocIDReq)(nil), "rpcpb.AllocIDReq")
	proto.RegisterType((*AllocIDRsp)(nil), "rpcpb.AllocIDRsp")
	proto.RegisterType((*AskBatchSplitReq)(nil), "rpcpb.AskBatchSplitReq")
	proto.RegisterType((*AskBatchSplitRsp)(nil), "rpcpb.AskBatchSplitRsp")
	proto.RegisterType((*CreateDestroyingReq)(nil), "rpcpb.CreateDestroyingReq")
	proto.RegisterType((*CreateDestroyingRsp)(nil), "rpcpb.CreateDestroyingRsp")
	proto.RegisterType((*GetDestroyingReq)(nil), "rpcpb.GetDestroyingReq")
	proto.RegisterType((*GetDestroyingRsp)(nil), "rpcpb.GetDestroyingRsp")
	proto.RegisterType((*ReportDestroyedReq)(nil), "rpcpb.ReportDestroyedReq")
	proto.RegisterType((*ReportDestroyedRsp)(nil), "rpcpb.ReportDestroyedRsp")
	proto.RegisterType((*SplitID)(nil), "rpcpb.SplitID")
	proto.RegisterType((*CreateWatcherReq)(nil), "rpcpb.CreateWatcherReq")
	proto.RegisterType((*CreateShardsReq)(nil), "rpcpb.CreateShardsReq")
	proto.RegisterType((*CreateShardsRsp)(nil), "rpcpb.CreateShardsRsp")
	proto.RegisterType((*RemoveShardsReq)(nil), "rpcpb.RemoveShardsReq")
	proto.RegisterType((*RemoveShardsRsp)(nil), "rpcpb.RemoveShardsRsp")
	proto.RegisterType((*CheckShardStateReq)(nil), "rpcpb.CheckShardStateReq")
	proto.RegisterType((*CheckShardStateRsp)(nil), "rpcpb.CheckShardStateRsp")
	proto.RegisterType((*PutPlacementRuleReq)(nil), "rpcpb.PutPlacementRuleReq")
	proto.RegisterType((*PutPlacementRuleRsp)(nil), "rpcpb.PutPlacementRuleRsp")
	proto.RegisterType((*GetAppliedRulesReq)(nil), "rpcpb.GetAppliedRulesReq")
	proto.RegisterType((*GetAppliedRulesRsp)(nil), "rpcpb.GetAppliedRulesRsp")
	proto.RegisterType((*CreateJobReq)(nil), "rpcpb.CreateJobReq")
	proto.RegisterType((*CreateJobRsp)(nil), "rpcpb.CreateJobRsp")
	proto.RegisterType((*RemoveJobReq)(nil), "rpcpb.RemoveJobReq")
	proto.RegisterType((*RemoveJobRsp)(nil), "rpcpb.RemoveJobRsp")
	proto.RegisterType((*ExecuteJobReq)(nil), "rpcpb.ExecuteJobReq")
	proto.RegisterType((*ExecuteJobRsp)(nil), "rpcpb.ExecuteJobRsp")
	proto.RegisterType((*AddScheduleGroupRuleReq)(nil), "rpcpb.AddScheduleGroupRuleReq")
	proto.RegisterType((*AddScheduleGroupRuleRsp)(nil), "rpcpb.AddScheduleGroupRuleRsp")
	proto.RegisterType((*GetScheduleGroupRuleReq)(nil), "rpcpb.GetScheduleGroupRuleReq")
	proto.RegisterType((*GetScheduleGroupRuleRsp)(nil), "rpcpb.GetScheduleGroupRuleRsp")
	proto.RegisterType((*EventNotify)(nil), "rpcpb.EventNotify")
	proto.RegisterType((*InitEventData)(nil), "rpcpb.InitEventData")
	proto.RegisterType((*ShardEventData)(nil), "rpcpb.ShardEventData")
	proto.RegisterType((*StoreEventData)(nil), "rpcpb.StoreEventData")
	proto.RegisterType((*ConfigChange)(nil), "rpcpb.ConfigChange")
	proto.RegisterType((*TransferLeader)(nil), "rpcpb.TransferLeader")
	proto.RegisterType((*ConfigChangeV2)(nil), "rpcpb.ConfigChangeV2")
	proto.RegisterType((*Merge)(nil), "rpcpb.Merge")
	proto.RegisterType((*SplitShard)(nil), "rpcpb.SplitShard")
	proto.RegisterType((*LabelConstraint)(nil), "rpcpb.LabelConstraint")
	proto.RegisterType((*PlacementRule)(nil), "rpcpb.PlacementRule")
	proto.RegisterType((*RequestBatchHeader)(nil), "rpcpb.RequestBatchHeader")
	proto.RegisterType((*ResponseBatchHeader)(nil), "rpcpb.ResponseBatchHeader")
	proto.RegisterType((*RequestBatch)(nil), "rpcpb.RequestBatch")
	proto.RegisterType((*ResponseBatch)(nil), "rpcpb.ResponseBatch")
	proto.RegisterType((*Request)(nil), "rpcpb.Request")
	proto.RegisterType((*Range)(nil), "rpcpb.Range")
	proto.RegisterType((*Response)(nil), "rpcpb.Response")
	proto.RegisterType((*ConfigChangeRequest)(nil), "rpcpb.ConfigChangeRequest")
	proto.RegisterType((*ConfigChangeResponse)(nil), "rpcpb.ConfigChangeResponse")
	proto.RegisterType((*CompactLogRequest)(nil), "rpcpb.CompactLogRequest")
	proto.RegisterType((*CompactLogResponse)(nil), "rpcpb.CompactLogResponse")
	proto.RegisterType((*TransferLeaderRequest)(nil), "rpcpb.TransferLeaderRequest")
	proto.RegisterType((*TransferLeaderResponse)(nil), "rpcpb.TransferLeaderResponse")
	proto.RegisterType((*BatchSplitRequest)(nil), "rpcpb.BatchSplitRequest")
	proto.RegisterType((*SplitRequest)(nil), "rpcpb.SplitRequest")
	proto.RegisterType((*BatchSplitResponse)(nil), "rpcpb.BatchSplitResponse")
	proto.RegisterType((*UpdateMetadataRequest)(nil), "rpcpb.UpdateMetadataRequest")
	proto.RegisterType((*UpdateMetadataResponse)(nil), "rpcpb.UpdateMetadataResponse")
	proto.RegisterType((*UpdateLabelsRequest)(nil), "rpcpb.UpdateLabelsRequest")
	proto.RegisterType((*UpdateLabelsResponse)(nil), "rpcpb.UpdateLabelsResponse")
	proto.RegisterType((*UpdateTxnRecordRequest)(nil), "rpcpb.UpdateTxnRecordRequest")
	proto.RegisterType((*UpdateTxnRecordResponse)(nil), "rpcpb.UpdateTxnRecordResponse")
	proto.RegisterType((*DeleteTxnRecordRequest)(nil), "rpcpb.DeleteTxnRecordRequest")
	proto.RegisterType((*DeleteTxnRecordResponse)(nil), "rpcpb.DeleteTxnRecordResponse")
	proto.RegisterType((*CommitTxnWriteDataRequest)(nil), "rpcpb.CommitTxnWriteDataRequest")
	proto.RegisterType((*CommitTxnWriteDataResponse)(nil), "rpcpb.CommitTxnWriteDataResponse")
	proto.RegisterType((*RollbackTxnWriteDataRequest)(nil), "rpcpb.RollbackTxnWriteDataRequest")
	proto.RegisterType((*RollbackTxnWriteDataResponse)(nil), "rpcpb.RollbackTxnWriteDataResponse")
	proto.RegisterType((*CleanTxnMVCCDataRequest)(nil), "rpcpb.CleanTxnMVCCDataRequest")
	proto.RegisterType((*CleanTxnMVCCDataResponse)(nil), "rpcpb.CleanTxnMVCCDataResponse")
	proto.RegisterType((*KVSetRequest)(nil), "rpcpb.KVSetRequest")
	proto.RegisterType((*KVSetResponse)(nil), "rpcpb.KVSetResponse")
	proto.RegisterType((*KVBatchSetRequest)(nil), "rpcpb.KVBatchSetRequest")
	proto.RegisterType((*KVBatchSetResponse)(nil), "rpcpb.KVBatchSetResponse")
	proto.RegisterType((*KVGetRequest)(nil), "rpcpb.KVGetRequest")
	proto.RegisterType((*KVGetResponse)(nil), "rpcpb.KVGetResponse")
	proto.RegisterType((*KVBatchGetRequest)(nil), "rpcpb.KVBatchGetRequest")
	proto.RegisterType((*KVBatchGetResponse)(nil), "rpcpb.KVBatchGetResponse")
	proto.RegisterType((*KVDeleteRequest)(nil), "rpcpb.KVDeleteRequest")
	proto.RegisterType((*KVDeleteResponse)(nil), "rpcpb.KVDeleteResponse")
	proto.RegisterType((*KVBatchDeleteRequest)(nil), "rpcpb.KVBatchDeleteRequest")
	proto.RegisterType((*KVBatchDeleteResponse)(nil), "rpcpb.KVBatchDeleteResponse")
	proto.RegisterType((*KVRangeDeleteRequest)(nil), "rpcpb.KVRangeDeleteRequest")
	proto.RegisterType((*KVRangeDeleteResponse)(nil), "rpcpb.KVRangeDeleteResponse")
	proto.RegisterType((*KVScanRequest)(nil), "rpcpb.KVScanRequest")
	proto.RegisterType((*KVScanResponse)(nil), "rpcpb.KVScanResponse")
}

func init() { proto.RegisterFile("rpcpb.proto", fileDescriptor_25e491924c678914) }

var fileDescriptor_25e491924c678914 = []byte{
	// 4074 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x5b, 0x5b, 0x73, 0x1c, 0x49,
	0x56, 0x76, 0xdf, 0xbb, 0x4f, 0xdf, 0x52, 0xa9, 0x96, 0xd4, 0xd6, 0x78, 0x65, 0x53, 0x9e, 0x8b,
	0xd0, 0x0c, 0x32, 0x6b, 0xef, 0xe0, 0x1d, 0x58, 0x66, 0xd7, 0x6e, 0x79, 0x64, 0xf9, 0x36, 0x8a,
	0x92, 0xd1, 0xb0, 0x11, 0xbc, 0x94, 0xba, 0xd2, 0xad, 0xc6, 0xd5, 0x55, 0xe5, 0xaa, 0x94, 0x2d,
	0xbd, 0x00, 0x11, 0xbc, 0x11, 0x1b, 0xc1, 0xbf, 0x20, 0x02, 0x7e, 0x07, 0x0f, 0xc3, 0x65, 0x61,
	0x78, 0xe1, 0x71, 0x02, 0xfc, 0xc4, 0xcf, 0x20, 0xf2, 0x56, 0x95, 0x59, 0x17, 0xa9, 0xbd, 0x2f,
	0x56, 0xe5, 0xb9, 0xe5, 0xed, 0xe4, 0x97, 0xe7, 0x9c, 0x6c, 0x43, 0x37, 0x0a, 0xa7, 0xe1, 0xc9,
	0x6e, 0x18, 0x05, 0x34, 0xc0, 0x0d, 0xde, 0xd8, 0xfc, 0x93, 0xd9, 0x9c, 0x9e, 0x9e, 0x9d, 0xec,
	0x4e, 0x83, 0xc5, 0x9d, 0x85, 0x43, 0xa3, 0xf9, 0x79, 0x10, 0xcd, 0x67, 0x73, 0x5f, 0x36, 0xa6,
	0x67, 0x27, 0xe4, 0x4e, 0x78, 0x72, 0x87, 0x44, 0x51, 0x10, 0xa5, 0x7f, 0x85, 0x8d, 0xcd, 0xaf,
	0x96, 0x53, 0x5e, 0x10, 0xea, 0x24, 0x7f, 0xa4, 0xea, 0xfd, 0xe5, 0x54, 0xe9, 0xb9, 0xaf, 0xfe,
	0x95, 0x8a, 0x4b, 0x0e, 0xf8, 0xd4, 0x9b, 0x32, 0xc5, 0xf9, 0x82, 0xc4, 0xd4, 0x59, 0x84, 0x52,
	0xf9, 0x0f, 0x34, 0xe5, 0x59, 0x30, 0x0b, 0xee, 0x70, 0xf2, 0xc9, 0xd9, 0x2b, 0xde, 0xe2, 0x0d,
	0xfe, 0x25, 0xc4, 0xad, 0x7f, 0xee, 0xc2, 0xe0, 0x30, 0x0a, 0xc2, 0x53, 0x42, 0x6d, 0xf2, 0xe6,
	0x8c, 0xc4, 0x14, 0xaf, 0x43, 0x75, 0xee, 0x8e, 0x2b, 0xb7, 0x2a, 0xdb, 0xf5, 0x87, 0xcd, 0xf7,
	0x3f, 0xde, 0xac, 0x1e, 0xec, 0xd9, 0xd5, 0xb9, 0x8b, 0xc7, 0xd0, 0x8a, 0x69, 0x10, 0x91, 0x83,
	0xbd, 0x71, 0x95, 0x31, 0x6d, 0xd5, 0xc4, 0x37, 0xa1, 0x4e, 0x2f, 0x42, 0x32, 0xae, 0xdd, 0xaa,
	0x6c, 0x0f, 0xee, 0x76, 0x77, 0xc5, 0x26, 0xbc, 0xbc, 0x08, 0x89, 0xcd, 0x19, 0xf8, 0x1b, 0x18,
	0xc4, 0xa7, 0x4e, 0xe4, 0x3e, 0x26, 0x4e, 0x44, 0x4f, 0x88, 0x43, 0xc7, 0xf5, 0x5b, 0x95, 0xed,
	0xee, 0xdd, 0xb1, 0x14, 0x3d, 0x32, 0x98, 0x36, 0x79, 0xf3, 0xb0, 0xfe, 0xfd, 0x8f, 0x37, 0xaf,
	0xd9, 0x19, 0x2d, 0x6e, 0x87, 0xf5, 0x99, 0xda, 0x69, 0x98, 0x76, 0x0c, 0xa6, 0x6e, 0xc7, 0x60,
	0xe0, 0x9f, 0x41, 0x3b, 0x3c, 0xa3, 0x5c, 0x7a, 0xdc, 0xe4, 0x16, 0xb0, 0xb4, 0x70, 0x28, 0xc9,
	0xa9, 0x6e, 0x22, 0xc9, 0xb4, 0x66, 0x44, 0x6a, 0xb5, 0x0c, 0xad, 0x7d, 0x92, 0xd3, 0x52, 0x92,
	0xf8, 0xa7, 0xd0, 0x72, 0x3c, 0x2f, 0x98, 0x1e, 0xec, 0x8d, 0xdb, 0x5c, 0x69, 0x45, 0x2a, 0x3d,
	0x10, 0xd4, 0x54, 0x47, 0xc9, 0xe1, 0x09, 0xf4, 0x9d, 0xf8, 0xf5, 0x43, 0x87, 0x4e, 0x4f, 0x8f,
	0x42, 0x6f, 0x4e, 0xc7, 0x1d, 0xae, 0xb8, 0xa1, 0x14, 0x75, 0x5e, 0xaa, 0x6e, 0xea, 0xe0, 0x67,
	0x80, 0xa6, 0x11, 0x71, 0x28, 0xd9, 0x23, 0x31, 0x8d, 0x82, 0x8b, 0xb9, 0x3f, 0x1b, 0x03, 0xb7,
	0xb3, 0x29, 0xed, 0x4c, 0x32, 0xec, 0xd4, 0x54, 0x4e, 0x13, 0x1f, 0xc0, 0xd0, 0x26, 0x61, 0x10,
	0x51, 0x49, 0x23, 0xee, 0xb8, 0xcb, 0x8d, 0x5d, 0x97, 0xc6, 0x32, 0xdc, 0xd4, 0x56, 0x56, 0x8f,
	0xcd, 0x6e, 0x46, 0xa8, 0x36, 0xaa, 0x9e, 0x31, 0xbb, 0x7d, 0x9d, 0xa7, 0xcd, 0xce, 0xd0, 0x61,
	0x46, 0xc4, 0x18, 0xbf, 0x63, 0x33, 0x26, 0xd1, 0xb8, 0x6f, 0x18, 0x99, 0xe8, 0x3c, 0xcd, 0x88,
	0xa1, 0x83, 0x7f, 0x05, 0x3d, 0x41, 0xe0, 0xfe, 0x17, 0x8f, 0x07, 0xdc, 0xc6, 0xba, 0x61, 0x43,
	0xb0, 0x52, 0x13, 0x86, 0x06, 0xb3, 0x10, 0x91, 0x45, 0xf0, 0x56, 0x59, 0x18, 0x1a, 0x16, 0x6c,
	0x8d, 0xa5, 0x59, 0xd0, 0x35, 0xd8, 0xc2, 0x4e, 0x4f, 0xc9, 0xf4, 0x35, 0x6f, 0x1e, 0x51, 0x87,
	0x92, 0x31, 0x32, 0x16, 0x76, 0x62, 0x72, 0xb5, 0x85, 0xcd, 0xe8, 0xb1, 0x1d, 0x0f, 0xcf, 0xe8,
	0xa1, 0xe7, 0x4c, 0xc9, 0x82, 0xf8, 0xd4, 0x3e, 0xf3, 0xc8, 0x78, 0xc5, 0xd8, 0xf1, 0xc3, 0x0c,
	0x5b, 0xdb, 0xf1, 0xac, 0x26, 0x1b, 0xd8, 0x8c, 0xd0, 0x07, 0x61, 0xe8, 0xcd, 0x89, 0xcb, 0x28,
	0xf1, 0x18, 0x1b, 0x03, 0xdb, 0x37, 0xb9, 0xda, 0xc0, 0x32, 0x7a, 0xf8, 0x3e, 0x74, 0xc4, 0xaa,
	0x3d, 0x09, 0x4e, 0xc6, 0xab, 0xdc, 0xc8, 0xaa, 0xb1, 0xc8, 0x4f, 0x82, 0x93, 0x54, 0x3d, 0x95,
	0x65, 0x8a, 0x62, 0xb1, 0x98, 0xe2, 0xc8, 0x50, 0xb4, 0x15, 0x5d, 0x53, 0x4c, 0x64, 0xf1, 0x1f,
	0x03, 0x90, 0x73, 0x32, 0x3d, 0x13, 0x5d, 0xae, 0x71, 0xcd, 0x91, 0xd4, 0x7c, 0x94, 0x30, 0x52,
	0x55, 0x4d, 0x1a, 0xff, 0x39, 0x8c, 0x1c, 0xd7, 0x3d, 0x9a, 0x9e, 0x12, 0xf7, 0xcc, 0x23, 0xfb,
	0x51, 0x70, 0x16, 0xf2, 0xa5, 0x5c, 0xe7, 0x56, 0xb6, 0xd4, 0x21, 0x2c, 0x10, 0x49, 0xed, 0x15,
	0x5a, 0x60, 0x96, 0x19, 0x2c, 0xe4, 0x2c, 0x6f, 0x18, 0x96, 0xf7, 0x0b, 0x44, 0x34, 0xcb, 0x45,
	0x16, 0x18, 0x8c, 0x0f, 0x13, 0x18, 0x8f, 0xc3, 0xc0, 0x8f, 0x49, 0x29, 0x8e, 0x2b, 0xb4, 0xae,
	0x96, 0xa1, 0xf5, 0x08, 0x1a, 0xfc, 0x12, 0xe4, 0x78, 0xde, 0xb1, 0x45, 0x03, 0xaf, 0x43, 0xd3,
	0x23, 0x8e, 0x4b, 0x22, 0x8e, 0xdd, 0x1d, 0x5b, 0xb6, 0x0a, 0xb0, 0xbd, 0x71, 0x19, 0xb6, 0xc7,
	0xe1, 0xd2, 0xd8, 0xde, 0xbc, 0x0c, 0xdb, 0x35, 0x3b, 0xe5, 0xd8, 0xde, 0x2a, 0xc6, 0xf6, 0x44,
	0xb7, 0x18, 0xdb, 0xdb, 0xc5, 0xd8, 0x9e, 0x6a, 0x15, 0x61, 0x7b, 0xa7, 0x10, 0xdb, 0x13, 0x9d,
	0x72, 0x6c, 0x87, 0x4b, 0xb0, 0x3d, 0x51, 0x5f, 0x02, 0xdb, 0xbb, 0x97, 0x63, 0x7b, 0x62, 0x6a,
	0x29, 0x6c, 0xef, 0x5d, 0x8a, 0xed, 0x89, 0xad, 0xab, 0xb1, 0xbd, 0x7f, 0x09, 0xb6, 0xa7, 0xb3,
	0x33, 0xb1, 0x7d, 0x17, 0x1a, 0xe4, 0x2d, 0xf1, 0xa9, 0xc4, 0x63, 0xb5, 0x11, 0x8f, 0x18, 0xed,
	0x45, 0x40, 0xe7, 0xaf, 0x2e, 0xa4, 0x9e, 0x10, 0xcb, 0xc1, 0xf8, 0xb0, 0x1c, 0xc6, 0x93, 0x2e,
	0x2f, 0x87, 0x71, 0x54, 0x0e, 0xe3, 0xa9, 0x85, 0xab, 0x60, 0x7c, 0xe5, 0x52, 0x18, 0x4f, 0xd7,
	0x70, 0x19, 0x18, 0xc7, 0x97, 0xc3, 0x78, 0xba, 0xb9, 0xcb, 0xc0, 0xf8, 0xea, 0xa5, 0x30, 0x9e,
	0x0e, 0xec, 0x52, 0x18, 0x1f, 0x95, 0xc0, 0x78, 0xa2, 0x5e, 0x06, 0xe3, 0x6b, 0x25, 0x30, 0x9e,
	0x2a, 0x96, 0xc1, 0xf8, 0x7a, 0x19, 0x8c, 0x27, 0xaa, 0xcb, 0xc0, 0xf8, 0xc6, 0xd5, 0x30, 0x9e,
	0xd8, 0xfb, 0x30, 0x18, 0x1f, 0x5f, 0x0d, 0xe3, 0xa9, 0xe5, 0x42, 0x18, 0xff, 0x6d, 0x15, 0x56,
	0x72, 0xb1, 0xb0, 0x1e, 0x78, 0x57, 0xcc, 0xc0, 0x7b, 0x04, 0x0d, 0x8e, 0xa2, 0x1c, 0xcb, 0x7b,
	0xb6, 0x68, 0x60, 0x0c, 0x75, 0x4a, 0xa2, 0x05, 0x87, 0xef, 0xba, 0xcd, 0xbf, 0xf1, 0x67, 0x06,
	0x7a, 0x77, 0xef, 0x0e, 0x77, 0x65, 0xae, 0x62, 0x93, 0xd0, 0x9b, 0x4f, 0x9d, 0x04, 0xce, 0xbf,
	0x86, 0x9e, 0x1b, 0xbc, 0xf3, 0x25, 0x39, 0x1e, 0x37, 0x6e, 0xd5, 0xf8, 0xa2, 0x9b, 0xe2, 0xcc,
	0x53, 0x63, 0x75, 0x10, 0x74, 0x79, 0xfc, 0x4b, 0x18, 0x86, 0xc4, 0x77, 0x79, 0xec, 0x26, 0x4d,
	0x34, 0xb9, 0x89, 0x6c, 0x8f, 0xca, 0xcb, 0x32, 0xd2, 0xec, 0xf4, 0xc7, 0xcc, 0x7a, 0x02, 0xde,
	0x52, 0x2d, 0x39, 0x21, 0xaa, 0x5f, 0x21, 0x86, 0x37, 0xa1, 0x3d, 0x63, 0x0b, 0xf8, 0x94, 0x5c,
	0x70, 0xe4, 0xee, 0xd8, 0x49, 0xdb, 0xfa, 0xef, 0x5a, 0x6e, 0x3d, 0xe3, 0x90, 0xaf, 0x27, 0x23,
	0x6a, 0xeb, 0x29, 0x9a, 0xf8, 0xe7, 0x00, 0xfc, 0xf3, 0x51, 0x18, 0x4c, 0x4f, 0xf9, 0xa2, 0x66,
	0x07, 0xc0, 0x39, 0xca, 0xdb, 0x52, 0x59, 0xfc, 0x25, 0xf4, 0xa9, 0x13, 0xcd, 0xd8, 0xf5, 0xcb,
	0xe7, 0xc1, 0x17, 0xbf, 0x60, 0x99, 0x4d, 0x29, 0x7c, 0x1f, 0x7a, 0xd3, 0xc0, 0x7f, 0x35, 0x9f,
	0x4d, 0x4e, 0x1d, 0x7f, 0x46, 0xe4, 0xe6, 0x24, 0xa7, 0x4a, 0x63, 0xd9, 0x86, 0x20, 0xfe, 0x53,
	0x18, 0xd0, 0xc8, 0xf1, 0xe3, 0x57, 0x24, 0x7a, 0x26, 0xf6, 0x55, 0xdc, 0xba, 0x6b, 0xea, 0x3a,
	0x37, 0x98, 0x76, 0x46, 0x18, 0x5b, 0xd0, 0x58, 0x90, 0x68, 0xa6, 0xb2, 0x9f, 0x9e, 0xd4, 0x7a,
	0xce, 0x68, 0xb6, 0x60, 0xe1, 0x9f, 0x02, 0xc4, 0xec, 0xb6, 0xe1, 0xf3, 0x96, 0xbb, 0xa1, 0xee,
	0xb7, 0xa3, 0x84, 0x61, 0x6b, 0x42, 0x6c, 0x54, 0xfa, 0x28, 0x8f, 0xef, 0xca, 0xbb, 0x74, 0xad,
	0x60, 0x42, 0xc7, 0x77, 0xed, 0x8c, 0x30, 0xde, 0x86, 0xa1, 0x2b, 0xae, 0x81, 0xbd, 0x79, 0x44,
	0xa6, 0xd4, 0xbb, 0xe0, 0xd7, 0x6a, 0xdb, 0xce, 0x92, 0xad, 0xdb, 0xd0, 0xd5, 0x32, 0x35, 0x7e,
	0x0e, 0xf8, 0xd5, 0x5d, 0x91, 0xe7, 0x80, 0x35, 0xac, 0x7b, 0x9a, 0x50, 0x1c, 0xe2, 0x8f, 0xa1,
	0x2f, 0xcd, 0x48, 0x94, 0x17, 0xc2, 0x26, 0xd1, 0xfa, 0x0e, 0x56, 0x72, 0x59, 0x64, 0xea, 0x93,
	0x95, 0x8c, 0x4b, 0x30, 0xc9, 0x02, 0x9f, 0xc4, 0x50, 0x77, 0x1d, 0xea, 0xc8, 0x63, 0xc9, 0xbf,
	0xad, 0xcf, 0x72, 0x86, 0xe3, 0x30, 0x11, 0xac, 0x68, 0x82, 0x9f, 0x40, 0x57, 0xcb, 0x27, 0xcb,
	0xc2, 0x38, 0xeb, 0xa9, 0x26, 0x56, 0x6c, 0x09, 0x6f, 0xab, 0x61, 0x57, 0xcb, 0x86, 0x2d, 0x07,
	0x6c, 0xf5, 0x00, 0xd2, 0x74, 0xd4, 0xfa, 0x38, 0x6d, 0xc5, 0x61, 0xe9, 0x00, 0x7e, 0x01, 0x28,
	0x9b, 0x89, 0x16, 0x8e, 0x62, 0x04, 0x8d, 0x69, 0x70, 0xe6, 0x53, 0x3e, 0x8a, 0xbe, 0x2d, 0x1a,
	0xd6, 0x5e, 0x56, 0x3b, 0x0e, 0xf1, 0x1f, 0x42, 0x9b, 0x3b, 0xd3, 0xc1, 0x1e, 0x5b, 0x69, 0x06,
	0x1a, 0x03, 0xdd, 0xdf, 0x0e, 0xf6, 0x54, 0x00, 0xa6, 0xa4, 0xac, 0xbf, 0x86, 0xd5, 0x82, 0x2c,
	0xb6, 0x34, 0xf4, 0x1d, 0x41, 0x63, 0xee, 0xbb, 0xe4, 0x5c, 0x16, 0x30, 0x44, 0x83, 0x21, 0x48,
	0xa4, 0xb0, 0xaa, 0x76, 0xab, 0xb6, 0x5d, 0xb7, 0x93, 0x36, 0xde, 0x02, 0x10, 0xd7, 0xd1, 0x1e,
	0x9b, 0x56, 0x9d, 0x7b, 0xa3, 0x46, 0xb1, 0x7e, 0x59, 0x30, 0x80, 0x38, 0x54, 0x2b, 0x2f, 0x1c,
	0x72, 0x50, 0x00, 0x62, 0x44, 0xac, 0x3c, 0xb1, 0x76, 0x00, 0x65, 0x33, 0xde, 0xd2, 0x15, 0xdf,
	0xcb, 0xca, 0xf2, 0x35, 0x6b, 0x32, 0x43, 0x67, 0xca, 0x37, 0xc7, 0xaa, 0xab, 0x54, 0xec, 0x88,
	0xf3, 0x6d, 0x29, 0x67, 0x3d, 0x01, 0x9c, 0x4f, 0xd6, 0x4b, 0x97, 0xec, 0x06, 0xbb, 0xbb, 0xf9,
	0x62, 0x24, 0x75, 0x9f, 0x94, 0x60, 0x7d, 0x9d, 0xb7, 0xf5, 0x41, 0xb3, 0x7f, 0x04, 0x2d, 0xb9,
	0xb5, 0x6c, 0x6f, 0x7c, 0xf2, 0x2e, 0xc1, 0x64, 0xd1, 0x60, 0x87, 0xd6, 0x27, 0xef, 0x6c, 0xd5,
	0x21, 0x73, 0x65, 0xb6, 0x41, 0x26, 0xd1, 0xfa, 0x14, 0x50, 0x36, 0xe3, 0x67, 0xae, 0xf8, 0xca,
	0x73, 0x66, 0xdc, 0x5c, 0xdf, 0xe6, 0xdf, 0xd6, 0xb7, 0x30, 0xcc, 0x64, 0xf5, 0x2c, 0xad, 0x89,
	0x15, 0x1c, 0xd4, 0xb6, 0x7b, 0xb6, 0x6c, 0xb1, 0x8e, 0x3d, 0xe2, 0xc4, 0x34, 0xb9, 0xc5, 0x64,
	0xc7, 0x06, 0xd1, 0x5a, 0xc9, 0x18, 0x8c, 0x43, 0xeb, 0x0b, 0x16, 0x4d, 0x1b, 0x79, 0x3f, 0xbe,
	0x0e, 0xb5, 0xb9, 0xec, 0xa0, 0xfe, 0xb0, 0xf5, 0xfe, 0xc7, 0x9b, 0xb5, 0x83, 0xbd, 0xd8, 0x66,
	0x34, 0x66, 0x20, 0x13, 0x5e, 0x5a, 0x77, 0x00, 0xe7, 0x73, 0xfe, 0xd4, 0x46, 0x65, 0xbb, 0x97,
	0xb1, 0x61, 0xe7, 0x15, 0xe2, 0x90, 0x6d, 0x9c, 0x9b, 0xc4, 0xf3, 0xe2, 0x3c, 0xa6, 0x04, 0xe6,
	0xd7, 0x6e, 0x1a, 0xa5, 0x0b, 0x9c, 0xd2, 0x28, 0xd6, 0x23, 0x58, 0x2d, 0x28, 0x16, 0xe0, 0x5d,
	0xa8, 0x47, 0x2c, 0xd4, 0xa9, 0x18, 0xa1, 0x98, 0x21, 0x26, 0xcf, 0x28, 0x97, 0xb3, 0xd6, 0x0a,
	0xcc, 0xc4, 0xa1, 0xb5, 0x0b, 0x38, 0x5f, 0x3d, 0x28, 0xbf, 0x97, 0xad, 0x6f, 0xf2, 0xf2, 0xdc,
	0xf5, 0x1b, 0x11, 0x0f, 0x68, 0x2b, 0x32, 0x46, 0x29, 0x1f, 0x8d, 0x10, 0xb4, 0xee, 0x41, 0x4f,
	0x2f, 0x38, 0xe0, 0xdb, 0x50, 0xfb, 0xcb, 0xe0, 0x44, 0xce, 0xa6, 0xab, 0xdc, 0xf4, 0x49, 0x70,
	0x22, 0xd5, 0x18, 0xd7, 0x1a, 0xe8, 0x4a, 0x71, 0xc8, 0x8c, 0xe8, 0xc5, 0x87, 0xa5, 0x8d, 0xe8,
	0xa1, 0xae, 0xf5, 0x18, 0xfa, 0x46, 0x1d, 0x62, 0x29, 0x2b, 0x85, 0xf7, 0xca, 0x6d, 0xc3, 0x52,
	0xc9, 0x9d, 0xf2, 0x02, 0x36, 0x4a, 0x0a, 0x16, 0xf8, 0x9e, 0xb1, 0xa5, 0xd7, 0x93, 0xb3, 0x9a,
	0x95, 0x35, 0xf6, 0xf5, 0x7a, 0x89, 0xbd, 0x38, 0x64, 0xac, 0x92, 0x0a, 0x86, 0x75, 0x58, 0xc2,
	0x8a, 0x43, 0xfc, 0xa5, 0xb9, 0x97, 0x57, 0x0e, 0x43, 0x6e, 0xe8, 0x7f, 0x55, 0xa1, 0xab, 0xe5,
	0x85, 0x18, 0x41, 0x2d, 0x26, 0x6f, 0xa4, 0xfb, 0xb0, 0x4f, 0x1e, 0x0c, 0xab, 0x6a, 0x47, 0x5f,
	0x16, 0x38, 0xee, 0x42, 0x67, 0xee, 0xcf, 0x29, 0x57, 0x94, 0x81, 0x9a, 0x72, 0x9e, 0x03, 0x45,
	0x67, 0xe8, 0x6e, 0xa7, 0x62, 0xf8, 0x4b, 0x15, 0x1a, 0x72, 0xa5, 0xba, 0x11, 0xd6, 0x1c, 0x25,
	0x0c, 0xae, 0xa5, 0x09, 0x72, 0x35, 0x76, 0xdb, 0x0a, 0x35, 0x33, 0x46, 0x3b, 0x4a, 0x18, 0x52,
	0x2d, 0x69, 0xe3, 0x5f, 0xc0, 0x30, 0x4e, 0xe2, 0x5d, 0xa1, 0xdb, 0x2c, 0x0b, 0x87, 0xed, 0xac,
	0x28, 0xd7, 0x4e, 0xae, 0x78, 0xa1, 0xdd, 0x2a, 0x8d, 0x00, 0xb2, 0xa2, 0xd6, 0xaf, 0xa1, 0x6f,
	0xac, 0x42, 0x29, 0x44, 0x8e, 0xa1, 0x25, 0x92, 0x06, 0x05, 0x8e, 0xaa, 0xc9, 0x35, 0x98, 0x55,
	0x71, 0x9f, 0x32, 0x0d, 0xde, 0xb2, 0x7c, 0x18, 0x98, 0x6b, 0x55, 0x18, 0x30, 0xa4, 0x95, 0x26,
	0x71, 0xdf, 0xa8, 0xd4, 0x64, 0x0c, 0x2d, 0x71, 0xf3, 0xba, 0x7c, 0xd3, 0xda, 0xb6, 0x6a, 0x32,
	0x0d, 0x91, 0x6d, 0xca, 0x1b, 0x5a, 0xb6, 0xac, 0x8f, 0x61, 0x60, 0x2e, 0x72, 0xe1, 0xe1, 0xb8,
	0x80, 0x9e, 0x1e, 0x98, 0xe2, 0x3b, 0xac, 0x1f, 0x11, 0xc5, 0x57, 0x0a, 0xa3, 0x78, 0x55, 0xd3,
	0x91, 0x52, 0x2c, 0x6d, 0x98, 0x72, 0xd5, 0x97, 0x69, 0x5d, 0x2d, 0xb9, 0x87, 0x75, 0xd3, 0xbc,
	0xc8, 0xa6, 0xc9, 0x5a, 0x0f, 0x60, 0x60, 0x46, 0xea, 0x1f, 0xdc, 0xb9, 0xf5, 0x08, 0x06, 0x66,
	0x58, 0x8d, 0xef, 0x41, 0x4b, 0x74, 0xa1, 0x4e, 0x53, 0x51, 0x3e, 0xa1, 0xcc, 0x48, 0x49, 0xeb,
	0x26, 0x34, 0x78, 0xf4, 0xcf, 0xd6, 0x52, 0xe4, 0x28, 0x72, 0x8d, 0x64, 0xcb, 0x7a, 0x0e, 0x90,
	0x46, 0xfd, 0xf8, 0x73, 0x68, 0x86, 0x81, 0x37, 0x9f, 0x5e, 0xc8, 0x3b, 0x7e, 0x35, 0x99, 0x2e,
	0xbb, 0x89, 0x0e, 0x39, 0xcb, 0x96, 0x22, 0x6c, 0xd1, 0x5f, 0x93, 0x0b, 0xe1, 0x25, 0x3d, 0x9b,
	0x7f, 0x5b, 0x04, 0x86, 0xcf, 0x9c, 0x13, 0xe2, 0x4d, 0x02, 0x3f, 0xa6, 0x91, 0x33, 0xf7, 0x29,
	0x3b, 0xbc, 0xaf, 0x89, 0x30, 0xd8, 0xb1, 0xd9, 0x27, 0xde, 0x86, 0x6a, 0x10, 0x26, 0x0b, 0x2a,
	0x26, 0x91, 0xd1, 0xfa, 0x36, 0xb4, 0xab, 0x01, 0x0b, 0x52, 0x9b, 0x6f, 0x1d, 0xef, 0x4c, 0x7a,
	0x5c, 0xc7, 0x96, 0x2d, 0xeb, 0x6f, 0x6b, 0xd0, 0x37, 0x0b, 0x22, 0x69, 0xa0, 0xd3, 0xc9, 0x3e,
	0x6f, 0xf1, 0xbc, 0x51, 0x86, 0x39, 0x1d, 0x5b, 0x35, 0xd3, 0xa8, 0xb1, 0x26, 0x02, 0xd8, 0x24,
	0x6a, 0x0c, 0xde, 0x92, 0x28, 0x9a, 0xbb, 0xca, 0xeb, 0x92, 0x36, 0xe3, 0xc5, 0xd4, 0x89, 0x28,
	0xcb, 0x49, 0x1b, 0x7c, 0x15, 0x93, 0x36, 0x1b, 0x29, 0xf1, 0x5d, 0xc6, 0x69, 0x8a, 0xf5, 0x15,
	0x2d, 0xbc, 0x03, 0xf5, 0x28, 0xf0, 0x44, 0xcd, 0x72, 0xa0, 0xd5, 0x9e, 0x44, 0xde, 0x18, 0x78,
	0xc2, 0x79, 0xb8, 0x4c, 0x1a, 0x52, 0xb7, 0xb5, 0x90, 0x1a, 0x3f, 0x06, 0xe4, 0x99, 0x8b, 0x13,
	0x8f, 0x3b, 0xdc, 0x01, 0xd6, 0x8b, 0xd7, 0x4e, 0x15, 0x8d, 0xb2, 0x5a, 0xf8, 0x53, 0x18, 0x78,
	0xc1, 0xd4, 0xa1, 0xf3, 0xc0, 0xe7, 0x2a, 0xf1, 0x18, 0xf8, 0xaa, 0x66, 0xa8, 0x4c, 0x6e, 0x1e,
	0x07, 0x9e, 0x20, 0x91, 0xb7, 0xc4, 0xe3, 0x55, 0xc8, 0x8e, 0x9d, 0xa1, 0x5a, 0xef, 0x58, 0x98,
	0xc8, 0x5f, 0x17, 0x79, 0xc0, 0xff, 0x58, 0xb8, 0x7a, 0xba, 0x13, 0xbd, 0xdc, 0x43, 0xa3, 0x8c,
	0x03, 0xaa, 0x66, 0x7e, 0xae, 0x1d, 0x8e, 0xda, 0x52, 0x87, 0xe3, 0xd7, 0xb0, 0xaa, 0xea, 0xe1,
	0xcb, 0xf4, 0xbc, 0xa3, 0x2a, 0xdf, 0x22, 0x61, 0x1a, 0xec, 0xaa, 0xc7, 0xe0, 0x47, 0xec, 0x6f,
	0x52, 0x75, 0x64, 0x0d, 0x86, 0x1a, 0xfa, 0x9c, 0xf0, 0x7d, 0x68, 0x9e, 0x0a, 0xd4, 0xaa, 0x64,
	0x8a, 0xa7, 0xd9, 0x89, 0x4b, 0x3b, 0x52, 0x9c, 0x65, 0x3d, 0x91, 0x90, 0x11, 0x27, 0x24, 0xcd,
	0x7a, 0x94, 0xaa, 0xcc, 0x7a, 0x94, 0x94, 0xf5, 0x57, 0xd0, 0x37, 0x66, 0x85, 0x7f, 0x9e, 0xe9,
	0x7b, 0x33, 0x31, 0x90, 0x9b, 0x7b, 0xa6, 0xf3, 0x7b, 0x2c, 0xbc, 0x17, 0x42, 0xaa, 0xf7, 0x61,
	0x56, 0x39, 0x29, 0xcb, 0x49, 0x39, 0xeb, 0x37, 0x2d, 0x68, 0xe5, 0x5f, 0x8b, 0x7b, 0xd9, 0x54,
	0x8b, 0x9f, 0x1f, 0x95, 0x6a, 0xf1, 0x06, 0xb6, 0x8c, 0x97, 0x62, 0x35, 0xcf, 0xc9, 0xc2, 0xd5,
	0x9e, 0x1f, 0xb6, 0x00, 0xa6, 0x67, 0x31, 0x0d, 0x16, 0x1c, 0x4d, 0xeb, 0x5c, 0x5d, 0xa3, 0x28,
	0x98, 0x10, 0xe7, 0x8a, 0xc3, 0x04, 0x82, 0xda, 0x74, 0xe1, 0xca, 0xf3, 0xc4, 0x3e, 0x59, 0xb4,
	0x1c, 0xce, 0x45, 0xd1, 0xa2, 0x26, 0xa2, 0xe5, 0xc3, 0x83, 0x3d, 0x9b, 0xd1, 0x98, 0x77, 0xd1,
	0x40, 0xd4, 0x34, 0xda, 0xc2, 0xbb, 0x64, 0x13, 0xef, 0x00, 0x9a, 0xcf, 0x7c, 0x76, 0x5d, 0x84,
	0xc1, 0xf4, 0x94, 0x03, 0x99, 0xac, 0x3f, 0xe4, 0xe8, 0xbc, 0x46, 0xcd, 0x8b, 0x44, 0x70, 0x45,
	0x91, 0x48, 0x88, 0xe1, 0x1d, 0xe8, 0x30, 0xd8, 0xb3, 0x79, 0x95, 0xa7, 0x6b, 0x14, 0x5d, 0x38,
	0xcd, 0x4e, 0xd9, 0xf8, 0x19, 0xac, 0x4a, 0xff, 0x3d, 0x22, 0x1e, 0x99, 0x52, 0x81, 0xa6, 0xbc,
	0x26, 0x3f, 0xd0, 0xb6, 0x36, 0x27, 0x61, 0x17, 0xa9, 0xe1, 0x5f, 0xc1, 0x90, 0x9e, 0xfb, 0xdc,
	0x03, 0xe4, 0x9e, 0xc9, 0xa2, 0xfc, 0xfa, 0xae, 0xf8, 0xd1, 0xc1, 0x4b, 0x93, 0x6b, 0x67, 0xc5,
	0xf1, 0x73, 0x18, 0x9e, 0x85, 0xae, 0x43, 0xc9, 0xcb, 0x73, 0xdf, 0x26, 0xd3, 0x20, 0x72, 0x65,
	0x65, 0xfe, 0x27, 0x72, 0x2c, 0x7f, 0x66, 0x72, 0x4d, 0xb7, 0xcd, 0xea, 0x32, 0x73, 0x2e, 0xf1,
	0x88, 0x6e, 0x6e, 0x68, 0x98, 0xdb, 0x33, 0xb9, 0x19, 0x73, 0x19, 0x5d, 0x7c, 0x0c, 0x78, 0x1a,
	0x2c, 0x16, 0x73, 0xfa, 0xf2, 0xdc, 0xff, 0x2e, 0x9a, 0x53, 0x91, 0xa9, 0x8b, 0x0a, 0xfe, 0xad,
	0xe4, 0xe2, 0xcb, 0x0a, 0x98, 0x46, 0x0b, 0x2c, 0xe0, 0x63, 0x58, 0x89, 0x02, 0xcf, 0x3b, 0x71,
	0xa6, 0xaf, 0xd3, 0x81, 0x8a, 0x9a, 0xbe, 0xa5, 0xf6, 0x20, 0xe5, 0x97, 0x18, 0xce, 0x9b, 0xc0,
	0x87, 0x80, 0xa6, 0x1e, 0x71, 0xfc, 0x97, 0xe7, 0xfe, 0xf3, 0xe3, 0xc9, 0x84, 0x8f, 0x16, 0x1b,
	0x95, 0xe3, 0x49, 0x86, 0x6d, 0x9a, 0xcc, 0x69, 0x5b, 0x9f, 0x43, 0x43, 0x38, 0x0e, 0x4b, 0x79,
	0xa3, 0x60, 0xa1, 0x82, 0x1b, 0xf6, 0x8d, 0x07, 0x50, 0xa5, 0x81, 0x4c, 0x18, 0xaa, 0x34, 0xb0,
	0xfe, 0xae, 0x01, 0xed, 0x82, 0x27, 0x42, 0xf3, 0xf0, 0x5a, 0xc6, 0x13, 0xe1, 0x32, 0xc7, 0xb4,
	0x96, 0x3b, 0xa6, 0x23, 0x68, 0xf0, 0x3b, 0x98, 0x9f, 0xe0, 0x9e, 0x2d, 0x1a, 0xea, 0x60, 0x36,
	0x0a, 0x0e, 0x66, 0x02, 0xbe, 0xcd, 0x2b, 0xc1, 0x17, 0x4f, 0x00, 0xa5, 0x5e, 0x2a, 0x26, 0x23,
	0x43, 0xdc, 0x8d, 0x9c, 0x57, 0x0b, 0xb6, 0x9d, 0x53, 0xc0, 0xfb, 0x79, 0xbf, 0x6e, 0x2f, 0xe1,
	0xd7, 0x79, 0x8f, 0xde, 0xcf, 0x7b, 0x74, 0x67, 0x09, 0x8f, 0xce, 0xfb, 0xf2, 0x61, 0xa1, 0x2f,
	0xc3, 0x72, 0xbe, 0x5c, 0xe8, 0xc5, 0x87, 0x45, 0x5e, 0xdc, 0x5d, 0xd6, 0x8b, 0x8b, 0xfc, 0xf7,
	0x49, 0x81, 0xff, 0xf6, 0x96, 0xf1, 0xdf, 0x02, 0xcf, 0xfd, 0x9b, 0x0a, 0xac, 0x1a, 0x45, 0x6e,
	0x89, 0x38, 0x66, 0x40, 0x5d, 0x59, 0x3e, 0xa0, 0xd6, 0x23, 0x84, 0xea, 0x52, 0x11, 0xc2, 0x03,
	0x18, 0x99, 0x23, 0x90, 0xce, 0xf1, 0xfb, 0xea, 0x69, 0x45, 0xdc, 0xa8, 0x7d, 0x03, 0xe0, 0x93,
	0x6a, 0x2f, 0x6b, 0x58, 0xf7, 0x61, 0x65, 0x12, 0x2c, 0x42, 0x67, 0x4a, 0x9f, 0x05, 0x33, 0x35,
	0x05, 0x0b, 0x7a, 0x53, 0x41, 0x3c, 0xe0, 0xb1, 0xa3, 0x48, 0x49, 0x0d, 0x9a, 0x35, 0x02, 0xac,
	0x2b, 0x8a, 0x9e, 0xad, 0xc7, 0xb0, 0x96, 0xa9, 0xde, 0x4b, 0x93, 0x1f, 0x9c, 0x1a, 0x8c, 0x61,
	0x3d, 0x6b, 0x49, 0xf6, 0xe1, 0xc2, 0x8a, 0x51, 0xb8, 0xe5, 0xf6, 0xbf, 0xd4, 0x02, 0x11, 0x33,
	0x71, 0xd0, 0xc5, 0xb2, 0xd1, 0x08, 0xbb, 0x50, 0xa7, 0x81, 0x4f, 0xc9, 0x39, 0x95, 0x30, 0xa3,
	0x9a, 0xd6, 0xdf, 0x57, 0xa0, 0x67, 0xf4, 0xc0, 0xeb, 0xf4, 0x4e, 0x44, 0xd3, 0x3a, 0xbd, 0x13,
	0xf1, 0xb8, 0x9f, 0xf8, 0xea, 0x0d, 0x8b, 0x7d, 0x32, 0x6c, 0xf1, 0xc9, 0xbb, 0x23, 0x19, 0x04,
	0x4a, 0x6c, 0x49, 0x29, 0xf8, 0x3e, 0x74, 0xd3, 0x02, 0x60, 0x3c, 0xae, 0x5f, 0xf6, 0xc0, 0xa4,
	0x4b, 0x5a, 0x0f, 0x00, 0xeb, 0xf3, 0x96, 0x7b, 0xfd, 0xb9, 0x91, 0xe0, 0x96, 0x6c, 0xb6, 0x14,
	0xb1, 0x6c, 0x58, 0x13, 0xb8, 0xf0, 0x9c, 0x50, 0xc7, 0x4d, 0xdd, 0x1b, 0x7f, 0x05, 0xed, 0x85,
	0x24, 0xc9, 0xfd, 0xd9, 0x30, 0xec, 0x3c, 0x0b, 0xa6, 0x8e, 0xc7, 0xcb, 0x73, 0x6a, 0x09, 0x95,
	0x38, 0xdb, 0xa8, 0xac, 0x4d, 0xb9, 0x51, 0x01, 0xac, 0x0a, 0x8e, 0x88, 0xb8, 0x55, 0x5f, 0x9f,
	0x43, 0xd3, 0x13, 0x81, 0x79, 0x66, 0xc4, 0x5c, 0x4c, 0x8d, 0x58, 0x88, 0x68, 0xb9, 0x5a, 0x55,
	0xe6, 0x6a, 0x3a, 0xbc, 0x99, 0xb9, 0x9a, 0xb5, 0x0e, 0x23, 0xb3, 0x43, 0x39, 0x90, 0x17, 0x6a,
	0x88, 0x59, 0x14, 0xc3, 0x3f, 0x83, 0x0e, 0x4d, 0xa0, 0x45, 0x4c, 0x1c, 0xa5, 0x20, 0x2c, 0xe8,
	0x2a, 0x86, 0x4c, 0x04, 0xad, 0x6f, 0x61, 0x23, 0x67, 0x4f, 0x6e, 0xc7, 0xef, 0x66, 0xf0, 0x2f,
	0x60, 0xbd, 0x18, 0x66, 0xf1, 0x17, 0xb0, 0x92, 0x88, 0xd9, 0xc1, 0x19, 0x25, 0x4f, 0x65, 0x96,
	0xd9, 0xb3, 0xf3, 0x0c, 0xe6, 0xa3, 0xf4, 0xdc, 0x97, 0xb9, 0x47, 0xcf, 0x16, 0x0d, 0xeb, 0x3a,
	0x6c, 0xe4, 0xac, 0xcb, 0x95, 0x59, 0xc0, 0xf5, 0x52, 0x4c, 0xc6, 0x37, 0xa0, 0x23, 0x7e, 0xbc,
	0x99, 0xf6, 0x99, 0x12, 0xf0, 0x5d, 0x68, 0x4b, 0xcc, 0x3e, 0x92, 0x70, 0x85, 0x76, 0xf9, 0xcf,
	0x3a, 0x77, 0x5f, 0xaa, 0x9f, 0x75, 0x2a, 0x5f, 0x51, 0x72, 0xd6, 0x0d, 0xd8, 0x2c, 0xea, 0x4e,
	0x0e, 0xe6, 0x0d, 0x7c, 0x74, 0x09, 0x9e, 0x5f, 0x31, 0x1c, 0xb6, 0xf0, 0xaa, 0xdf, 0x2b, 0xc6,
	0x93, 0x0a, 0x5a, 0x5b, 0x70, 0xa3, 0xb8, 0x4b, 0x39, 0xa4, 0x6f, 0x61, 0xa3, 0xe4, 0x46, 0x30,
	0x3b, 0xac, 0x2c, 0xdb, 0xe1, 0x26, 0x8c, 0xf3, 0x06, 0x65, 0x67, 0x7f, 0x04, 0xbd, 0xa7, 0xc7,
	0x47, 0xe9, 0x8f, 0x59, 0xb5, 0x9a, 0x82, 0x4c, 0x16, 0x92, 0xb8, 0xa4, 0xaa, 0xc5, 0x25, 0xd6,
	0x10, 0xfa, 0x52, 0x4f, 0x1a, 0x7a, 0x02, 0x2b, 0x4f, 0x8f, 0x05, 0x56, 0x90, 0x25, 0x10, 0x52,
	0xef, 0x34, 0x97, 0xaf, 0x8d, 0x00, 0xeb, 0xb6, 0x64, 0x0f, 0xb7, 0xd8, 0x50, 0xf7, 0x2f, 0x19,
	0xaa, 0xf5, 0x09, 0x1b, 0xd4, 0xbe, 0xf6, 0x93, 0xae, 0x64, 0xec, 0x15, 0x7d, 0xec, 0x9f, 0x25,
	0x43, 0xd5, 0xac, 0xa9, 0x9a, 0x4b, 0x45, 0xab, 0xb9, 0x7c, 0x91, 0x8c, 0x63, 0xdf, 0xf8, 0x9d,
	0x98, 0x2a, 0x9d, 0xc8, 0xf2, 0x9e, 0x2c, 0x9d, 0xdc, 0x86, 0xe1, 0xd3, 0x63, 0xe1, 0xf4, 0xe5,
	0x43, 0xc4, 0x80, 0x52, 0x21, 0x39, 0xb1, 0x1d, 0x18, 0xc9, 0x6e, 0x4c, 0xed, 0xa2, 0x21, 0x6d,
	0xc0, 0x5a, 0x46, 0x56, 0x1a, 0xf9, 0x9a, 0x19, 0xe1, 0x61, 0xad, 0x69, 0x64, 0xc9, 0x2b, 0x44,
	0x18, 0x36, 0xf4, 0xa5, 0xe1, 0x7f, 0xac, 0xf0, 0xad, 0x9e, 0x3a, 0xfe, 0x87, 0xde, 0x4a, 0x23,
	0x68, 0x78, 0xf3, 0xc5, 0x9c, 0xca, 0x0b, 0x49, 0x34, 0xd8, 0x5d, 0xc5, 0x3f, 0x1e, 0x5e, 0x50,
	0x12, 0xab, 0x74, 0x35, 0xa5, 0xb0, 0x23, 0xf7, 0x6e, 0x4e, 0x4f, 0x8f, 0xf9, 0xbe, 0x35, 0x78,
	0x3a, 0x99, 0x12, 0xf8, 0x81, 0xf4, 0xbd, 0x8b, 0x09, 0xaf, 0xe6, 0x34, 0x05, 0x37, 0x21, 0x58,
	0xbf, 0xa9, 0xc0, 0x40, 0x8d, 0x55, 0xee, 0x56, 0xc1, 0x22, 0x6a, 0x3b, 0x58, 0xd5, 0x77, 0x30,
	0x2d, 0x13, 0xc9, 0x01, 0x8b, 0x32, 0xd1, 0x0d, 0xe8, 0xb0, 0x28, 0x84, 0x2d, 0x8a, 0x2b, 0x2b,
	0x57, 0x29, 0x81, 0x97, 0xae, 0x78, 0x0e, 0xeb, 0xbb, 0x49, 0xe9, 0x4a, 0xb6, 0x77, 0xfe, 0xa1,
	0x0d, 0x75, 0x1e, 0x65, 0xad, 0xc1, 0x0a, 0x8f, 0xbc, 0xc8, 0x6c, 0x1e, 0x53, 0x12, 0xf1, 0x1a,
	0x2b, 0xba, 0x86, 0xaf, 0xc3, 0x1a, 0x23, 0xe7, 0x7e, 0xc1, 0x82, 0x2a, 0x25, 0xac, 0x38, 0x44,
	0xd5, 0x84, 0x95, 0x7d, 0x75, 0x47, 0xb5, 0x12, 0x56, 0x1c, 0xa2, 0x3a, 0x5e, 0x85, 0x21, 0x63,
	0x69, 0xbf, 0x02, 0x40, 0x8d, 0x1c, 0x31, 0x0e, 0x51, 0x53, 0x11, 0xb5, 0x37, 0x75, 0xd4, 0xca,
	0x11, 0xe3, 0x10, 0xb5, 0x31, 0x86, 0x01, 0x23, 0xa6, 0x2f, 0xe1, 0xa8, 0x93, 0xa5, 0xc5, 0x21,
	0x02, 0x3c, 0x86, 0x11, 0xa7, 0x65, 0x5e, 0xbf, 0x51, 0xb7, 0x98, 0x13, 0x87, 0xa8, 0x87, 0x3f,
	0x82, 0x0d, 0xc6, 0x29, 0x78, 0xad, 0x46, 0xfd, 0x52, 0x66, 0x1c, 0xa2, 0x01, 0xde, 0x84, 0x75,
	0xb1, 0xd8, 0xd9, 0x37, 0x5b, 0x34, 0x2c, 0xe3, 0xc5, 0x21, 0x42, 0x6a, 0x2c, 0xd9, 0xd7, 0x65,
	0xb4, 0x52, 0xcc, 0x89, 0x43, 0x84, 0x15, 0x27, 0xfb, 0x98, 0x8a, 0x56, 0xd5, 0x82, 0x69, 0x8f,
	0x2d, 0x68, 0x84, 0x37, 0x60, 0x35, 0x15, 0x4f, 0xde, 0x3b, 0xd1, 0x5a, 0x21, 0x23, 0x0e, 0xd1,
	0xba, 0x62, 0x64, 0x5e, 0x48, 0xd1, 0x46, 0x21, 0x23, 0x0e, 0xd1, 0x58, 0x4d, 0x31, 0xff, 0x24,
	0x8a, 0xae, 0x97, 0xf1, 0xe2, 0x10, 0x6d, 0xaa, 0x35, 0x2d, 0x78, 0xc5, 0x44, 0x1f, 0x95, 0x32,
	0xe3, 0x10, 0xdd, 0x50, 0x56, 0xf3, 0x2f, 0x94, 0xe8, 0x27, 0x65, 0xbc, 0x38, 0x44, 0x5b, 0x78,
	0x04, 0x28, 0x9d, 0xb4, 0x78, 0xd6, 0x43, 0x37, 0xf3, 0xd4, 0x38, 0x44, 0xb7, 0x14, 0x55, 0x7f,
	0x48, 0x44, 0xbf, 0x97, 0xa7, 0xc6, 0x21, 0xb2, 0xd4, 0x69, 0x33, 0xde, 0x0b, 0xd1, 0xed, 0x02,
	0x72, 0x1c, 0xa2, 0x8f, 0xf1, 0x4d, 0xf8, 0x88, 0xbb, 0x60, 0xf1, 0x73, 0x1f, 0xfa, 0xe4, 0x52,
	0x81, 0x38, 0x44, 0x9f, 0x2a, 0x81, 0x92, 0x57, 0x3c, 0xf4, 0xd9, 0xa5, 0x02, 0x71, 0x88, 0xb6,
	0x77, 0x26, 0xfc, 0x17, 0xa5, 0x7a, 0xe1, 0x1a, 0x77, 0xa0, 0x71, 0x1c, 0x50, 0x12, 0xa1, 0x6b,
	0x18, 0xa0, 0x29, 0xd2, 0x11, 0x54, 0xc1, 0x3d, 0x68, 0x7f, 0x13, 0x78, 0x5e, 0xf0, 0x8e, 0x44,
	0xa8, 0x8a, 0xbb, 0xd0, 0x7a, 0x46, 0x9c, 0xc8, 0x27, 0x11, 0xaa, 0xed, 0x3c, 0x80, 0x95, 0x5c,
	0xad, 0x1f, 0x37, 0xa1, 0x7a, 0xe0, 0xa3, 0x6b, 0xcc, 0xdc, 0x8b, 0x80, 0x1e, 0xf8, 0xa8, 0xc2,
	0xcc, 0x3d, 0x3a, 0x9f, 0xc7, 0x34, 0x46, 0x55, 0xdc, 0x87, 0xce, 0x8b, 0x80, 0xca, 0x66, 0x6d,
	0xe7, 0x2e, 0xb4, 0x64, 0xd1, 0x82, 0x29, 0xf0, 0xd0, 0x04, 0x5d, 0xc3, 0x6d, 0xa8, 0xdb, 0xc4,
	0x71, 0x51, 0x85, 0x11, 0x1f, 0xb8, 0x8b, 0xb9, 0x8f, 0xaa, 0xb8, 0x05, 0xb5, 0x97, 0xe7, 0x3e,
	0xaa, 0xed, 0xfc, 0x53, 0x0d, 0xba, 0x07, 0x3e, 0x25, 0x91, 0xef, 0x78, 0x93, 0x85, 0xcb, 0x1c,
	0x7f, 0xb2, 0x70, 0xf5, 0x1c, 0x11, 0x5d, 0xc3, 0x2b, 0xd0, 0xe7, 0x44, 0x95, 0xbc, 0xa1, 0x0a,
	0xdb, 0x0e, 0xd6, 0x97, 0x91, 0x6f, 0xa1, 0xaa, 0x94, 0x4c, 0xd1, 0x00, 0x35, 0xa4, 0xa4, 0x19,
	0xf0, 0x0b, 0x9c, 0x4a, 0xc8, 0x22, 0xf8, 0x46, 0x2d, 0xbc, 0x0e, 0x38, 0x21, 0x26, 0xa1, 0x27,
	0x72, 0x25, 0x3d, 0x13, 0x92, 0x22, 0x16, 0x21, 0x20, 0x31, 0x30, 0x11, 0x20, 0xb2, 0xd8, 0x08,
	0xbd, 0x92, 0xd2, 0x5a, 0x94, 0xc6, 0xe9, 0x33, 0x76, 0xe8, 0x98, 0x74, 0x26, 0x98, 0x42, 0xa7,
	0xb8, 0x0f, 0xed, 0xc9, 0xc2, 0xe5, 0x41, 0x0d, 0xfa, 0xbe, 0x82, 0x31, 0x9f, 0x44, 0x1a, 0xc3,
	0xa0, 0x7f, 0xa9, 0x24, 0x22, 0xfb, 0x84, 0xa2, 0x7f, 0xcd, 0x88, 0x30, 0xda, 0xbf, 0x55, 0x30,
	0x82, 0x2e, 0xa7, 0x89, 0x61, 0xa2, 0x7f, 0x67, 0x8b, 0x84, 0x52, 0x29, 0x49, 0xfe, 0x6d, 0x4a,
	0xd6, 0xee, 0x6b, 0xf4, 0x1f, 0x15, 0x3c, 0x80, 0x8e, 0x18, 0xc5, 0xd4, 0xf1, 0xd1, 0x7f, 0x2a,
	0x7b, 0x36, 0x89, 0x49, 0xf4, 0x96, 0xb8, 0xe8, 0xff, 0x5a, 0x3b, 0x5f, 0x41, 0x4f, 0xcf, 0x62,
	0xd8, 0x2e, 0x3e, 0x70, 0x5d, 0xe1, 0x63, 0xe2, 0x14, 0x89, 0x5d, 0x66, 0x3a, 0x14, 0x55, 0xd9,
	0x27, 0x9b, 0x2d, 0x73, 0xaf, 0x43, 0x58, 0x2d, 0xa8, 0xa1, 0x62, 0x04, 0x3d, 0xd1, 0x96, 0x3b,
	0x78, 0x2d, 0xa5, 0xd8, 0x8e, 0xef, 0x06, 0x0b, 0xb1, 0xd5, 0x89, 0x4c, 0x4c, 0x1e, 0x07, 0x1e,
	0xdf, 0xea, 0x87, 0xe8, 0x87, 0xff, 0xdd, 0xba, 0xf6, 0xfd, 0xfb, 0xad, 0xca, 0x0f, 0xef, 0xb7,
	0x2a, 0xff, 0xf3, 0x7e, 0xab, 0x72, 0xd2, 0xe4, 0xff, 0xc9, 0xea, 0xde, 0xff, 0x07, 0x00, 0x00,
	0xff, 0xff, 0xb0, 0x36, 0xf1, 0xa5, 0x97, 0x36, 0x00, 0x00,
}

func (m *ProphetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProphetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ID))
	}
	if m.StoreID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.StoreID))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Type))
	}
	dAtA[i] = 0x22
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.ShardHeartbeat.Size()))
	n1, err := m.ShardHeartbeat.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	dAtA[i] = 0x2a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.StoreHeartbeat.Size()))
	n2, err := m.StoreHeartbeat.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x32
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.PutStore.Size()))
	n3, err := m.PutStore.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x3a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.GetStore.Size()))
	n4, err := m.GetStore.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	dAtA[i] = 0x42
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.AllocID.Size()))
	n5, err := m.AllocID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n5
	dAtA[i] = 0x4a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.AskBatchSplit.Size()))
	n6, err := m.AskBatchSplit.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n6
	dAtA[i] = 0x52
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.CreateDestroying.Size()))
	n7, err := m.CreateDestroying.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n7
	dAtA[i] = 0x5a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.ReportDestroyed.Size()))
	n8, err := m.ReportDestroyed.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n8
	dAtA[i] = 0x62
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.GetDestroying.Size()))
	n9, err := m.GetDestroying.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n9
	dAtA[i] = 0x6a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.CreateWatcher.Size()))
	n10, err := m.CreateWatcher.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n10
	dAtA[i] = 0x72
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.CreateShards.Size()))
	n11, err := m.CreateShards.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n11
	dAtA[i] = 0x7a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.RemoveShards.Size()))
	n12, err := m.RemoveShards.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n12
	dAtA[i] = 0x82
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.CheckShardState.Size()))
	n13, err := m.CheckShardState.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n13
	dAtA[i] = 0x8a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.PutPlacementRule.Size()))
	n14, err := m.PutPlacementRule.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n14
	dAtA[i] = 0x92
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.GetAppliedRules.Size()))
	n15, err := m.GetAppliedRules.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n15
	dAtA[i] = 0x9a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.CreateJob.Size()))
	n16, err := m.CreateJob.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n16
	dAtA[i] = 0xa2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.RemoveJob.Size()))
	n17, err := m.RemoveJob.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n17
	dAtA[i] = 0xaa
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.ExecuteJob.Size()))
	n18, err := m.ExecuteJob.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n18
	dAtA[i] = 0xb2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.AddScheduleGroupRule.Size()))
	n19, err := m.AddScheduleGroupRule.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n19
	dAtA[i] = 0xba
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.GetScheduleGroupRule.Size()))
	n20, err := m.GetScheduleGroupRule.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n20
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ProphetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProphetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ID))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Type))
	}
	if len(m.Error) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Error)))
		i += copy(dAtA[i:], m.Error)
	}
	if len(m.Leader) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Leader)))
		i += copy(dAtA[i:], m.Leader)
	}
	dAtA[i] = 0x2a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.ShardHeartbeat.Size()))
	n21, err := m.ShardHeartbeat.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n21
	dAtA[i] = 0x32
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.StoreHeartbeat.Size()))
	n22, err := m.StoreHeartbeat.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n22
	dAtA[i] = 0x3a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.PutStore.Size()))
	n23, err := m.PutStore.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n23
	dAtA[i] = 0x42
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.GetStore.Size()))
	n24, err := m.GetStore.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n24
	dAtA[i] = 0x4a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.AllocID.Size()))
	n25, err := m.AllocID.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n25
	dAtA[i] = 0x52
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.AskBatchSplit.Size()))
	n26, err := m.AskBatchSplit.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n26
	dAtA[i] = 0x5a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.CreateDestroying.Size()))
	n27, err := m.CreateDestroying.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n27
	dAtA[i] = 0x62
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.ReportDestroyed.Size()))
	n28, err := m.ReportDestroyed.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n28
	dAtA[i] = 0x6a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.GetDestroying.Size()))
	n29, err := m.GetDestroying.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n29
	dAtA[i] = 0x72
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Event.Size()))
	n30, err := m.Event.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n30
	dAtA[i] = 0x7a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.CreateShards.Size()))
	n31, err := m.CreateShards.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n31
	dAtA[i] = 0x82
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.RemoveShards.Size()))
	n32, err := m.RemoveShards.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n32
	dAtA[i] = 0x8a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.CheckShardState.Size()))
	n33, err := m.CheckShardState.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n33
	dAtA[i] = 0x92
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.PutPlacementRule.Size()))
	n34, err := m.PutPlacementRule.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n34
	dAtA[i] = 0x9a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.GetAppliedRules.Size()))
	n35, err := m.GetAppliedRules.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n35
	dAtA[i] = 0xa2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.CreateJob.Size()))
	n36, err := m.CreateJob.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n36
	dAtA[i] = 0xaa
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.RemoveJob.Size()))
	n37, err := m.RemoveJob.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n37
	dAtA[i] = 0xb2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.ExecuteJob.Size()))
	n38, err := m.ExecuteJob.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n38
	dAtA[i] = 0xba
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.AddScheduleGroupRule.Size()))
	n39, err := m.AddScheduleGroupRule.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n39
	dAtA[i] = 0xc2
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.GetScheduleGroupRule.Size()))
	n40, err := m.GetScheduleGroupRule.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n40
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShardHeartbeatReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardHeartbeatReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.StoreID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.StoreID))
	}
	if len(m.Shard) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Shard)))
		i += copy(dAtA[i:], m.Shard)
	}
	if m.Term != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Term))
	}
	if m.Leader != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Leader.Size()))
		n41, err := m.Leader.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n41
	}
	if len(m.DownReplicas) > 0 {
		for _, msg := range m.DownReplicas {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PendingReplicas) > 0 {
		for _, msg := range m.PendingReplicas {
			dAtA[i] = 0x32
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x3a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Stats.Size()))
	n42, err := m.Stats.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n42
	if len(m.GroupKey) > 0 {
		dAtA[i] = 0x42
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.GroupKey)))
		i += copy(dAtA[i:], m.GroupKey)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShardHeartbeatRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardHeartbeatRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ShardID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ShardID))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.ShardEpoch.Size()))
	n43, err := m.ShardEpoch.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n43
	if m.TargetReplica != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.TargetReplica.Size()))
		n44, err := m.TargetReplica.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n44
	}
	if m.ConfigChange != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ConfigChange.Size()))
		n45, err := m.ConfigChange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n45
	}
	if m.TransferLeader != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.TransferLeader.Size()))
		n46, err := m.TransferLeader.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n46
	}
	if m.Merge != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Merge.Size()))
		n47, err := m.Merge.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n47
	}
	if m.SplitShard != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.SplitShard.Size()))
		n48, err := m.SplitShard.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n48
	}
	if m.ConfigChangeV2 != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ConfigChangeV2.Size()))
		n49, err := m.ConfigChangeV2.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n49
	}
	if m.DestroyDirectly {
		dAtA[i] = 0x48
		i++
		if m.DestroyDirectly {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PutStoreReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutStoreReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Store) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Store)))
		i += copy(dAtA[i:], m.Store)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PutStoreRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutStoreRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.DestroyShards) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.DestroyShards)))
		i += copy(dAtA[i:], m.DestroyShards)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StoreHeartbeatReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreHeartbeatReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Stats.Size()))
	n50, err := m.Stats.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n50
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StoreHeartbeatRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreHeartbeatRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetStoreReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStoreReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetStoreRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStoreRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Stats != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Stats.Size()))
		n51, err := m.Stats.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n51
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AllocIDReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocIDReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AllocIDRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllocIDRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AskBatchSplitReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AskBatchSplitReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Count != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AskBatchSplitRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AskBatchSplitRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SplitIDs) > 0 {
		for _, msg := range m.SplitIDs {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateDestroyingReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateDestroyingReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ID))
	}
	if m.Index != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Index))
	}
	if len(m.Replicas) > 0 {
		dAtA53 := make([]byte, len(m.Replicas)*10)
		var j52 int
		for _, num := range m.Replicas {
			for num >= 1<<7 {
				dAtA53[j52] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j52++
			}
			dAtA53[j52] = uint8(num)
			j52++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(j52))
		i += copy(dAtA[i:], dAtA53[:j52])
	}
	if m.RemoveData {
		dAtA[i] = 0x20
		i++
		if m.RemoveData {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateDestroyingRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateDestroyingRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetDestroyingReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDestroyingReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetDestroyingRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetDestroyingRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Status != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Status.Size()))
		n54, err := m.Status.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n54
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ReportDestroyedReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportDestroyedReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ID))
	}
	if m.ReplicaID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ReplicaID))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ReportDestroyedRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReportDestroyedRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SplitID) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitID) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.NewID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.NewID))
	}
	if len(m.NewReplicaIDs) > 0 {
		dAtA56 := make([]byte, len(m.NewReplicaIDs)*10)
		var j55 int
		for _, num := range m.NewReplicaIDs {
			for num >= 1<<7 {
				dAtA56[j55] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j55++
			}
			dAtA56[j55] = uint8(num)
			j55++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(j55))
		i += copy(dAtA[i:], dAtA56[:j55])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateWatcherReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateWatcherReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Flag != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Flag))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateShardsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateShardsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Shards) > 0 {
		for _, b := range m.Shards {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.LeastReplicas) > 0 {
		dAtA58 := make([]byte, len(m.LeastReplicas)*10)
		var j57 int
		for _, num := range m.LeastReplicas {
			for num >= 1<<7 {
				dAtA58[j57] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j57++
			}
			dAtA58[j57] = uint8(num)
			j57++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(j57))
		i += copy(dAtA[i:], dAtA58[:j57])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateShardsRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateShardsRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RemoveShardsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveShardsReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IDs) > 0 {
		dAtA60 := make([]byte, len(m.IDs)*10)
		var j59 int
		for _, num := range m.IDs {
			for num >= 1<<7 {
				dAtA60[j59] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j59++
			}
			dAtA60[j59] = uint8(num)
			j59++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(j59))
		i += copy(dAtA[i:], dAtA60[:j59])
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RemoveShardsRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveShardsRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CheckShardStateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckShardStateReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IDs) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.IDs)))
		i += copy(dAtA[i:], m.IDs)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CheckShardStateRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckShardStateRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Destroyed) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Destroyed)))
		i += copy(dAtA[i:], m.Destroyed)
	}
	if len(m.Destroying) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Destroying)))
		i += copy(dAtA[i:], m.Destroying)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PutPlacementRuleReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutPlacementRuleReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Rule.Size()))
	n61, err := m.Rule.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n61
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PutPlacementRuleRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutPlacementRuleRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetAppliedRulesReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAppliedRulesReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ShardID != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ShardID))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetAppliedRulesRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetAppliedRulesRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateJobReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateJobReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Job.Size()))
	n62, err := m.Job.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n62
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CreateJobRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateJobRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RemoveJobReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveJobReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Job.Size()))
	n63, err := m.Job.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n63
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RemoveJobRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RemoveJobRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExecuteJobReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteJobReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Job.Size()))
	n64, err := m.Job.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n64
	if len(m.Data) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ExecuteJobRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecuteJobRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AddScheduleGroupRuleReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddScheduleGroupRuleReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Rule.Size()))
	n65, err := m.Rule.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n65
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AddScheduleGroupRuleRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AddScheduleGroupRuleRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetScheduleGroupRuleReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetScheduleGroupRuleReq) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *GetScheduleGroupRuleRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetScheduleGroupRuleRsp) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, msg := range m.Rules {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *EventNotify) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventNotify) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seq != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Seq))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Type))
	}
	if m.InitEvent != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.InitEvent.Size()))
		n66, err := m.InitEvent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n66
	}
	if m.ShardEvent != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ShardEvent.Size()))
		n67, err := m.ShardEvent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n67
	}
	if m.StoreEvent != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.StoreEvent.Size()))
		n68, err := m.StoreEvent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n68
	}
	if m.ShardStatsEvent != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ShardStatsEvent.Size()))
		n69, err := m.ShardStatsEvent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n69
	}
	if m.StoreStatsEvent != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.StoreStatsEvent.Size()))
		n70, err := m.StoreStatsEvent.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n70
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InitEventData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitEventData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Shards) > 0 {
		for _, b := range m.Shards {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Leaders) > 0 {
		dAtA72 := make([]byte, len(m.Leaders)*10)
		var j71 int
		for _, num := range m.Leaders {
			for num >= 1<<7 {
				dAtA72[j71] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j71++
			}
			dAtA72[j71] = uint8(num)
			j71++
		}
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(j71))
		i += copy(dAtA[i:], dAtA72[:j71])
	}
	if len(m.Stores) > 0 {
		for _, b := range m.Stores {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ShardEventData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ShardEventData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.Leader != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Leader))
	}
	if m.Removed {
		dAtA[i] = 0x18
		i++
		if m.Removed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Create {
		dAtA[i] = 0x20
		i++
		if m.Create {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *StoreEventData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StoreEventData) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConfigChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigChange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Replica.Size()))
	n73, err := m.Replica.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n73
	if m.ChangeType != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ChangeType))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TransferLeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferLeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Replica.Size()))
	n74, err := m.Replica.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n74
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConfigChangeV2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigChangeV2) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for _, msg := range m.Changes {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Merge) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Merge) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Target) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Target)))
		i += copy(dAtA[i:], m.Target)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SplitShard) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitShard) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Policy != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Policy))
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			dAtA[i] = 0x12
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *LabelConstraint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LabelConstraint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.Op != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Op))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			dAtA[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *PlacementRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlacementRule) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if len(m.GroupID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.GroupID)))
		i += copy(dAtA[i:], m.GroupID)
	}
	if m.Index != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Index))
	}
	if m.Override {
		dAtA[i] = 0x20
		i++
		if m.Override {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.StartKey) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.StartKey)))
		i += copy(dAtA[i:], m.StartKey)
	}
	if len(m.EndKey) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.EndKey)))
		i += copy(dAtA[i:], m.EndKey)
	}
	if m.Role != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Role))
	}
	if m.Count != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Count))
	}
	if len(m.LabelConstraints) > 0 {
		for _, msg := range m.LabelConstraints {
			dAtA[i] = 0x4a
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.LocationLabels) > 0 {
		for _, s := range m.LocationLabels {
			dAtA[i] = 0x52
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.IsolationLevel) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.IsolationLevel)))
		i += copy(dAtA[i:], m.IsolationLevel)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RequestBatchHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestBatchHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if m.ShardID != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ShardID))
	}
	dAtA[i] = 0x1a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Replica.Size()))
	n75, err := m.Replica.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n75
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResponseBatchHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseBatchHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Error.Size()))
	n76, err := m.Error.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n76
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RequestBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestBatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Header.Size()))
	n77, err := m.Header.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n77
	if len(m.Requests) > 0 {
		for _, msg := range m.Requests {
			dAtA[i] = 0x12
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ResponseBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseBatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Header.Size()))
	n78, err := m.Header.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n78
	if len(m.Responses) > 0 {
		for _, msg := range m.Responses {
			dAtA[i] = 0x12
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if m.Group != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Group))
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Type))
	}
	if m.CustomType != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.CustomType))
	}
	if len(m.Key) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Cmd) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Cmd)))
		i += copy(dAtA[i:], m.Cmd)
	}
	if m.PID != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.PID))
	}
	if m.ToShard != 0 {
		dAtA[i] = 0x40
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ToShard))
	}
	if m.IgnoreEpochCheck {
		dAtA[i] = 0x48
		i++
		if m.IgnoreEpochCheck {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	dAtA[i] = 0x52
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Epoch.Size()))
	n79, err := m.Epoch.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n79
	if m.KeysRange != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.KeysRange.Size()))
		n80, err := m.KeysRange.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n80
	}
	if m.ReplicaSelectPolicy != 0 {
		dAtA[i] = 0x60
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ReplicaSelectPolicy))
	}
	if m.TxnBatchRequest != nil {
		dAtA[i] = 0x6a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.TxnBatchRequest.Size()))
		n81, err := m.TxnBatchRequest.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n81
	}
	dAtA[i] = 0x72
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.UpdateTxnRecord.Size()))
	n82, err := m.UpdateTxnRecord.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n82
	dAtA[i] = 0x7a
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.DeleteTxnRecord.Size()))
	n83, err := m.DeleteTxnRecord.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n83
	dAtA[i] = 0x82
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.CommitTxnWriteData.Size()))
	n84, err := m.CommitTxnWriteData.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n84
	dAtA[i] = 0x8a
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.RollbackTxnRecord.Size()))
	n85, err := m.RollbackTxnRecord.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n85
	dAtA[i] = 0x92
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.CleanTxnMVCCData.Size()))
	n86, err := m.CleanTxnMVCCData.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n86
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Range) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Range) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.From) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.From)))
		i += copy(dAtA[i:], m.From)
	}
	if len(m.To) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.To)))
		i += copy(dAtA[i:], m.To)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.ID) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.ID)))
		i += copy(dAtA[i:], m.ID)
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Type))
	}
	if m.CustomType != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.CustomType))
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.PID != 0 {
		dAtA[i] = 0x28
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.PID))
	}
	dAtA[i] = 0x32
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Error.Size()))
	n87, err := m.Error.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n87
	if m.TxnBatchResponse != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.TxnBatchResponse.Size()))
		n88, err := m.TxnBatchResponse.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n88
	}
	if m.UpdateTxnRecord != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.UpdateTxnRecord.Size()))
		n89, err := m.UpdateTxnRecord.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n89
	}
	if m.DeleteTxnRecord != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.DeleteTxnRecord.Size()))
		n90, err := m.DeleteTxnRecord.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n90
	}
	if m.CommitTxnWriteData != nil {
		dAtA[i] = 0x52
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.CommitTxnWriteData.Size()))
		n91, err := m.CommitTxnWriteData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n91
	}
	if m.RollbackTxnRecord != nil {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.RollbackTxnRecord.Size()))
		n92, err := m.RollbackTxnRecord.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n92
	}
	if m.CleanTxnMVCCData != nil {
		dAtA[i] = 0x62
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.CleanTxnMVCCData.Size()))
		n93, err := m.CleanTxnMVCCData.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n93
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConfigChangeRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigChangeRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ChangeType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.ChangeType))
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Replica.Size()))
	n94, err := m.Replica.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n94
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ConfigChangeResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigChangeResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Shard.Size()))
	n95, err := m.Shard.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n95
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CompactLogRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactLogRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.CompactIndex != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.CompactIndex))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CompactLogResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactLogResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TransferLeaderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferLeaderRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Replica.Size()))
	n96, err := m.Replica.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n96
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TransferLeaderResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TransferLeaderResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BatchSplitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSplitRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, msg := range m.Requests {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Context) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Context)))
		i += copy(dAtA[i:], m.Context)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *SplitRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SplitRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Start) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Start)))
		i += copy(dAtA[i:], m.Start)
	}
	if len(m.End) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.End)))
		i += copy(dAtA[i:], m.End)
	}
	if m.NewShardID != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.NewShardID))
	}
	if len(m.NewReplicas) > 0 {
		for _, msg := range m.NewReplicas {
			dAtA[i] = 0x22
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *BatchSplitResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchSplitResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Shards) > 0 {
		for _, msg := range m.Shards {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateMetadataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateMetadataRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Metadata.Size()))
	n97, err := m.Metadata.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n97
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateMetadataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateMetadataResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateLabelsRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateLabelsRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for _, msg := range m.Labels {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Policy != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Policy))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateLabelsResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateLabelsResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateTxnRecordRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTxnRecordRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.TxnRecord.Size()))
	n98, err := m.TxnRecord.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n98
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *UpdateTxnRecordResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateTxnRecordResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.TxnRecord.Size()))
	n99, err := m.TxnRecord.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n99
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DeleteTxnRecordRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteTxnRecordRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TxnRecordRouteKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.TxnRecordRouteKey)))
		i += copy(dAtA[i:], m.TxnRecordRouteKey)
	}
	if len(m.TxnID) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.TxnID)))
		i += copy(dAtA[i:], m.TxnID)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *DeleteTxnRecordResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteTxnRecordResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommitTxnWriteDataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitTxnWriteDataRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OriginKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.OriginKey)))
		i += copy(dAtA[i:], m.OriginKey)
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.CommitTS.Size()))
	n100, err := m.CommitTS.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n100
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CommitTxnWriteDataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitTxnWriteDataResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RollbackTxnWriteDataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RollbackTxnWriteDataRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.OriginKey) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.OriginKey)))
		i += copy(dAtA[i:], m.OriginKey)
	}
	dAtA[i] = 0x12
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Timestamp.Size()))
	n101, err := m.Timestamp.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n101
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *RollbackTxnWriteDataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RollbackTxnWriteDataResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CleanTxnMVCCDataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CleanTxnMVCCDataRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRpcpb(dAtA, i, uint64(m.Timestamp.Size()))
	n102, err := m.Timestamp.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n102
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CleanTxnMVCCDataResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CleanTxnMVCCDataResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KVSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVSetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if len(m.Value) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KVSetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVSetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KVBatchSetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVBatchSetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, msg := range m.Requests {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KVBatchSetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVBatchSetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KVGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KVGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Value)))
		i += copy(dAtA[i:], m.Value)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KVBatchGetRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVBatchGetRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KVBatchGetResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVBatchGetResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, b := range m.Values {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KVDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Key)))
		i += copy(dAtA[i:], m.Key)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KVDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KVBatchDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVBatchDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KVBatchDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVBatchDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KVRangeDeleteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVRangeDeleteRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Start) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Start)))
		i += copy(dAtA[i:], m.Start)
	}
	if len(m.End) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.End)))
		i += copy(dAtA[i:], m.End)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KVRangeDeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVRangeDeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KVScanRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVScanRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Start) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.Start)))
		i += copy(dAtA[i:], m.Start)
	}
	if len(m.End) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.End)))
		i += copy(dAtA[i:], m.End)
	}
	if m.Limit != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Limit))
	}
	if m.LimitBytes != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.LimitBytes))
	}
	if m.WithValue {
		dAtA[i] = 0x28
		i++
		if m.WithValue {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.OnlyCount {
		dAtA[i] = 0x30
		i++
		if m.OnlyCount {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KVScanResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVScanResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if len(m.Values) > 0 {
		for _, b := range m.Values {
			dAtA[i] = 0x12
			i++
			i = encodeVarintRpcpb(dAtA, i, uint64(len(b)))
			i += copy(dAtA[i:], b)
		}
	}
	if m.Count != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(m.Count))
	}
	if m.Completed {
		dAtA[i] = 0x20
		i++
		if m.Completed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.ShardEnd) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRpcpb(dAtA, i, uint64(len(m.ShardEnd)))
		i += copy(dAtA[i:], m.ShardEnd)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintRpcpb(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *ProphetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRpcpb(uint64(m.ID))
	}
	if m.StoreID != 0 {
		n += 1 + sovRpcpb(uint64(m.StoreID))
	}
	if m.Type != 0 {
		n += 1 + sovRpcpb(uint64(m.Type))
	}
	l = m.ShardHeartbeat.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.StoreHeartbeat.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.PutStore.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.GetStore.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.AllocID.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.AskBatchSplit.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.CreateDestroying.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.ReportDestroyed.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.GetDestroying.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.CreateWatcher.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.CreateShards.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.RemoveShards.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.CheckShardState.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.PutPlacementRule.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.GetAppliedRules.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.CreateJob.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.RemoveJob.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.ExecuteJob.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.AddScheduleGroupRule.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.GetScheduleGroupRule.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ProphetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRpcpb(uint64(m.ID))
	}
	if m.Type != 0 {
		n += 1 + sovRpcpb(uint64(m.Type))
	}
	l = len(m.Error)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = m.ShardHeartbeat.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.StoreHeartbeat.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.PutStore.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.GetStore.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.AllocID.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.AskBatchSplit.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.CreateDestroying.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.ReportDestroyed.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.GetDestroying.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.Event.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.CreateShards.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.RemoveShards.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.CheckShardState.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.PutPlacementRule.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.GetAppliedRules.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.CreateJob.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.RemoveJob.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.ExecuteJob.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.AddScheduleGroupRule.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.GetScheduleGroupRule.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardHeartbeatReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StoreID != 0 {
		n += 1 + sovRpcpb(uint64(m.StoreID))
	}
	l = len(m.Shard)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Term != 0 {
		n += 1 + sovRpcpb(uint64(m.Term))
	}
	if m.Leader != nil {
		l = m.Leader.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if len(m.DownReplicas) > 0 {
		for _, e := range m.DownReplicas {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if len(m.PendingReplicas) > 0 {
		for _, e := range m.PendingReplicas {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	l = m.Stats.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = len(m.GroupKey)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardHeartbeatRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardID != 0 {
		n += 1 + sovRpcpb(uint64(m.ShardID))
	}
	l = m.ShardEpoch.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.TargetReplica != nil {
		l = m.TargetReplica.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.ConfigChange != nil {
		l = m.ConfigChange.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.TransferLeader != nil {
		l = m.TransferLeader.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Merge != nil {
		l = m.Merge.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.SplitShard != nil {
		l = m.SplitShard.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.ConfigChangeV2 != nil {
		l = m.ConfigChangeV2.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.DestroyDirectly {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutStoreReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Store)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutStoreRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DestroyShards)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StoreHeartbeatReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Stats.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StoreHeartbeatRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetStoreReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRpcpb(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetStoreRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Stats != nil {
		l = m.Stats.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllocIDReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AllocIDRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRpcpb(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AskBatchSplitReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovRpcpb(uint64(m.Count))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AskBatchSplitRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SplitIDs) > 0 {
		for _, e := range m.SplitIDs {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateDestroyingReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRpcpb(uint64(m.ID))
	}
	if m.Index != 0 {
		n += 1 + sovRpcpb(uint64(m.Index))
	}
	if len(m.Replicas) > 0 {
		l = 0
		for _, e := range m.Replicas {
			l += sovRpcpb(uint64(e))
		}
		n += 1 + sovRpcpb(uint64(l)) + l
	}
	if m.RemoveData {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateDestroyingRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovRpcpb(uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetDestroyingReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRpcpb(uint64(m.ID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetDestroyingRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != nil {
		l = m.Status.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportDestroyedReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ID != 0 {
		n += 1 + sovRpcpb(uint64(m.ID))
	}
	if m.ReplicaID != 0 {
		n += 1 + sovRpcpb(uint64(m.ReplicaID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReportDestroyedRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.State != 0 {
		n += 1 + sovRpcpb(uint64(m.State))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SplitID) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewID != 0 {
		n += 1 + sovRpcpb(uint64(m.NewID))
	}
	if len(m.NewReplicaIDs) > 0 {
		l = 0
		for _, e := range m.NewReplicaIDs {
			l += sovRpcpb(uint64(e))
		}
		n += 1 + sovRpcpb(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateWatcherReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flag != 0 {
		n += 1 + sovRpcpb(uint64(m.Flag))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateShardsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Shards) > 0 {
		for _, b := range m.Shards {
			l = len(b)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if len(m.LeastReplicas) > 0 {
		l = 0
		for _, e := range m.LeastReplicas {
			l += sovRpcpb(uint64(e))
		}
		n += 1 + sovRpcpb(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateShardsRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoveShardsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IDs) > 0 {
		l = 0
		for _, e := range m.IDs {
			l += sovRpcpb(uint64(e))
		}
		n += 1 + sovRpcpb(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoveShardsRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckShardStateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IDs)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckShardStateRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Destroyed)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = len(m.Destroying)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutPlacementRuleReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Rule.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PutPlacementRuleRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAppliedRulesReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ShardID != 0 {
		n += 1 + sovRpcpb(uint64(m.ShardID))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetAppliedRulesRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateJobReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Job.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CreateJobRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoveJobReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Job.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RemoveJobRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteJobReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Job.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ExecuteJobRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddScheduleGroupRuleReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Rule.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AddScheduleGroupRuleRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetScheduleGroupRuleReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GetScheduleGroupRuleRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *EventNotify) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seq != 0 {
		n += 1 + sovRpcpb(uint64(m.Seq))
	}
	if m.Type != 0 {
		n += 1 + sovRpcpb(uint64(m.Type))
	}
	if m.InitEvent != nil {
		l = m.InitEvent.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.ShardEvent != nil {
		l = m.ShardEvent.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.StoreEvent != nil {
		l = m.StoreEvent.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.ShardStatsEvent != nil {
		l = m.ShardStatsEvent.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.StoreStatsEvent != nil {
		l = m.StoreStatsEvent.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InitEventData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Shards) > 0 {
		for _, b := range m.Shards {
			l = len(b)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if len(m.Leaders) > 0 {
		l = 0
		for _, e := range m.Leaders {
			l += sovRpcpb(uint64(e))
		}
		n += 1 + sovRpcpb(uint64(l)) + l
	}
	if len(m.Stores) > 0 {
		for _, b := range m.Stores {
			l = len(b)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ShardEventData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Leader != 0 {
		n += 1 + sovRpcpb(uint64(m.Leader))
	}
	if m.Removed {
		n += 2
	}
	if m.Create {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StoreEventData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Replica.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.ChangeType != 0 {
		n += 1 + sovRpcpb(uint64(m.ChangeType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransferLeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Replica.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigChangeV2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Changes) > 0 {
		for _, e := range m.Changes {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Merge) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SplitShard) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Policy != 0 {
		n += 1 + sovRpcpb(uint64(m.Policy))
	}
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *LabelConstraint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Op != 0 {
		n += 1 + sovRpcpb(uint64(m.Op))
	}
	if len(m.Values) > 0 {
		for _, s := range m.Values {
			l = len(s)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PlacementRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = len(m.GroupID)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovRpcpb(uint64(m.Index))
	}
	if m.Override {
		n += 2
	}
	l = len(m.StartKey)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Role != 0 {
		n += 1 + sovRpcpb(uint64(m.Role))
	}
	if m.Count != 0 {
		n += 1 + sovRpcpb(uint64(m.Count))
	}
	if len(m.LabelConstraints) > 0 {
		for _, e := range m.LabelConstraints {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if len(m.LocationLabels) > 0 {
		for _, s := range m.LocationLabels {
			l = len(s)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	l = len(m.IsolationLevel)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RequestBatchHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.ShardID != 0 {
		n += 1 + sovRpcpb(uint64(m.ShardID))
	}
	l = m.Replica.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseBatchHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = m.Error.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RequestBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Header.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if len(m.Responses) > 0 {
		for _, e := range m.Responses {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Group != 0 {
		n += 1 + sovRpcpb(uint64(m.Group))
	}
	if m.Type != 0 {
		n += 1 + sovRpcpb(uint64(m.Type))
	}
	if m.CustomType != 0 {
		n += 1 + sovRpcpb(uint64(m.CustomType))
	}
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = len(m.Cmd)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.PID != 0 {
		n += 1 + sovRpcpb(uint64(m.PID))
	}
	if m.ToShard != 0 {
		n += 1 + sovRpcpb(uint64(m.ToShard))
	}
	if m.IgnoreEpochCheck {
		n += 2
	}
	l = m.Epoch.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.KeysRange != nil {
		l = m.KeysRange.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.ReplicaSelectPolicy != 0 {
		n += 1 + sovRpcpb(uint64(m.ReplicaSelectPolicy))
	}
	if m.TxnBatchRequest != nil {
		l = m.TxnBatchRequest.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = m.UpdateTxnRecord.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.DeleteTxnRecord.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	l = m.CommitTxnWriteData.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.RollbackTxnRecord.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	l = m.CleanTxnMVCCData.Size()
	n += 2 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Range) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovRpcpb(uint64(m.Type))
	}
	if m.CustomType != 0 {
		n += 1 + sovRpcpb(uint64(m.CustomType))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.PID != 0 {
		n += 1 + sovRpcpb(uint64(m.PID))
	}
	l = m.Error.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.TxnBatchResponse != nil {
		l = m.TxnBatchResponse.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.UpdateTxnRecord != nil {
		l = m.UpdateTxnRecord.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.DeleteTxnRecord != nil {
		l = m.DeleteTxnRecord.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.CommitTxnWriteData != nil {
		l = m.CommitTxnWriteData.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.RollbackTxnRecord != nil {
		l = m.RollbackTxnRecord.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.CleanTxnMVCCData != nil {
		l = m.CleanTxnMVCCData.Size()
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigChangeRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChangeType != 0 {
		n += 1 + sovRpcpb(uint64(m.ChangeType))
	}
	l = m.Replica.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ConfigChangeResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Shard.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CompactLogRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CompactIndex != 0 {
		n += 1 + sovRpcpb(uint64(m.CompactIndex))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CompactLogResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransferLeaderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Replica.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TransferLeaderResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BatchSplitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	l = len(m.Context)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SplitRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Start)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = len(m.End)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.NewShardID != 0 {
		n += 1 + sovRpcpb(uint64(m.NewShardID))
	}
	if len(m.NewReplicas) > 0 {
		for _, e := range m.NewReplicas {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BatchSplitResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Shards) > 0 {
		for _, e := range m.Shards {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateMetadataRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Metadata.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateMetadataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateLabelsRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Labels) > 0 {
		for _, e := range m.Labels {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.Policy != 0 {
		n += 1 + sovRpcpb(uint64(m.Policy))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateLabelsResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateTxnRecordRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TxnRecord.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateTxnRecordResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TxnRecord.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteTxnRecordRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxnRecordRouteKey)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = len(m.TxnID)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteTxnRecordResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommitTxnWriteDataRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OriginKey)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = m.CommitTS.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CommitTxnWriteDataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RollbackTxnWriteDataRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OriginKey)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = m.Timestamp.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *RollbackTxnWriteDataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CleanTxnMVCCDataRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Timestamp.Size()
	n += 1 + l + sovRpcpb(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CleanTxnMVCCDataResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KVSetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KVSetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KVBatchSetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KVBatchSetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KVGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KVGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KVBatchGetRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KVBatchGetResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Values) > 0 {
		for _, b := range m.Values {
			l = len(b)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KVDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KVDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KVBatchDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KVBatchDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KVRangeDeleteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Start)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = len(m.End)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KVRangeDeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KVScanRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Start)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	l = len(m.End)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.Limit != 0 {
		n += 1 + sovRpcpb(uint64(m.Limit))
	}
	if m.LimitBytes != 0 {
		n += 1 + sovRpcpb(uint64(m.LimitBytes))
	}
	if m.WithValue {
		n += 2
	}
	if m.OnlyCount {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KVScanResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Keys) > 0 {
		for _, b := range m.Keys {
			l = len(b)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if len(m.Values) > 0 {
		for _, b := range m.Values {
			l = len(b)
			n += 1 + l + sovRpcpb(uint64(l))
		}
	}
	if m.Count != 0 {
		n += 1 + sovRpcpb(uint64(m.Count))
	}
	if m.Completed {
		n += 2
	}
	l = len(m.ShardEnd)
	if l > 0 {
		n += 1 + l + sovRpcpb(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovRpcpb(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRpcpb(x uint64) (n int) {
	return sovRpcpb(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ProphetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProphetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProphetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ShardHeartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StoreHeartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PutStore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PutStore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetStore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetStore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AllocID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskBatchSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AskBatchSplit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateDestroying", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreateDestroying.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportDestroyed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReportDestroyed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetDestroying", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetDestroying.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateWatcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreateWatcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreateShards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemoveShards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckShardState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CheckShardState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PutPlacementRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PutPlacementRule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetAppliedRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetAppliedRules.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreateJob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemoveJob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecuteJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExecuteJob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddScheduleGroupRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AddScheduleGroupRule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetScheduleGroupRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetScheduleGroupRule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProphetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProphetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProphetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Error = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ShardHeartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreHeartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.StoreHeartbeat.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PutStore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PutStore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetStore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetStore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AllocID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AskBatchSplit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AskBatchSplit.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateDestroying", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreateDestroying.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReportDestroyed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ReportDestroyed.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetDestroying", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetDestroying.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Event", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Event.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreateShards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveShards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemoveShards.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CheckShardState", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CheckShardState.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PutPlacementRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PutPlacementRule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetAppliedRules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetAppliedRules.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreateJob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 21:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RemoveJob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 22:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecuteJob", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ExecuteJob.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 23:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddScheduleGroupRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AddScheduleGroupRule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 24:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetScheduleGroupRule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.GetScheduleGroupRule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardHeartbeatReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardHeartbeatReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardHeartbeatReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreID", wireType)
			}
			m.StoreID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StoreID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shard = append(m.Shard[:0], dAtA[iNdEx:postIndex]...)
			if m.Shard == nil {
				m.Shard = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Leader == nil {
				m.Leader = &metapb.Replica{}
			}
			if err := m.Leader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownReplicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DownReplicas = append(m.DownReplicas, metapb.ReplicaStats{})
			if err := m.DownReplicas[len(m.DownReplicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PendingReplicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PendingReplicas = append(m.PendingReplicas, metapb.Replica{})
			if err := m.PendingReplicas[len(m.PendingReplicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardHeartbeatRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardHeartbeatRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardHeartbeatRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardEpoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ShardEpoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetReplica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TargetReplica == nil {
				m.TargetReplica = &metapb.Replica{}
			}
			if err := m.TargetReplica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigChange == nil {
				m.ConfigChange = &ConfigChange{}
			}
			if err := m.ConfigChange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TransferLeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TransferLeader == nil {
				m.TransferLeader = &TransferLeader{}
			}
			if err := m.TransferLeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Merge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Merge == nil {
				m.Merge = &Merge{}
			}
			if err := m.Merge.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitShard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SplitShard == nil {
				m.SplitShard = &SplitShard{}
			}
			if err := m.SplitShard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigChangeV2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ConfigChangeV2 == nil {
				m.ConfigChangeV2 = &ConfigChangeV2{}
			}
			if err := m.ConfigChangeV2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestroyDirectly", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.DestroyDirectly = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutStoreReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutStoreReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutStoreReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Store", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Store = append(m.Store[:0], dAtA[iNdEx:postIndex]...)
			if m.Store == nil {
				m.Store = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutStoreRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutStoreRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutStoreRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DestroyShards", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DestroyShards = append(m.DestroyShards[:0], dAtA[iNdEx:postIndex]...)
			if m.DestroyShards == nil {
				m.DestroyShards = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreHeartbeatReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreHeartbeatReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreHeartbeatReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreHeartbeatRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreHeartbeatRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreHeartbeatRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStoreReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStoreReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStoreReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStoreRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStoreRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStoreRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stats", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Stats == nil {
				m.Stats = &metapb.StoreStats{}
			}
			if err := m.Stats.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocIDReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocIDReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocIDReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllocIDRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllocIDRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllocIDRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AskBatchSplitReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AskBatchSplitReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AskBatchSplitReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AskBatchSplitRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AskBatchSplitRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AskBatchSplitRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SplitIDs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SplitIDs = append(m.SplitIDs, SplitID{})
			if err := m.SplitIDs[len(m.SplitIDs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateDestroyingReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateDestroyingReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateDestroyingReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Replicas = append(m.Replicas, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRpcpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRpcpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Replicas) == 0 {
					m.Replicas = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Replicas = append(m.Replicas, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Replicas", wireType)
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveData", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RemoveData = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateDestroyingRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateDestroyingRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateDestroyingRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= metapb.ShardState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDestroyingReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDestroyingReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDestroyingReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetDestroyingRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetDestroyingRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetDestroyingRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Status == nil {
				m.Status = &metapb.DestroyingStatus{}
			}
			if err := m.Status.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportDestroyedReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportDestroyedReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportDestroyedReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			m.ID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaID", wireType)
			}
			m.ReplicaID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReportDestroyedRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReportDestroyedRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReportDestroyedRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= metapb.ShardState(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitID) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitID: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitID: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewID", wireType)
			}
			m.NewID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.NewReplicaIDs = append(m.NewReplicaIDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRpcpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRpcpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.NewReplicaIDs) == 0 {
					m.NewReplicaIDs = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.NewReplicaIDs = append(m.NewReplicaIDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field NewReplicaIDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateWatcherReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateWatcherReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateWatcherReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateShardsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateShardsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateShardsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, make([]byte, postIndex-iNdEx))
			copy(m.Shards[len(m.Shards)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.LeastReplicas = append(m.LeastReplicas, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRpcpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRpcpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.LeastReplicas) == 0 {
					m.LeastReplicas = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.LeastReplicas = append(m.LeastReplicas, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field LeastReplicas", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateShardsRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateShardsRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateShardsRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveShardsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveShardsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveShardsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IDs = append(m.IDs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRpcpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRpcpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IDs) == 0 {
					m.IDs = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IDs = append(m.IDs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IDs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveShardsRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveShardsRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveShardsRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckShardStateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckShardStateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckShardStateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IDs", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IDs = append(m.IDs[:0], dAtA[iNdEx:postIndex]...)
			if m.IDs == nil {
				m.IDs = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckShardStateRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckShardStateRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckShardStateRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destroyed", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destroyed = append(m.Destroyed[:0], dAtA[iNdEx:postIndex]...)
			if m.Destroyed == nil {
				m.Destroyed = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Destroying", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Destroying = append(m.Destroying[:0], dAtA[iNdEx:postIndex]...)
			if m.Destroying == nil {
				m.Destroying = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutPlacementRuleReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutPlacementRuleReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutPlacementRuleReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutPlacementRuleRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutPlacementRuleRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutPlacementRuleRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAppliedRulesReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAppliedRulesReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAppliedRulesReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetAppliedRulesRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetAppliedRulesRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetAppliedRulesRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, PlacementRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateJobReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateJobReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateJobReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateJobRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateJobRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateJobRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveJobReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveJobReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveJobReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RemoveJobRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RemoveJobRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RemoveJobRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteJobReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteJobReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteJobReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Job", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Job.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecuteJobRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecuteJobRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecuteJobRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddScheduleGroupRuleReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddScheduleGroupRuleReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddScheduleGroupRuleReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rule", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Rule.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AddScheduleGroupRuleRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AddScheduleGroupRuleRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AddScheduleGroupRuleRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetScheduleGroupRuleReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetScheduleGroupRuleReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetScheduleGroupRuleReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetScheduleGroupRuleRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetScheduleGroupRuleRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetScheduleGroupRuleRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, metapb.ScheduleGroupRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventNotify) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventNotify: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventNotify: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.InitEvent == nil {
				m.InitEvent = &InitEventData{}
			}
			if err := m.InitEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardEvent == nil {
				m.ShardEvent = &ShardEventData{}
			}
			if err := m.ShardEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StoreEvent == nil {
				m.StoreEvent = &StoreEventData{}
			}
			if err := m.StoreEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardStatsEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ShardStatsEvent == nil {
				m.ShardStatsEvent = &metapb.ShardStats{}
			}
			if err := m.ShardStatsEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StoreStatsEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StoreStatsEvent == nil {
				m.StoreStatsEvent = &metapb.StoreStats{}
			}
			if err := m.StoreStatsEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitEventData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitEventData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitEventData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, make([]byte, postIndex-iNdEx))
			copy(m.Shards[len(m.Shards)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Leaders = append(m.Leaders, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRpcpb
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRpcpb
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Leaders) == 0 {
					m.Leaders = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRpcpb
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Leaders = append(m.Leaders, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Leaders", wireType)
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stores", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Stores = append(m.Stores, make([]byte, postIndex-iNdEx))
			copy(m.Stores[len(m.Stores)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardEventData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardEventData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardEventData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			m.Leader = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Leader |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Removed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Removed = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Create", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Create = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StoreEventData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StoreEventData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StoreEventData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Replica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeType", wireType)
			}
			m.ChangeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeType |= metapb.ConfigChangeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferLeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferLeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferLeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Replica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigChangeV2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigChangeV2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigChangeV2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Changes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Changes = append(m.Changes, ConfigChange{})
			if err := m.Changes[len(m.Changes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Merge) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Merge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Merge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = append(m.Target[:0], dAtA[iNdEx:postIndex]...)
			if m.Target == nil {
				m.Target = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitShard) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitShard: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitShard: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			m.Policy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Policy |= metapb.CheckPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LabelConstraint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LabelConstraint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LabelConstraint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= LabelConstraintOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlacementRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlacementRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlacementRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Override", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Override = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StartKey = append(m.StartKey[:0], dAtA[iNdEx:postIndex]...)
			if m.StartKey == nil {
				m.StartKey = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = append(m.EndKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EndKey == nil {
				m.EndKey = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			m.Role = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Role |= ReplicaRoleType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LabelConstraints", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LabelConstraints = append(m.LabelConstraints, LabelConstraint{})
			if err := m.LabelConstraints[len(m.LabelConstraints)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocationLabels", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocationLabels = append(m.LocationLabels, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsolationLevel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IsolationLevel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestBatchHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestBatchHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestBatchHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardID", wireType)
			}
			m.ShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ShardID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Replica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseBatchHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseBatchHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseBatchHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, Request{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Responses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Responses = append(m.Responses, Response{})
			if err := m.Responses[len(m.Responses)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			m.Group = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Group |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= CmdType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomType", wireType)
			}
			m.CustomType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CustomType |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cmd = append(m.Cmd[:0], dAtA[iNdEx:postIndex]...)
			if m.Cmd == nil {
				m.Cmd = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PID", wireType)
			}
			m.PID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToShard", wireType)
			}
			m.ToShard = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToShard |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IgnoreEpochCheck", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IgnoreEpochCheck = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Epoch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeysRange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.KeysRange == nil {
				m.KeysRange = &Range{}
			}
			if err := m.KeysRange.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReplicaSelectPolicy", wireType)
			}
			m.ReplicaSelectPolicy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReplicaSelectPolicy |= ReplicaSelectPolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnBatchRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxnBatchRequest == nil {
				m.TxnBatchRequest = &txnpb.TxnBatchRequest{}
			}
			if err := m.TxnBatchRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTxnRecord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.UpdateTxnRecord.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteTxnRecord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.DeleteTxnRecord.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTxnWriteData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CommitTxnWriteData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RollbackTxnRecord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.RollbackTxnRecord.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CleanTxnMVCCData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CleanTxnMVCCData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Range) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Range: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Range: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = append(m.From[:0], dAtA[iNdEx:postIndex]...)
			if m.From == nil {
				m.From = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = append(m.To[:0], dAtA[iNdEx:postIndex]...)
			if m.To == nil {
				m.To = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = append(m.ID[:0], dAtA[iNdEx:postIndex]...)
			if m.ID == nil {
				m.ID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= CmdType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CustomType", wireType)
			}
			m.CustomType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CustomType |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PID", wireType)
			}
			m.PID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PID |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Error.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnBatchResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxnBatchResponse == nil {
				m.TxnBatchResponse = &txnpb.TxnBatchResponse{}
			}
			if err := m.TxnBatchResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTxnRecord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateTxnRecord == nil {
				m.UpdateTxnRecord = &UpdateTxnRecordRequest{}
			}
			if err := m.UpdateTxnRecord.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeleteTxnRecord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeleteTxnRecord == nil {
				m.DeleteTxnRecord = &DeleteTxnRecordRequest{}
			}
			if err := m.DeleteTxnRecord.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTxnWriteData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CommitTxnWriteData == nil {
				m.CommitTxnWriteData = &CommitTxnWriteDataRequest{}
			}
			if err := m.CommitTxnWriteData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RollbackTxnRecord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RollbackTxnRecord == nil {
				m.RollbackTxnRecord = &RollbackTxnWriteDataRequest{}
			}
			if err := m.RollbackTxnRecord.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CleanTxnMVCCData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CleanTxnMVCCData == nil {
				m.CleanTxnMVCCData = &CleanTxnMVCCDataRequest{}
			}
			if err := m.CleanTxnMVCCData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigChangeRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigChangeRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigChangeRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeType", wireType)
			}
			m.ChangeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChangeType |= metapb.ConfigChangeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Replica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigChangeResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigChangeResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigChangeResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shard", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Shard.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactLogRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactLogRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactLogRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompactIndex", wireType)
			}
			m.CompactIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompactIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactLogResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactLogResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactLogResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferLeaderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferLeaderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferLeaderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Replica", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Replica.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TransferLeaderResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TransferLeaderResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TransferLeaderResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSplitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSplitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSplitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, SplitRequest{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = append(m.Context[:0], dAtA[iNdEx:postIndex]...)
			if m.Context == nil {
				m.Context = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SplitRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SplitRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SplitRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Start = append(m.Start[:0], dAtA[iNdEx:postIndex]...)
			if m.Start == nil {
				m.Start = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.End = append(m.End[:0], dAtA[iNdEx:postIndex]...)
			if m.End == nil {
				m.End = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewShardID", wireType)
			}
			m.NewShardID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewShardID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewReplicas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewReplicas = append(m.NewReplicas, metapb.Replica{})
			if err := m.NewReplicas[len(m.NewReplicas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchSplitResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchSplitResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchSplitResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shards = append(m.Shards, metapb.Shard{})
			if err := m.Shards[len(m.Shards)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateMetadataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateMetadataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateMetadataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateMetadataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateMetadataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateMetadataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateLabelsRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateLabelsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateLabelsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Labels = append(m.Labels, metapb.Label{})
			if err := m.Labels[len(m.Labels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Policy", wireType)
			}
			m.Policy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Policy |= UpdatePolicy(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateLabelsResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateLabelsResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateLabelsResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTxnRecordRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTxnRecordRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTxnRecordRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnRecord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxnRecord.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateTxnRecordResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateTxnRecordResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateTxnRecordResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnRecord", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TxnRecord.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteTxnRecordRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteTxnRecordRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteTxnRecordRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnRecordRouteKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxnRecordRouteKey = append(m.TxnRecordRouteKey[:0], dAtA[iNdEx:postIndex]...)
			if m.TxnRecordRouteKey == nil {
				m.TxnRecordRouteKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxnID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxnID = append(m.TxnID[:0], dAtA[iNdEx:postIndex]...)
			if m.TxnID == nil {
				m.TxnID = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteTxnRecordResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteTxnRecordResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteTxnRecordResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitTxnWriteDataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitTxnWriteDataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitTxnWriteDataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginKey = append(m.OriginKey[:0], dAtA[iNdEx:postIndex]...)
			if m.OriginKey == nil {
				m.OriginKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitTS", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CommitTS.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitTxnWriteDataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitTxnWriteDataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitTxnWriteDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RollbackTxnWriteDataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RollbackTxnWriteDataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RollbackTxnWriteDataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginKey = append(m.OriginKey[:0], dAtA[iNdEx:postIndex]...)
			if m.OriginKey == nil {
				m.OriginKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RollbackTxnWriteDataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RollbackTxnWriteDataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RollbackTxnWriteDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CleanTxnMVCCDataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CleanTxnMVCCDataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CleanTxnMVCCDataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Timestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CleanTxnMVCCDataResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CleanTxnMVCCDataResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CleanTxnMVCCDataResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVSetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVSetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVSetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVBatchSetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVBatchSetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVBatchSetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, KVSetRequest{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVBatchSetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVBatchSetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVBatchSetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVBatchGetRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVBatchGetRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVBatchGetRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVBatchGetResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVBatchGetResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVBatchGetResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, make([]byte, postIndex-iNdEx))
			copy(m.Values[len(m.Values)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = append(m.Key[:0], dAtA[iNdEx:postIndex]...)
			if m.Key == nil {
				m.Key = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVBatchDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVBatchDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVBatchDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVBatchDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVBatchDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVBatchDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVRangeDeleteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVRangeDeleteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVRangeDeleteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Start = append(m.Start[:0], dAtA[iNdEx:postIndex]...)
			if m.Start == nil {
				m.Start = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.End = append(m.End[:0], dAtA[iNdEx:postIndex]...)
			if m.End == nil {
				m.End = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVRangeDeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVRangeDeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVRangeDeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVScanRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVScanRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVScanRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Start = append(m.Start[:0], dAtA[iNdEx:postIndex]...)
			if m.Start == nil {
				m.Start = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.End = append(m.End[:0], dAtA[iNdEx:postIndex]...)
			if m.End == nil {
				m.End = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitBytes", wireType)
			}
			m.LimitBytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LimitBytes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WithValue", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.WithValue = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnlyCount", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.OnlyCount = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVScanResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVScanResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVScanResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Keys", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Keys = append(m.Keys, make([]byte, postIndex-iNdEx))
			copy(m.Keys[len(m.Keys)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Values", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Values = append(m.Values, make([]byte, postIndex-iNdEx))
			copy(m.Values[len(m.Values)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Count |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Completed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Completed = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShardEnd", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRpcpb
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRpcpb
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShardEnd = append(m.ShardEnd[:0], dAtA[iNdEx:postIndex]...)
			if m.ShardEnd == nil {
				m.ShardEnd = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRpcpb(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRpcpb
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRpcpb(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRpcpb
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRpcpb
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRpcpb
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthRpcpb
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRpcpb
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRpcpb(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthRpcpb
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRpcpb = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRpcpb   = fmt.Errorf("proto: integer overflow")
)
